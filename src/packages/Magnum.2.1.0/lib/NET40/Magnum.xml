<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Magnum</name>
  </assembly>
  <members>
    <member name="T:Magnum.Algorithms.Implementations.NodeList`2">
      <summary>
            Maintains a list of nodes for a given set of instances of T
            </summary>
      <typeparam name="T">The type encapsulated in the node</typeparam>
      <typeparam name="TNode">The type of node contained in the list</typeparam>
    </member>
    <member name="M:Magnum.Algorithms.Implementations.NodeList`2.Index(`0)">
      <summary>
            Retrieve the index for a given key
            </summary>
      <param name="key">The key</param>
      <returns>The index</returns>
    </member>
    <member name="P:Magnum.Algorithms.Implementations.NodeList`2.Item(`0)">
      <summary>
            Retrieves the node for the given key
            </summary>
      <param name="key">The key</param>
      <returns>The unique node that relates to the specified key</returns>
    </member>
    <member name="T:Magnum.Algorithms.Implementations.NodeTable`1">
      <summary>
            Maintains an index of nodes so that regular ints can be used to execute algorithms
            against objects with int-compare speed vs. .Equals() speed
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:Magnum.Algorithms.Implementations.NodeTable`1.Item(`0)">
      <summary>
            Returns the index for the specified key, which can be any type that supports
            equality comparison
            </summary>
      <param name="key">The key to retrieve</param>
      <returns>The index that uniquely relates to the specified key</returns>
    </member>
    <member name="T:Magnum.Benchmark`1">
      <summary>
            A class that can be benchmarked by the console
            </summary>
    </member>
    <member name="M:Magnum.Benchmark`1.WarmUp(`0)">
      <summary>
            Any single-run operations that should be performed to prepare for the benchmark
            </summary>
      <param name="instance">The instance being tested</param>
    </member>
    <member name="M:Magnum.Benchmark`1.Shutdown(`0)">
      <summary>
            Any post-run operations that should be performed to clean up
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Magnum.Benchmark`1.Run(`0,System.Int32)">
      <summary>
            Run the operation being benchmarked the specified number of iterations
            </summary>
      <param name="instance">The instance being tested</param>
      <param name="iterationCount">The number of iterations to execute</param>
    </member>
    <member name="P:Magnum.Benchmark`1.Iterations">
      <summary>
            A list of iteration counts to execute with each benchmark
            </summary>
    </member>
    <member name="T:Magnum.Caching.ReadCache`2">
      <summary>
            A read-only view of a cache. Methods that are able to modify the cache contents are not
            available in this reduced interface. Methods on this interface will NOT invoke a missing
            item provider.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.Has(`0)">
      <summary>
            Checks if the key exists in the cache
            </summary>
      <param name="key">The key to check</param>
      <returns>True if the key exists, otherwise false</returns>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.HasValue(`1)">
      <summary>
            Checks if a value exists in the cache
            </summary>
      <param name="value">The value to check</param>
      <returns>True if the value exists, otherwise false</returns>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.Each(System.Action{`1})">
      <summary>
            Calls the specified callback with each value in the cache
            </summary>
      <param name="callback">A callback that accepts the value for each item in the cache</param>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.Each(System.Action{`0,`1})">
      <summary>
            Calls the specified callback with each item in the cache
            </summary>
      <param name="callback">A callback that accepts the key and value for each item in the cache</param>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.Exists(System.Predicate{`1})">
      <summary>
            Uses a predicate to scan the cache for a matching value
            </summary>
      <param name="predicate">The predicate to run against each value</param>
      <returns>True if a matching value exists, otherwise false</returns>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.Find(System.Predicate{`1},`1@)">
      <summary>
            Uses a predicate to scan the cache for a matching value
            </summary>
      <param name="predicate">The predicate to run against each value</param>
      <param name="result">The matching value</param>
      <returns>True if a matching value was found, otherwise false</returns>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.GetAllKeys">
      <summary>
            Gets all keys that are stored in the cache
            </summary>
      <returns>An array of every key in the dictionary</returns>
    </member>
    <member name="M:Magnum.Caching.ReadCache`2.GetAll">
      <summary>
            Gets all values that are stored in the cache
            </summary>
      <returns>An array of every value in the dictionary</returns>
    </member>
    <member name="P:Magnum.Caching.ReadCache`2.Count">
      <summary>
            The number of items in the cache
            </summary>
    </member>
    <member name="T:Magnum.Caching.Cache`2">
      <summary>
            A cache implementation that extends the capability of most dictionary style classes to
            have a more complete set of methods commonly used in a dictionary scenario.
            </summary>
      <typeparam name="TKey">The key type of the cache</typeparam>
      <typeparam name="TValue">The value type of the cache</typeparam>
    </member>
    <member name="M:Magnum.Caching.Cache`2.Get(`0)">
      <summary>
            Get the value for the specified key
            </summary>
      <param name="key">The key referencing the value in the cache</param>
      <returns>The matching value if the key exists in the cache, otherwise an exception is thrown</returns>
    </member>
    <member name="M:Magnum.Caching.Cache`2.Get(`0,Magnum.Caching.MissingValueProvider{`0,`1})">
      <summary>
            Get the value for the specified key, overriding the default missing value provider
            </summary>
      <param name="key">The key referencing the value in the cache</param>
      <param name="missingValueProvider">An overloaded missing value provider to create the value if it is not found in the cache</param>
      <returns>The matching value if the key exists in the cache, otherwise an exception is thrown</returns>
    </member>
    <member name="M:Magnum.Caching.Cache`2.Add(`0,`1)">
      <summary>
            Adds a value to the cache using the specified key. If the key already exists in the cache, an exception is thrown.
            </summary>
      <param name="key">The key referencing the value</param>
      <param name="value">The value</param>
    </member>
    <member name="M:Magnum.Caching.Cache`2.AddValue(`1)">
      <summary>
            Adds a value to the cache using the KeySelector to extract the key from the value. If the key already exists
            in the cache, an exception is thrown.
            </summary>
      <param name="value">The value</param>
    </member>
    <member name="M:Magnum.Caching.Cache`2.Remove(`0)">
      <summary>
            Remove an existing value from the cache
            </summary>
      <param name="key">The key referencing the value</param>
    </member>
    <member name="M:Magnum.Caching.Cache`2.RemoveValue(`1)">
      <summary>
            Remove an existing value from the cache, using the KeySelector to extract the key to find the value
            </summary>
      <param name="value">The value to remove</param>
    </member>
    <member name="M:Magnum.Caching.Cache`2.Clear">
      <summary>
            Removes all items from the cache
            </summary>
    </member>
    <member name="M:Magnum.Caching.Cache`2.Fill(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Fills the cache from a list of values, using the KeySelector to extract the key for each value.
            </summary>
      <param name="values">
      </param>
    </member>
    <member name="M:Magnum.Caching.Cache`2.WithValue(`0,System.Action{`1})">
      <summary>
            Calls the callback with the value matching the specified key
            </summary>
      <param name="key">The key referencing the value</param>
      <param name="callback">The callback to call</param>
      <returns>True if the value exists and the callback was called</returns>
    </member>
    <member name="M:Magnum.Caching.Cache`2.WithValue``1(`0,System.Func{`1,``0},``0)">
      <summary>
            Calls the function with the value matching the specified key, returning the result of that function
            </summary>
      <typeparam name="TResult">The result type of the function</typeparam>
      <param name="key">The key references the value</param>
      <param name="callback">The function to call</param>
      <param name="defaultValue">The default return value if the item does not exist in the cache</param>
      <returns>The return value of the function, or the defaultValue specified if the item does not exist in the cache</returns>
    </member>
    <member name="P:Magnum.Caching.Cache`2.MissingValueProvider">
      <summary>
            Sets the missing value provider used by the cache to create requested values that do not exist in the cache
            </summary>
    </member>
    <member name="P:Magnum.Caching.Cache`2.ValueAddedCallback">
      <summary>
            Sets the callback that is called when a new value is added to the cache
            </summary>
    </member>
    <member name="P:Magnum.Caching.Cache`2.ValueRemovedCallback">
      <summary>
            Sets the callback that is called when a value is removed or replaced from the cache
            </summary>
    </member>
    <member name="P:Magnum.Caching.Cache`2.DuplicateValueAdded">
      <summary>
            Sets the callback that is called when a duplicate value is added to the cache
            </summary>
    </member>
    <member name="P:Magnum.Caching.Cache`2.KeySelector">
      <summary>
            Specifies a selector that returns the key from a value which is used when a value is added to the cache
            </summary>
    </member>
    <member name="P:Magnum.Caching.Cache`2.Item(`0)">
      <summary>
            References a value in the cache, returning a newly created or existing value for the specified key, and
            adding a new or replacing an existing value in the cache
            </summary>
      <param name="key">The key references the value</param>
      <returns>The value from the cache</returns>
    </member>
    <member name="M:Magnum.Caching.GenericTypeCache`1.#ctor(System.Type)">
      <summary>
            Constructs a cache for the specified generic type
            </summary>
      <param name="genericType">The generic type to close</param>
    </member>
    <member name="M:Magnum.Caching.GenericTypeCache`1.#ctor(System.Type,Magnum.Caching.MissingValueProvider{System.Type,`0})">
      <summary>
            Constructs a cache for the specified generic type.
            </summary>
      <param name="genericType">The generic type to close</param>
      <param name="missingValueProvider">The implementation provider, which must close the generic type with the passed type</param>
    </member>
    <member name="T:Magnum.PerformanceCounters.CounterCategory">
      <summary>
            Marker interface for type scanning
            </summary>
    </member>
    <member name="T:Magnum.PerformanceCounters.CounterRegistry">
      <summary>
            A class used for type scanning
            </summary>
    </member>
    <member name="T:Magnum.PerformanceCounters.CounterRepositoryConfigurator">
      <summary>
            How to configure/create a counter repository
            </summary>
    </member>
    <member name="T:Magnum.PerformanceCounters.InstancePerformanceCounter">
      <summary>
            This class actually wraps the .Net Performance Counter
            </summary>
    </member>
    <member name="T:Magnum.PerformanceCounters.PerformanceCounterConfiguration">
      <summary>
            This class encapsulates the data needed to create a counter in Windows
            </summary>
    </member>
    <member name="T:Magnum.Binding.BinderContext">
      <summary>
              Used by the type binders to obtain information
            </summary>
    </member>
    <member name="M:Magnum.Binding.BinderContext.Bind(Magnum.Binding.ObjectPropertyBinder)">
      <summary>
              Binds a property of an object, pushing the property context on the stack
            </summary>
      <param name="property">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Magnum.Binding.BinderContext.Property">
      <summary>
              The current property being bound
            </summary>
    </member>
    <member name="P:Magnum.Binding.BinderContext.PropertyValue">
      <summary>
              Resolves the value of the property based on the naming convention.
              This can be an expensive call, so it should only be called once and
              the return value should be cached to avoid performance concerns
            </summary>
    </member>
    <member name="T:Magnum.Binding.ModelBinder">
      <summary>
            A model binder is used to map an unstructured data source to an object
            using a series of conventions and value providers
            </summary>
    </member>
    <member name="M:Magnum.Binding.ModelBinder.Bind(System.Type,Magnum.Binding.ModelBinderContext)">
      <summary>
            Create an object of the requested type, initializing the properties
            of that object to the value retrieved from the context
            </summary>
      <param name="type">The type of object to create</param>
      <param name="context">The context to use while binding the object</param>
      <returns>Returns an instance of the object, or an exception if the binding was unsuccessful</returns>
    </member>
    <member name="M:Magnum.Binding.ModelBinder.Bind``1(Magnum.Binding.ModelBinderContext)">
      <summary>
            Create an object of the requested type, initializing the properties
            of that object to the value retrieved from the context
            </summary>
      <typeparam name="T">The type of object to create</typeparam>
      <param name="context">The context to use while binding the object</param>
      <returns>Returns an instance of the object, or an exception if the binding was unsuccessful</returns>
    </member>
    <member name="T:Magnum.Binding.FastModelBinder">
      <summary>
            A fast model binder for quickly applying values to properties
            </summary>
    </member>
    <member name="T:Magnum.Binding.ModelBinderContext">
      <summary>
              Context for binding to a model
            </summary>
    </member>
    <member name="M:Magnum.Cryptography.Sha512HMacHashingService.#ctor(System.String)">
      <summary>
      </summary>
      <param name="key">The key to use in the hashing algorhythem. Can be of any length</param>
    </member>
    <member name="T:Magnum.Concurrency.Atomic">
      <summary>
            The factory to create atomic instances/references
            </summary>
    </member>
    <member name="T:Magnum.Concurrency.Atomic`1">
      <summary>
            An atomic value that can be modified using a mutator function.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Concurrency.Atomic`1.Set(System.Func{`0,`0})">
      <summary>
            Sets the value to the result of the mutator. Each attempt to set the value
            will call the mutator, which could result in multiple calls with different
            values on each call.
            </summary>
      <param name="mutator">A function that takes in the current value and returns the new value</param>
      <returns>The value that was replaced</returns>
    </member>
    <member name="T:Magnum.Concurrency.Internal.AtomicObject">
      <summary>
            Maintains a reference to an immutable object, allowing a mutator function to 
            change the reference pointed to in an atomic fashion
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Concurrency.Internal.AtomicObject.Set(System.Func{System.Object,System.Object})">
      <summary>
            Applies a change method to the value, passing the current value to the mutator
            and attempting to set the value to the returned value. if the value has not been
            changed by another thread, the operation completes, otherwise it is attempted 
            again by calling the mutator function with the new value.
            </summary>
      <param name="mutator">A function that, given the current value, returns the changed value</param>
      <returns>The previous value</returns>
    </member>
    <member name="T:Magnum.Concurrency.Internal.AtomicReference`1">
      <summary>
            Maintains a reference to an immutable object, allowing a mutator function to 
            change the reference pointed to in an atomic fashion
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Concurrency.Internal.AtomicReference`1.Set(System.Func{`0,`0})">
      <summary>
            Applies a change method to the value, passing the current value to the mutator
            and attempting to set the value to the returned value. if the value has not been
            changed by another thread, the operation completes, otherwise it is attempted 
            again by calling the mutator function with the new value.
            </summary>
      <param name="mutator">A function that, given the current value, returns the changed value</param>
      <returns>The previous value</returns>
    </member>
    <member name="T:Magnum.Configuration.ConfigurationBinder">
      <summary>
            Creates configuration/settings objects, applying configuration values
            to the properties as they match the configuration keys in the store
            </summary>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.Bind``1">
      <summary>
            Creates an instance of the specified type and sets the properties
            to the configuration settings that match
            </summary>
      <typeparam name="T">The configuration object type</typeparam>
      <returns>An initialize configuration object</returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.Bind(System.Type)">
      <summary>
            Creates an instance of the specified type and sets the properties
            to the configuration settings that match
            </summary>
      <typeparam name="T">The configuration object type</typeparam>
      <returns>An initialize configuration object</returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetValue(System.String)">
      <summary>
            Returns a single configuration value
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetValue``1(System.String)">
      <summary>
            Returns a single configuration value of type T
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetValueAsString(System.String)">
      <summary>
            Returns a single configuration as a string
            </summary>
      <param name="key">
      </param>
      <returns>The string representation of the value, or null</returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetAll">
      <summary>
            Return a dictionary of all key/value pairs that exist
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToUri.AppendPath(System.Uri,System.String)">
      <summary>
              Appends a path to an existing Uri
            </summary>
      <param name="uri">
      </param>
      <param name="path">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Collections.BinaryPredicate`1">
      <summary>
            The BinaryPredicate delegate type  encapsulates a method that takes two
            items of the same type, and returns a boolean value representating 
            some relationship between them. For example, checking whether two
            items are equal or equivalent is one kind of binary predicate.
            </summary>
      <param name="item1">The first item.</param>
      <param name="item2">The second item.</param>
      <returns>Whether item1 and item2 satisfy the relationship that the BinaryPredicate defines.</returns>
    </member>
    <member name="T:Magnum.Collections.Algorithms">
      <summary>
            Algorithms contains a number of static methods that implement
            algorithms that work on collections. Most of the methods deal with
            the standard generic collection interfaces such as IEnumerable&lt;T&gt;,
            ICollection&lt;T&gt; and IList&lt;T&gt;.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ListRange`1">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of a list. The object stores a wrapped list, and a start/count indicating
            a sub-range of the list. Insertion/deletions through the sub-range view
            cause the count to change also; insertions and deletions directly on
            the wrapped list do not.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ListRange`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
      <summary>
            Create a sub-range view object on the indicate part 
            of the list.
            </summary>
      <param name="wrappedList">List to wrap.</param>
      <param name="start">The start index of the view in the wrapped list.</param>
      <param name="count">The number of items in the view.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ArrayRange`1">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of an array. The object stores a wrapped array, and a start/count indicating
            a sub-range of the array. Insertion/deletions through the sub-range view
            cause the count to change up to the size of the underlying array. Elements
            fall off the end of the underlying array.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ArrayRange`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>
            Create a sub-range view object on the indicate part 
            of the array.
            </summary>
      <param name="wrappedArray">Array to wrap.</param>
      <param name="start">The start index of the view in the wrapped list.</param>
      <param name="count">The number of items in the view.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReadOnlyCollection`1">
      <summary>
            The read-only ICollection&lt;T&gt; implementation that is used by the ReadOnly method.
            Methods that modify the collection throw a NotSupportedException, methods that don't
            modify are fowarded through to the wrapped collection.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Create a ReadOnlyCollection wrapped around the given collection.
            </summary>
      <param name="wrappedCollection">Collection to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyCollection`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReadOnlyList`1">
      <summary>
            The read-only IList&lt;T&gt; implementation that is used by the ReadOnly method.
            Methods that modify the list throw a NotSupportedException, methods that don't
            modify are fowarded through to the wrapped list.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Create a ReadOnlyList wrapped around the given list.
            </summary>
      <param name="wrappedList">List to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyList`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReadOnlyDictionary`2">
      <summary>
            The private class that implements a read-only wrapped for 
            IDictionary &lt;TKey,TValue&gt;.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Create a read-only dictionary wrapped around the given dictionary.
            </summary>
      <param name="wrappedDictionary">The IDictionary&lt;TKey,TValue&gt; to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyDictionary`2.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedEnumerator`1">
      <summary>
             The class that provides a typed IEnumerator&lt;T&gt;
            view onto an untyped IEnumerator interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedEnumerator`1.#ctor(System.Collections.IEnumerator)">
      <summary>
            Create a typed IEnumerator&lt;T&gt;
            view onto an untyped IEnumerator interface 
            </summary>
      <param name="wrappedEnumerator">IEnumerator to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedEnumerable`1">
      <summary>
            The class that provides a typed IEnumerable&lt;T&gt; view
            onto an untyped IEnumerable interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedEnumerable`1.#ctor(System.Collections.IEnumerable)">
      <summary>
            Create a typed IEnumerable&lt;T&gt; view
            onto an untyped IEnumerable interface.
            </summary>
      <param name="wrappedEnumerable">IEnumerable interface to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedCollection`1">
      <summary>
            The class that provides a typed ICollection&lt;T&gt; view
            onto an untyped ICollection interface. The ICollection&lt;T&gt;
            is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedCollection`1.#ctor(System.Collections.ICollection)">
      <summary>
            Create a typed ICollection&lt;T&gt; view
            onto an untyped ICollection interface.
            </summary>
      <param name="wrappedCollection">ICollection interface to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedCollection`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedList`1">
      <summary>
            The class used to create a typed IList&lt;T&gt; view onto
            an untype IList interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedList`1.#ctor(System.Collections.IList)">
      <summary>
            Create a typed IList&lt;T&gt; view onto
            an untype IList interface.
            </summary>
      <param name="wrappedList">The IList to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.UntypedCollection`1">
      <summary>
            The class that is used to provide an untyped ICollection
            view onto a typed ICollection&lt;T&gt; interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.UntypedCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Create an untyped ICollection
            view onto a typed ICollection&lt;T&gt; interface.
            </summary>
      <param name="wrappedCollection">The ICollection&lt;T&gt; to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.UntypedList`1">
      <summary>
            The class that implements a non-generic IList wrapper
            around a generic IList&lt;T&gt; interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.UntypedList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Create a non-generic IList wrapper
            around a generic IList&lt;T&gt; interface.
            </summary>
      <param name="wrappedList">The IList&lt;T&gt; interface to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.UntypedList`1.ConvertToItemType(System.String,System.Object)">
      <summary>
            Convert the given parameter to T. Throw an ArgumentException
            if it isn't.
            </summary>
      <param name="name">parameter name</param>
      <param name="value">parameter value</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ArrayWrapper`1">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view an array
            in a read-write way. Insertions cause the last item in the array
            to fall off, deletions replace the last item with the default value.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ArrayWrapper`1.#ctor(`0[])">
      <summary>
            Create a list wrapper object on an array.
            </summary>
      <param name="wrappedArray">Array to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.LexicographicalComparerClass`1">
      <summary>
            A private class used by the LexicographicalComparer method to compare sequences
            (IEnumerable) of T by there Lexicographical ordering.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalComparerClass`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new instance that comparer sequences of T by their lexicographical
            ordered.
            </summary>
      <param name="itemComparer">The IComparer used to compare individual items of type T.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReverseComparerClass`1">
      <summary>
            An IComparer instance that can be used to reverse the sense of 
            a wrapped IComparer instance.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReverseComparerClass`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
      </summary>
      <param name="comparer">The comparer to reverse.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.IdentityComparer`1">
      <summary>
            A class, implementing IEqualityComparer&lt;T&gt;, that compares objects
            for object identity only. Only Equals and GetHashCode can be used;
            this implementation is not appropriate for ordering.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.CollectionEqualityComparer`1">
      <summary>
            A private class used to implement GetCollectionEqualityComparer(). This
            class implements IEqualityComparer&lt;IEnumerable&lt;T&gt;gt; to compare
            two enumerables for equality, where order is significant.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.SetEqualityComparer`1">
      <summary>
            A private class used to implement GetSetEqualityComparer(). This
            class implements IEqualityComparer&lt;IEnumerable&lt;T&gt;gt; to compare
            two enumerables for equality, where order is not significant.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Range``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of a list. Items from <paramref name="list" /> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="list" />
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>This method can be used to apply an algorithm to a portion of a list. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(list, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <typeparam name="T">The type of the items in the list.</typeparam>
      <param name="list">The list to view.</param>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-list. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of <paramref name="list" />.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Range``1(``0[],System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of an array. Items from <paramref name="array" /> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="array" />
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view. After an insertion, the last item in <paramref name="array" /> "falls off the end". After a deletion, the
            last item in array becomes the default value (0 or null).
            </summary>
      <remarks>This method can be used to apply an algorithm to a portion of a array. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(array, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="array">The array to view.</param>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-array. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of <paramref name="array" />.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnly``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Returns a read-only view onto a collection. The returned ICollection&lt;T&gt; interface
            only allows operations that do not change the collection: GetEnumerator, Contains, CopyTo,
            Count. The ReadOnly property returns false, indicating that the collection is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
      <remarks>The data in the underlying collection is not copied. If the underlying
            collection is changed, then the read-only view also changes accordingly.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to wrap.</param>
      <returns>A read-only view onto <paramref name="collection" />. If <paramref name="collection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnly``1(System.Collections.Generic.IList{``0})">
      <summary>
            Returns a read-only view onto a list. The returned IList&lt;T&gt; interface
            only allows operations that do not change the list: GetEnumerator, Contains, CopyTo,
            Count, IndexOf, and the get accessor of the indexer. 
            The IsReadOnly property returns true, indicating that the list is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
      <remarks>The data in the underlying list is not copied. If the underlying
            list is changed, then the read-only view also changes accordingly.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to wrap.</param>
      <returns>A read-only view onto <paramref name="list" />. Returns null if <paramref name="list" /> is null. 
            If <paramref name="list" /> is already read-only, returns <paramref name="list" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Returns a read-only view onto a dictionary. The returned IDictionary&lt;TKey,TValue&gt; interface
            only allows operations that do not change the dictionary. 
            The IsReadOnly property returns true, indicating that the dictionary is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
      <remarks>The data in the underlying dictionary is not copied. If the underlying
            dictionary is changed, then the read-only view also changes accordingly.</remarks>
      <param name="dictionary">The dictionary to wrap.</param>
      <returns>A read-only view onto <paramref name="dictionary" />. Returns null if <paramref name="dictionary" /> is null. 
            If <paramref name="dictionary" /> is already read-only, returns <paramref name="dictionary" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedAs``1(System.Collections.IEnumerable)">
      <summary>
            Given a non-generic IEnumerable interface, wrap a generic IEnumerable&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
      <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection" /> to IEnumerable&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the wrapper collection.</typeparam>
      <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic IEnumerable&lt;T&gt; wrapper around <paramref name="untypedCollection" />. 
            If <paramref name="untypedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedAs``1(System.Collections.ICollection)">
      <summary>
            Given a non-generic ICollection interface, wrap a generic ICollection&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
      <remarks>
        <para>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection" /> to ICollection&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</para>
        <para>Unlike the generic interface, the non-generic ICollection interfaces does
            not contain methods for adding or removing items from the collection. For this reason,
            the returned ICollection&lt;T&gt; will be read-only.</para>
      </remarks>
      <typeparam name="T">The item type of the wrapper collection.</typeparam>
      <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic ICollection&lt;T&gt; wrapper around <paramref name="untypedCollection" />.
            If <paramref name="untypedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedAs``1(System.Collections.IList)">
      <summary>
            Given a non-generic IList interface, wrap a generic IList&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic list, but can be used in places that require a generic interface.
            The underlying non-generic list must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic lists to newer code that uses generic interfaces.
            </summary>
      <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedList" /> to IList&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the wrapper list.</typeparam>
      <param name="untypedList">An untyped list. This list should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic IList&lt;T&gt; wrapper around <paramref name="untypedList" />.
            If <paramref name="untypedList" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Untyped``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Given a generic ICollection&lt;T&gt; interface, wrap a non-generic (untyped)
            ICollection interface around it. The non-generic interface will contain the same objects as the 
            underlying generic collection, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
      <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedCollection" /> to ICollection. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the underlying collection.</typeparam>
      <param name="typedCollection">A typed collection to wrap.</param>
      <returns>A non-generic ICollection wrapper around <paramref name="typedCollection" />.
            If <paramref name="typedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Untyped``1(System.Collections.Generic.IList{``0})">
      <summary>
            Given a generic IList&lt;T&gt; interface, wrap a non-generic (untyped)
            IList interface around it. The non-generic interface will contain the same objects as the 
            underlying generic list, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
      <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedList" /> to IList. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the underlying list.</typeparam>
      <param name="typedList">A typed list to wrap.</param>
      <returns>A non-generic IList wrapper around <paramref name="typedList" />.
            If <paramref name="typedList" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadWriteList``1(``0[])">
      <summary>
        <para>Creates a read-write IList&lt;T&gt; wrapper around an array. When an array is
            implicitely converted to an IList&lt;T&gt;, changes to the items in the array cannot
            be made through the interface. This method creates a read-write IList&lt;T&gt; wrapper
            on an array that can be used to make changes to the array. </para>
        <para>Use this method when you need to pass an array to an algorithms that takes an 
            IList&lt;T&gt; and that tries to modify items in the list. Algorithms in this class generally do not
            need this method, since they have been design to operate on arrays even when they
            are passed as an IList&lt;T&gt;.</para>
      </summary>
      <remarks>Since arrays cannot be resized, inserting an item causes the last item in the array to be automatically
            removed. Removing an item causes the last item in the array to be replaced with a default value (0 or null). Clearing
            the list causes all the items to be replaced with a default value.</remarks>
      <param name="array">The array to wrap.</param>
      <returns>An IList&lt;T&gt; wrapper onto <paramref name="array" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
      <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="collection" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="collection" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0)">
      <summary>
            Replace all items in a collection that a predicate evalues at true with a value, yielding another collection. .
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0)">
      <summary>
            Replace all items in a list or array equal to a particular value with another value. The replacement is done in-place, changing
            the list.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
      <param name="itemFind">The value to find and replace within <paramtype name="T" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Replace all items in a list or array equal to a particular value with another values.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="itemFind">The value to find and replace within <paramtype name="T" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},System.Predicate{``0},``0)">
      <summary>
            Replace all items in a list or array that a predicate evaluates at true with a value. The replacement is done in-place, changing
            the list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. 
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to process.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive duplicates removed.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive duplicates removed.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="equalityComparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Remove consecutive "equal" items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. </remarks>
      <param name="collection">The collection to process.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". An item <c>current</c> is removed if <c>predicate(first, current)==true</c>, where
            <c>first</c> is the first item in the group of "duplicate" items.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive "duplicates" removed.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Remove consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The removal is done in-place, changing
            the list. 
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Remove subsequent consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Remove consecutive "equal" items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The replacement is done in-place, changing
            the list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>
        <para>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive equal items in the
            list.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists..</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive equal items in the
            list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive "equal" items in the
            list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </remarks>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveWhere``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive items in the
            list for which a given predicate returns true.
            </summary>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive items to look for. The count must be at least 1.</param>
      <param name="predicate">The predicate used to test each item.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> items where <paramref name="predicate" />
            returns true for all items in the run, or -1 if no such run exists.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
      <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="foundItem">Outputs the first item in the collection that matches the condition, if the method returns true.</param>
      <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>
        <para>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</para>
        <para>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</para>
      </remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
      <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="foundItem">Outputs the last item in the collection that matches the condition, if the method returns true.</param>
      <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Enumerates all the items in <paramref name="collection" /> that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindFirstIndexWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Finds the index of the first item in a list that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item satisfying the condition. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindLastIndexWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Finds the index of the last item in a list that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item satisfying the condition. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindIndicesWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Enumerates the indices of all the items in <paramref name="list" /> that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Finds the index of the first item in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>The index of the first item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the first item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the first item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Finds the index of the last item in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>The index of the last item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the last item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the last item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Enumerates the indices of all the items in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the index of the first item in a list equal to one of several given items.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the first item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode methods will be called.</param>
      <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Finds the index of the first item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            first item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the first item "equal" to any of the items in the collection <paramref name="itemsToLookFor" />, using 
            <paramtype name="BinaryPredicate{T}" /> as the test for equality. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the index of the last item in a list equal to one of several given items.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the last item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
      <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Finds the index of the last item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the last item "equal" to any of the items in the collection <paramref name="itemsToLookFor" />, using 
            <paramtype name="BinaryPredicate" /> as the test for equality. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. 
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. </param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items "equal" to any of the items 
            in the collection <paramref name="itemsToLookFor" />, using 
            <paramtest name="BinaryPredicate" /> as the test for equality. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern" />, list[i+1] is equal to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is "equal" to the first item
            in <paramref name="pattern" />, list[i+1] is "equal" to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for in the pattern need not be equality. </remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern" />, list[i+1] is equal to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> is a proper subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are disjoint, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparerComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are disjoint, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are equal, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are equal, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to intersect.</param>
      <param name="collection2">The second collection to intersect.</param>
      <returns>The intersection of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to intersect.</param>
      <param name="collection2">The second collection to intersect.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The intersection of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Union or UnionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to union.</param>
      <param name="collection2">The second collection to union.</param>
      <returns>The union of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the union or unionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to union.</param>
      <param name="collection2">The second collection to union.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The union of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Difference or DifferenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to difference.</param>
      <param name="collection2">The second collection to difference.</param>
      <returns>The difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the difference or differenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to difference.</param>
      <param name="collection2">The second collection to difference.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the SymmetricDifference or SymmetricDifferenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to symmetric difference.</param>
      <param name="collection2">The second collection to symmetric difference.</param>
      <returns>The symmetric difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the symmetric difference or symmetric differenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to symmetric difference.</param>
      <param name="collection2">The second collection to symmetric difference.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The symmetric difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CartesianProduct``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Computes the cartestian product of two collections: all possible pairs of items, with the first item taken from the first collection and 
            the second item taken from the second collection. If the first collection has N items, and the second collection has M items, the cartesian
            product will have N * M pairs.
            </summary>
      <typeparam name="TFirst">The type of items in the first collection.</typeparam>
      <typeparam name="TSecond">The type of items in the second collection.</typeparam>
      <param name="first">The first collection.</param>
      <param name="second">The second collection.</param>
      <returns>An IEnumerable&lt;Pair&lt;TFirst, TSecond&gt;&gt; that enumerates the cartesian product of the two collections.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Gets a string representation of the elements in the collection.
            The string representation starts with "{", has a list of items separated
            by commas (","), and ends with "}". Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
      <param name="collection">A collection to get the string representation of.</param>
      <returns>The string representation of the collection. If <paramref name="collection" /> is null, then the string "null" is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.String,System.String,System.String)">
      <summary>
            Gets a string representation of the elements in the collection.
            The string to used at the beginning and end, and to separate items,
            and supplied by parameters. Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            </summary>
      <param name="collection">A collection to get the string representation of.</param>
      <param name="recursive">If true, contained collections (except strings) are converted to strings by a recursive call to this method, instead
            of by calling ToString.</param>
      <param name="start">The string to appear at the beginning of the output string.</param>
      <param name="separator">The string to appear between each item in the string.</param>
      <param name="end">The string to appear at the end of the output string.</param>
      <returns>The string representation of the collection. If <paramref name="collection" /> is null, then the string "null" is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" />, <paramref name="separator" />, or <paramref name="end" />
             is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToString``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Gets a string representation of the mappings in a dictionary.
            The string representation starts with "{", has a list of mappings separated
            by commas (", "), and ends with "}". Each mapping is represented
            by "key-&gt;value". Each key and value in the dictionary is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
      <param name="dictionary">A dictionary to get the string representation of.</param>
      <returns>The string representation of the collection, or "null" 
            if <paramref name="dictionary" /> is null.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
      <typeparam name="T">The type of the items in the collection.</typeparam>
      <param name="collection">The collection to shuffle.</param>
      <returns>An array with the same size and items as <paramref name="collection" />, but the items in a randomly chosen order.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
      <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
      <typeparam name="T">The type of the items in the collection.</typeparam>
      <param name="collection">The collection to shuffle.</param>
      <param name="randomGenerator">The random number generator to use to select the random order.</param>
      <returns>An array with the same size and items as <paramref name="collection" />, but the items in a randomly chosen order.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to shuffle.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0},System.Random)">
      <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to shuffle.</param>
      <param name="randomGenerator">The random number generator to use to select the random order.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Picks a random subset of <paramref name="count" /> items from <paramref name="collection" />, and places
            those items into a random order. No item is selected more than once.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count" />).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection of items to select from. This collection is not changed.</param>
      <param name="count">The number of items in the subset to choose.</param>
      <returns>An array of <paramref name="count" /> items, selected at random from <paramref name="collection" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or greater than <paramref name="collection" />.Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random)">
      <summary>
            Picks a random subset of <paramref name="count" /> items from <paramref name="collection" />, and places
            those items into a random order. No item is selected more than once.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count" />).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection of items to select from. This collection is not changed.</param>
      <param name="count">The number of items in the subset to choose.</param>
      <param name="randomGenerator">The random number generates used to make the selection.</param>
      <returns>An array of <paramref name="count" /> items, selected at random from <paramref name="collection" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or greater than <paramref name="collection" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="randomGenerator" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GeneratePermutations``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />. If <paramref name="collection" />
            has N items, then N factorial permutations will be generated. This method does not compare the items to determine if
            any of them are equal. If some items are equal, the same permutation may be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate the six permutations, AAB, AAB,
            ABA, ABA, BAA, BAA (not necessarily in that order). To take equal items into account, use the GenerateSortedPermutations
            method.
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. 
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. A
            supplied IComparer&lt;T&gt; instance is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <param name="comparer">The IComparer&lt;T&gt; used to compare the items.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. A
            supplied Comparison&lt;T&gt; delegate is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <param name="comparison">The Comparison&lt;T&gt; delegate used to compare the items.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetRandomGenerator">
      <summary>
            Return a private random number generator to use if the user
            doesn't supply one.
            </summary>
      <returns>The private random number generator. Only one is ever created
            and is always returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the maximum value in a collection.
            </summary>
      <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <returns>The largest item in the collection. </returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the maximum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The largest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Finds the maximum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The largest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the minimum value in a collection.
            </summary>
      <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the minimum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Finds the minimum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0})">
      <summary>
            Finds the index of the maximum value in a list.
            </summary>
      <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the index of the maximum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Finds the index of the maximum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0})">
      <summary>
            Finds the index of the minimum value in a list.
            </summary>
      <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the index of the minimum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Finds the index of the minimum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a sorted version of a collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a sorted version of a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Creates a sorted version of a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Sorts a list or array in place.
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a list or array in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Sorts a list or array in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            </summary>
      <remarks>
        <para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;).
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>The number of items equal to <paramref name="item" /> that appear in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed instance of IComparer&lt;T&gt;.
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="comparer">The comparer instance used to sort the list. Only
            the Compare method is used.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>
            The number of items equal to <paramref name="item" /> that appear in the list.
            </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Comparison{``0},System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed Comparison&lt;T&gt; delegate.
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="comparison">The comparison delegate used to sort the list.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>The number of items equal to <paramref name="item" /> that appear in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.MergeSorted``1(System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;). The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
      <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.MergeSorted``1(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the ordering in the passed instance of IComparer&lt;T&gt;. The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
      <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <param name="comparer">The comparer instance used to sort the list. Only
            the Compare method is used.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.MergeSorted``1(System.Comparison{``0},System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the ordering in the passed Comparison&lt;T&gt; delegate. The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
      <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <param name="comparison">The comparison delegate used to sort the collections.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
      <typeparam name="T">Types of items to compare. This type must implement IComparable&lt;T&gt; to allow 
            items to be compared.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
      <exception cref="T:System.NotSupportedException">T does not implement IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparison delegate. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <typeparam name="T">Types of items to compare.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <param name="comparison">The IComparison&lt;T&gt; delegate to compare items. 
            Only the Compare member function of this interface is called.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparer interface. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <typeparam name="T">Types of items to compare.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <param name="comparer">The IComparer&lt;T&gt; used to compare items. 
            Only the Compare member function of this interface is called.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sequence1" />, <paramref name="sequence2" />, or 
            <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetLexicographicalComparer``1">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be used
            for collections or algorithms that use sequences of T as an item type. The Lexicographical
            ordered of sequences is for comparison.
            </summary>
      <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetLexicographicalComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
      <param name="comparer">A comparer instance used to compare individual items of type T.</param>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetLexicographicalComparer``1(System.Comparison{``0})">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
      <param name="comparison">A comparison delegate used to compare individual items of type T.</param>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetReverseComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Reverses the order of comparison of an IComparer&lt;T&gt;. The resulting comparer can be used,
            for example, to sort a collection in descending order. Equality and hash codes are unchanged.
            </summary>
      <typeparam name="T">The type of items thta are being compared.</typeparam>
      <param name="comparer">The comparer to reverse.</param>
      <returns>An IComparer&lt;T&gt; that compares items in the reverse order of <paramref name="comparer" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetIdentityComparer``1">
      <summary>
            Gets an IEqualityComparer&lt;T&gt; instance that can be used to compare objects
            of type T for object identity only. Two objects compare equal only if they
            are references to the same object. 
            </summary>
      <returns>An IEqualityComparer&lt;T&gt; instance for identity comparison.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetReverseComparison``1(System.Comparison{``0})">
      <summary>
            Reverses the order of comparison of an Comparison&lt;T&gt;. The resulting comparison can be used,
            for example, to sort a collection in descending order. 
            </summary>
      <typeparam name="T">The type of items that are being compared.</typeparam>
      <param name="comparison">The comparison to reverse.</param>
      <returns>A Comparison&lt;T&gt; that compares items in the reverse order of <paramref name="comparison" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetComparerFromComparison``1(System.Comparison{``0})">
      <summary>
            Given a comparison delegate that compares two items of type T, gets an
            IComparer&lt;T&gt; instance that performs the same comparison.
            </summary>
      <param name="comparison">The comparison delegate to use.</param>
      <returns>An IComparer&lt;T&gt; that performs the same comparing operation
            as <paramref name="comparison" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetComparisonFromComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Given in IComparer&lt;T&gt; instenace that comparers two items from type T, 
            gets a Comparison delegate that performs the same comparison.
            </summary>
      <param name="comparer">The IComparer&lt;T&gt; instance to use.</param>
      <returns>A Comparison&lt;T&gt; delegate that performans the same comparing
            operation as <paramref name="comparer" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetCollectionEqualityComparer``1">
      <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
      <example>
            The following code creates a Dictionary where the keys are a collection of strings.
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;());
            </code></example>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetCollectionEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
        <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
        <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
      </summary>
      <example>
            The following code creates a Dictionary where the keys are a collection of strings, compared in a case-insensitive way
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code></example>
      <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetSetEqualityComparer``1">
      <summary>
        <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
        <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
      </summary>
      <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code></example>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetSetEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
      <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;());
            </code></example>
      <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Determines if a collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TrueForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CountWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to count items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveWhere``1(System.Collections.Generic.ICollection{``0},System.Predicate{``0})">
      <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the collection if an array or implements IList&lt;T&gt;, an efficient algorithm that
            compacts items is used. If not, then ICollection&lt;T&gt;.Remove is used
            to remove items from the collection. If the collection is an array or fixed-size list,
            the non-removed elements are placed, in order, at the beginning of
            the list, and the remaining list items are filled with a default value (0 or null).</remarks>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>Returns a collection of the items that were removed. This collection contains the
            items in the same order that they orginally appeared in <paramref name="collection" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Convert``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
      <summary>
            Convert a collection of items by applying a delegate to each item in the collection. The resulting collection
            contains the result of applying <paramref name="converter" /> to each item in <paramref name="sourceCollection" />, in
            order.
            </summary>
      <typeparam name="TSource">The type of items in the collection to convert.</typeparam>
      <typeparam name="TDest">The type each item is being converted to.</typeparam>
      <param name="sourceCollection">The collection of item being converted.</param>
      <param name="converter">A delegate to the method to call, passing each item in <paramref name="sourceCollection" />.</param>
      <returns>The resulting collection from applying <paramref name="converter" /> to each item in <paramref name="sourceCollection" />, in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sourceCollection" /> or <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to the default value (zero or null).
            </summary>
      <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
      <param name="dictionary">The dictionary used to perform the conversion.</param>
      <returns>A delegate to a method that converts keys to values. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1},``1)">
      <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to a supplied default value.
            </summary>
      <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
      <param name="dictionary">The dictionary used to perform the conversion.</param>
      <param name="defaultValue">The result of the conversion for keys that are not present in the dictionary.</param>
      <returns>A delegate to a method that converts keys to values. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="dictionary" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Performs the specified action on each item in a collection.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="action">An Action delegate which is invoked for each item in <paramref name="collection" />.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Partition``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to partition.</param>
      <param name="predicate">A delegate that defines the partitioning condition.</param>
      <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate" /> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StablePartition``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false. 
            The partition is stable, which means that if items X and Y have the same result from
            the predicate, and X precedes Y in the original list, X will precede Y in the 
            partitioned list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to partition.</param>
      <param name="predicate">A delegate that defines the partitioning condition.</param>
      <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate" /> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Concatenate``1(System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Concatenates all the items from several collections. The collections need not be of the same type, but
            must have the same item type.
            </summary>
      <param name="collections">The set of collections to concatenate. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <returns>An IEnumerable that enumerates all the items in each of the collections, in order.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if the two collections contain equal items in the same order. The two collections do not need
            to be of the same type; it is permissible to compare an array and an OrderedBag, for instance.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the two collections contain equal items in the same order. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals member function of this interface is called.</param>
      <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" />, <paramref name="collection2" />, or
            <paramref name="equalityComparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Determines if the two collections contain "equal" items in the same order. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for need not be equality. For example, the following code determines if each integer in
            list1 is less than or equal to the corresponding integer in list2.
            <code>
            List&lt;int&gt; list1, list2;
            if (EqualCollections(list1, list2, delegate(int x, int y) { return x &lt;= y; }) {
                // the check is true...
            }
            </code></remarks>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". 
            This predicate can compute any relation between two items; it need not represent equality or an equivalence relation.</param>
      <returns>True if <paramref name="predicate" />returns true for each corresponding pair of
            items in the two collections. If both collections are empty, true is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" />, <paramref name="collection2" />, or
            <paramref name="predicate" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Create an array with the items in a collection.
            </summary>
      <remarks>If <paramref name="collection" /> implements ICollection&lt;T&gt;T, then 
            ICollection&lt;T&gt;.CopyTo() is used to fill the array. Otherwise, the IEnumerable&lt;T&gt;.GetEnumerator()
            is used to fill the array.</remarks>
      <typeparam name="T">Element type of the collection.</typeparam>
      <param name="collection">Collection to create array from.</param>
      <returns>An array with the items from the collection, in enumeration order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Count``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Count the number of items in an IEnumerable&lt;T&gt; collection. If 
            a more specific collection type is being used, it is more efficient to use
            the Count property, if one is provided.
            </summary>
      <remarks>If the collection implements ICollection&lt;T&gt;, this method
            simply returns ICollection&lt;T&gt;.Count. Otherwise, it enumerates all items
            and counts them.</remarks>
      <param name="collection">The collection to count items in.</param>
      <returns>The number of items in the collection.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Counts the number of items in the collection that are equal to <paramref name="find" />.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to count items in.</param>
      <param name="find">The item to compare to.</param>
      <returns>The number of items in the collection that are equal to <paramref name="find" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Counts the number of items in the collection that are equal to <paramref name="find" />.
            </summary>
      <param name="collection">The collection to count items in.</param>
      <param name="find">The item to compare to.</param>
      <param name="equalityComparer">The comparer to use to determine if two items are equal. Only the Equals
            member function will be called.</param>
      <returns>The number of items in the collection that are equal to <paramref name="find" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> or <paramref name="equalityComparer" />
            is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.NCopiesOf``1(System.Int32,``0)">
      <summary>
            Creates an IEnumerator that enumerates a given item <paramref name="n" /> times.
            </summary>
      <example>
            The following creates a list consisting of 1000 copies of the double 1.0.
            <code>
            List&lt;double&gt; list = new List&lt;double&gt;(Algorithms.NCopiesOf(1000, 1.0));
            </code></example>
      <param name="n">The number of times to enumerate the item.</param>
      <param name="item">The item that should occur in the enumeration.</param>
      <returns>An IEnumerable&lt;T&gt; that yields <paramref name="n" /> copies
            of <paramref name="item" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The argument <paramref name="n" /> is less than zero.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Fill``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Replaces each item in a list with a given value. The list does not change in size.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to modify.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is a read-only list.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Fill``1(``0[],``0)">
      <summary>
            Replaces each item in a array with a given value. 
            </summary>
      <param name="array">The array to modify.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FillRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0)">
      <summary>
            Replaces each item in a part of a list with a given value.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to modify.</param>
      <param name="start">The index at which to start filling. The first index in the list has index 0.</param>
      <param name="count">The number of items to fill.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is a read-only list.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative, or 
            <paramref name="start" /> + <paramref name="count" /> is greater than <paramref name="list" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FillRange``1(``0[],System.Int32,System.Int32,``0)">
      <summary>
            Replaces each item in a part of a array with a given value.
            </summary>
      <param name="array">The array to modify.</param>
      <param name="start">The index at which to start filling. The first index in the array has index 0.</param>
      <param name="count">The number of items to fill.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative, or 
            <paramref name="start" /> + <paramref name="count" /> is greater than <paramref name="array" />.Length.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Copies all of the items from the collection <paramref name="source" /> to the list <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)">
      <summary>
            Copies all of the items from the collection <paramref name="source" /> to the array <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. 
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The array to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Length.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
      <exception cref="T:System.ArgumentException">The collection has more items than will fit into the array. In this case, the array
            has been filled with as many items as fit before the exception is thrown.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Copies at most <paramref name="count" /> items from the collection <paramref name="source" /> to the list <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded. The source collection must not be
            the destination list or part thereof.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <param name="count">The maximum number of items to copy.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32,System.Int32)">
      <summary>
            Copies at most <paramref name="count" /> items from the collection <paramref name="source" /> to the array <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. The source collection must not be
            the destination array or part thereof.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The array to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <param name="count">The maximum number of items to copy. The array must be large enought to fit this number of items.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Length.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or <paramref name="destIndex" /> + <paramref name="count" />
            is greater than <paramref name="dest" />.Length.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Copies <paramref name="count" /> items from the list <paramref name="source" />, starting at the index <paramref name="sourceIndex" />, 
            to the list <paramref name="dest" />, starting at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded.
            The source and destination lists may be the same.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="sourceIndex">The index within <paramref name="source" />to begin copying items from.</param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index within <paramref name="dest" />to begin copying items to.</param>
      <param name="count">The maximum number of items to copy.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sourceIndex" /> is negative or 
            greater than <paramref name="source" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or too large.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IList{``0},System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies <paramref name="count" /> items from the list or array <paramref name="source" />, starting at the index <paramref name="sourceIndex" />, 
            to the array <paramref name="dest" />, starting at the index <paramref name="destIndex" />. 
            The source may be the same as the destination array.
            </summary>
      <param name="source">The list or array that provide the source items. </param>
      <param name="sourceIndex">The index within <paramref name="source" />to begin copying items from.</param>
      <param name="dest">The array to store the items into.</param>
      <param name="destIndex">The index within <paramref name="dest" />to begin copying items to.</param>
      <param name="count">The maximum number of items to copy. The destination array must be large enough to hold this many items.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sourceIndex" /> is negative or 
            greater than <paramref name="source" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Length</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or too large.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Reverse``1(System.Collections.Generic.IList{``0})">
      <summary>
            Reverses a list and returns the reversed list, without changing the source list.
            </summary>
      <param name="source">The list to reverse.</param>
      <returns>A collection that contains the items from <paramref name="source" /> in reverse order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReverseInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Reverses a list or array in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to reverse.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is read only.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Rotate``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Rotates a list and returns the rotated list, without changing the source list.
            </summary>
      <param name="source">The list to rotate.</param>
      <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that source[3] is the first item in the returned collection.
            Rotating by negative 3 means that source[source.Count - 3] is the first item in the returned collection.</param>
      <returns>A collection that contains the items from <paramref name="source" /> in rotated order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RotateInPlace``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Rotates a list or array in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to rotate.</param>
      <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that list[3] is the first item in the resulting list.
            Rotating by negative 3 means that list[list.Count - 3] is the first item in the resulting list.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="T:Magnum.Collections.CollectionBase`1">
      <summary>
            CollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces.
            </summary>
      <remarks>
        <para>To use CollectionBase as a base class, the derived class must override
            the Count, GetEnumerator, Add, Clear, and Remove methods. </para>
        <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the CollectionBase implementation
            may not be very efficient.</para>
      </remarks>
      <typeparam name="T">The item type of the collection.</typeparam>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ToString">
      <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection. Contained collections (except string) are expanded
            recursively.
            </summary>
      <returns>The string representation of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.DebuggerDisplayString">
      <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Add(`0)">
      <summary>
            Must be overridden to allow adding items to this collection.
            </summary>
      <remarks>
        <p>This method is not abstract, although derived classes should always
            override it. It is not abstract because some derived classes may wish to reimplement
            Add with a different return type (typically bool). In C#, this can be accomplished
            with code like the following:</p>
        <code>
                public class MyCollection&lt;T&gt;: CollectionBase&lt;T&gt;, ICollection&lt;T&gt;
                {
                    public new bool Add(T item) {
                        /* Add the item */
                    }
             
                    void ICollection&lt;T&gt;.Add(T item) {
                        Add(item);
                    }
                }
            </code>
      </remarks>
      <param name="item">Item to be added to the collection.</param>
      <exception cref="T:System.NotImplementedException">Always throws this exception to indicated
            that the method must be overridden or re-implemented in the derived class.</exception>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Clear">
      <summary>
            Must be overridden to allow clearing this collection.
            </summary>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Remove(`0)">
      <summary>
            Must be overridden to allow removing items from this collection.
            </summary>
      <returns>True if <paramref name="item" /> existed in the collection and
            was removed. False if <paramref name="item" /> did not exist in the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Contains(`0)">
      <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item" /> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
      <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation, or if the default equality comparison
            is inappropriate.</remarks>
      <param name="item">The item to check for in the collection.</param>
      <returns>True if the collection contains <paramref name="item" />, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ToArray">
      <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
      <returns>An array containing all the elements in the collection, in order.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.AsReadOnly">
      <summary>
            Provides a read-only view of this collection. The returned ICollection&lt;T&gt; provides
            a view of the collection that prevents modifications to the collection. Use the method to provide
            access to the collection without allowing changes. Since the returned object is just a view,
            changes to the collection will be reflected in the view.
            </summary>
      <returns>An ICollection&lt;T&gt; that provides read-only access to the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Exists(System.Predicate{`0})">
      <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.TrueForAll(System.Predicate{`0})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.CountWhere(System.Predicate{`0})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.FindAll(System.Predicate{`0})">
      <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.RemoveAll(System.Predicate{`0})">
      <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>Returns a collection of the items that were removed, in sorted order.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ForEach(System.Action{`0})">
      <summary>
            Performs the specified action on each item in this collection.
            </summary>
      <param name="action">An Action delegate which is invoked for each item in this collection.</param>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ConvertAll``1(System.Converter{`0,``0})">
      <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter" /> to each item in this collection, in
            order.
            </summary>
      <typeparam name="TOutput">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
      <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter" /> to each item in this collection in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.GetEnumerator">
      <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
      <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
    </member>
    <member name="P:Magnum.Collections.CollectionBase`1.Count">
      <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
      <value>The number of items in the collection.</value>
    </member>
    <member name="T:Magnum.Collections.ListBase`1">
      <summary>
            ListBase is an abstract class that can be used as a base class for a read-write collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the following methods: Count, Clear, Insert, RemoveAt, and the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Clear">
      <summary>
            This method must be overridden by the derived class to empty the list
            of all items.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Insert(System.Int32,`0)">
      <summary>
            This method must be overridden by the derived class to insert a new
            item at the given index. 
            </summary>
      <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.RemoveAt(System.Int32)">
      <summary>
            This method must be overridden by the derived class to remove the
            item at the given index. 
            </summary>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
      <remarks>The enumerator does not check for changes made
            to the structure of the list. Thus, changes to the list during
            enumeration may cause incorrect enumeration or out of range
            exceptions. Consider overriding this method and adding checks
            for structural changes.</remarks>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Contains(`0)">
      <summary>
            Determines if the list contains any item that compares equal to <paramref name="item" />.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the list contains an item that compares equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Add(`0)">
      <summary>
            Adds an item to the end of the list. This method is equivalent to calling: 
            <code>Insert(Count, item)</code></summary>
      <param name="item">The item to add to the list.</param>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Remove(`0)">
      <summary>
            Searches the list for the first item that compares equal to <paramref name="item" />.
            If one is found, it is removed. Otherwise, the list is unchanged.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to remove from the list.</param>
      <returns>True if an item was found and removed that compared equal to
            <paramref name="item" />. False if no such item was in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.IndexOf(`0)">
      <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the first item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.CopyTo(`0[])">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at index 0.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
      <summary>
            Copies a range of elements from the list to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="index">The starting index in the source list of the range to copy.</param>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
      <param name="count">The number of items to copy.</param>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.AsReadOnly">
      <summary>
            Provides a read-only view of this list. The returned IList&lt;T&gt; provides
            a view of the list that prevents modifications to the list. Use the method to provide
            access to the list without allowing changes. Since the returned object is just a view,
            changes to the list will be reflected in the view.
            </summary>
      <returns>An IList&lt;T&gt; that provides read-only access to the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Find(System.Predicate{`0})">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ListBase`1.TryFind(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ListBase`1.TryFind(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ListBase`1.TryFind(System.Predicate{`0},`0@)">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLast(System.Predicate{`0})">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLastIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLastIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.IndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.IndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.LastIndexOf(`0)">
      <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the last item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.LastIndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, 
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.ReverseInPlace(deque.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-part of this list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of the list.</exception>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.ConvertToItemType(System.String,System.Object)">
      <summary>
            Convert the given parameter to T. Throw an ArgumentException
            if it isn't.
            </summary>
      <param name="name">parameter name</param>
      <param name="value">parameter value</param>
    </member>
    <member name="P:Magnum.Collections.ListBase`1.Count">
      <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
      <value>The number of items in the list.</value>
    </member>
    <member name="P:Magnum.Collections.ListBase`1.Item(System.Int32)">
      <summary>
            The indexer must be overridden by the derived class to get and set
            values of the list at a particular index.
            </summary>
      <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.Bag`1">
      <summary>
             Bag&lt;T&gt; is a collection that contains items of type T. 
             Unlike a Set, duplicate items (items that compare equal to each other) are allowed in an Bag. 
             </summary>
      <remarks>
        <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
        <p>Bag is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the bag.</p>
        <p>When multiple equal items are stored in the bag, they are stored as a representative item and a count. 
             If equal items can be distinguished, this may be noticable. For example, if a case-insensitive
             comparer is used with a Bag&lt;string&gt;, and both "hello", and "HELLO" are added to the bag, then the
             bag will appear to contain two copies of "hello" (the representative item).</p>
        <p>
          <see cref="T:Magnum.Collections.OrderedBag`1" /> is similar, but uses comparison instead of hashing, maintain
             the items in sorted order, and stores distinct copies of items that compare equal.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.OrderedBag`1" />
    </member>
    <member name="M:Magnum.Collections.Bag`1.NewPair(`0,System.Int32)">
      <summary>
            Helper function to create a new KeyValuePair struct with an item and a count.
            </summary>
      <param name="item">The item.</param>
      <param name="count">The number of appearances.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.NewPair(`0)">
      <summary>
            Helper function to create a new KeyValuePair struct with a count of zero.
            </summary>
      <param name="item">The item.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor">
      <summary>
             Creates a new Bag. 
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag for equality.
            </summary>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new Bag. The bag is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
      <param name="collection">A collection with items to be placed into the Bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the Bag.</param>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{`0,System.Int32}},System.Collections.Generic.IEqualityComparer{`0},Magnum.Collections.Hash{System.Collections.Generic.KeyValuePair{`0,System.Int32}},System.Int32)">
      <summary>
            Creates a new Bag given a comparer and a hash that contains the data. Used
            internally for Clone.
            </summary>
      <param name="equalityComparer">IEqualityComparer for the bag.</param>
      <param name="keyEqualityComparer">IEqualityComparer for the key.</param>
      <param name="hash">Data for the bag.</param>
      <param name="count">Size of the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Clone">
      <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the bag takes time O(N), where N is the number of unquie items in the bag.</remarks>
      <returns>The cloned bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.CloneContents">
      <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para>
      </remarks>
      <returns>The cloned bag.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.NumberOfCopies(`0)">
      <summary>
            Returns the number of copies of <paramref name="item" /> in the bag. 
            </summary>
      <remarks>NumberOfCopies() takes approximately constant time, no matter how many items
            are stored in the bag.</remarks>
      <param name="item">The item to search for in the bag.</param>
      <returns>The number of items in the bag that compare equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.GetRepresentativeItem(`0,`0@)">
      <summary>
            Returns the representative item stored in the bag that is equal to
            the provided item. Also returns the number of copies of the item in the bag.
            </summary>
      <param name="item">Item to find in the bag.</param>
      <param name="representative">If one or more items equal to <paramref name="item" /> are present in the
            bag, returns the representative item. If no items equal to <paramref name="item" /> are stored in the bag, 
            returns <paramref name="item" />.</param>
      <returns>The number of items equal to <paramref name="item" /> stored in the bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            If an item is present multiple times in the bag, the representative item is yielded by the
            enumerator multiple times. The order of enumeration is haphazard and may change.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the Bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Contains(`0)">
      <summary>
            Determines if this bag contains an item equal to <paramref name="item" />. The bag
            is not changed.
            </summary>
      <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the bag contains <paramref name="item" />. False if the bag does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.DistinctItems">
      <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
      <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
      <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Add(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case, the count of items for the representative item is increased by one, but the existing
            represetative item is unchanged.
            </summary>
      <remarks>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.AddRepresentative(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case (unlike Add), the new item becomes the representative item.
            </summary>
      <remarks>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.ChangeNumberOfCopies(`0,System.Int32)">
      <summary>
            Changes the number of copies of an existing item in the bag, or adds the indicated number
            of copies of the item to the bag. 
            </summary>
      <remarks>
        <para>Changing the number of copies takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to change the number of copies of. This may or may not already be present in the bag.</param>
      <param name="numCopies">The new number of copies of the item.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the bag. 
            </summary>
      <remarks>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Remove(`0)">
      <summary>
            Searches the bag for one item equal to <paramref name="item" />, and if found,
            removes it from the bag. If not found, the bag is unchanged. 
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing an item from the bag takes approximated constant time,
            regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.RemoveAllCopies(`0)">
      <summary>
            Searches the bag for all items equal to <paramref name="item" />, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
        <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item" />.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>The number of copies of <paramref name="item" /> that were found and removed. </returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the bag. Items that
            are not present in the bag are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
        <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the bag.</param>
      <returns>The number of items removed from the bag.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Clear">
      <summary>
            Removes all items from the bag.
            </summary>
      <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsEqualTo(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag" /> if they contain the same number of 
            of copies of equal elements.
            </summary>
      <remarks>IsSupersetOf is computed in time O(N), where N is the number of unique items in 
            this bag.</remarks>
      <param name="otherBag">Bag to compare to</param>
      <returns>True if this bag is equal to <paramref name="otherBag" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsSupersetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times.
            </summary>
      <remarks>IsSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsProperSupersetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">Set to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsSubsetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a subset of another ba11 items in this bag.
            </summary>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsProperSubsetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(N), where N is the number of unique items in this bag.</remarks>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsDisjointFrom(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherBag">Bag to check disjointness with.</param>
      <returns>True if the two bags are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.UnionWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M+N), where M and N are the size of the 
            two bags.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Union(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M+N), where M and N are the size of the two bags.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <returns>The union of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.SumWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M), where M is the size of the 
            other bag..</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Sum(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <returns>The sum of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IntersectionWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Intersection(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the intersection contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <returns>The intersection of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.DifferenceWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M), where M is the size of the 
            other bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Difference(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N), where M and N are the size
            of the two bags.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <returns>The difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.SymmetricDifferenceWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.SymmetricDifference(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <returns>The symmetric difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.CheckConsistentComparison(Magnum.Collections.Bag{`0})">
      <summary>
            Check that this bag and another bag were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherBag">Other bag to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherBag and this bag don't use the same method for comparing items.</exception>
    </member>
    <member name="P:Magnum.Collections.Bag`1.Comparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
      <value>If the bag was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.Bag`1.Count">
      <summary>
            Returns the number of items in the bag.
            </summary>
      <remarks>The size of the bag is returned in constant time.</remarks>
      <value>The number of items in the bag.</value>
    </member>
    <member name="T:Magnum.Collections.BigList`1">
      <summary>
            BigList&lt;T&gt; provides a list of items, in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. BigList&lt;T&gt; is optimized for efficient operations on large (&gt;100 items)
            lists, especially for insertions, deletions, copies, and concatinations.
            </summary>
      <remarks>
        <para>BigList&lt;T&gt; class is similar in functionality to the standard List&lt;T&gt; class. Both classes
            provide a collection that stores an set of items in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. Both classes provide the ability to add and remove items from any index,
            and the get or set the item at any index.</para>
        <para>BigList&lt;T&gt; differs significantly from List&lt;T&gt; in the performance of various operations, 
            especially when the lists become large (several hundred items or more). With List&lt;T&gt;, inserting or removing
            elements from anywhere in a large list except the end is very inefficient -- every item after the point of inserting
            or deletion has to be moved in the list. The BigList&lt;T&gt; class, however, allows for fast insertions
            and deletions anywhere in the list. Furthermore, BigList&lt;T&gt; allows copies of a list, sub-parts
            of a list, and concatinations of two lists to be very fast. When a copy is made of part or all of a BigList,
            two lists shared storage for the parts of the lists that are the same. Only when one of the lists is changed is additional
            memory allocated to store the distinct parts of the lists.</para>
        <para>Of course, there is a small price to pay for this extra flexibility. Although still quite efficient, using an 
            index to get or change one element of a BigList, while still reasonably efficient, is significantly slower than using
            a plain List. Because of this, if you want to process every element of a BigList, using a foreach loop is a lot
            more efficient than using a for loop and indexing the list.</para>
        <para>In general, use a List when the only operations you are using are Add (to the end), foreach,
            or indexing, or you are very sure the list will always remain small (less than 100 items). For large (&gt;100 items) lists
            that do insertions, removals, copies, concatinations, or sub-ranges, BigList will be more efficient than List. 
            In almost all cases, BigList is more efficient and easier to use than LinkedList.</para>
      </remarks>
      <typeparam name="T">The type of items to store in the BigList.</typeparam>
    </member>
    <member name="T:Magnum.Collections.BigList`1.Node">
      <summary>
            The base class for the two kinds of nodes in the tree: Concat nodes
            and Leaf nodes.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.MarkShared">
      <summary>
            Marks this node as shared by setting the shared variable.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.GetAt(System.Int32)">
      <summary>
            Returns the items at the given index in this node.
            </summary>
      <param name="index">0-based index, relative to this node.</param>
      <returns>Item at that index.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.Subrange(System.Int32,System.Int32)">
      <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive first element, relative to this node.</param>
      <param name="last">Inclusize last element, relative to this node.</param>
      <returns>Node with the given sub-range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A new node with the sub-range removed.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.RemoveRangeInPlace(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.Validate">
      <summary>
            Validates the node for consistency, as much as possible. Also validates
            child nodes, if any.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.Print(System.String,System.String)">
      <summary>
            Print out the contents of this node.
            </summary>
      <param name="prefixNode">Prefix to use in front of this node.</param>
      <param name="prefixChildren">Prefixed to use in front of children of this node.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.IsBalanced">
      <summary>
            Determine if this node is balanced. A node is balanced if the number
            of items is greater than
            Fibonacci(Depth+2). Balanced nodes are never rebalanced unless
            they go out of balance again.
            </summary>
      <returns>True if the node is balanced by this definition.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.IsAlmostBalanced">
      <summary>
            Determine if this node is almost balanced. A node is almost balanced if t
            its depth is at most one greater than a fully balanced node with the same count.
            </summary>
      <returns>True if the node is almost balanced by this definition.</returns>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Node.Count">
      <summary>
            The number of items stored in the node (or below it).
            </summary>
      <value>The number of items in the node or below.</value>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Node.Shared">
      <summary>
            Is this node shared by more that one list (or within a single)
            lists. If true, indicates that this node, and any nodes below it,
            may never be modified. Never becomes false after being set to 
            true.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Node.Depth">
      <summary>
            Gets the depth of this node. A leaf node has depth 0, 
            a concat node with two leaf children has depth 1, etc.
            </summary>
      <value>The depth of this node.</value>
    </member>
    <member name="T:Magnum.Collections.BigList`1.LeafNode">
      <summary>
            The LeafNode class is the type of node that lives at the leaf of a tree and holds
            the actual items stored in the list. Each leaf holds at least 1, and at most MAXLEAF
            items in the items array. The number of items stored is found in "count", which may
            be less than "items.Length".
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.GetAt(System.Int32)">
      <summary>
            Returns the items at the given index in this node.
            </summary>
      <param name="index">0-based index, relative to this node.</param>
      <returns>Item at that index.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.RemoveRangeInPlace(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A new node with the sub-range removed.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.Subrange(System.Int32,System.Int32)">
      <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive first element, relative to this node.</param>
      <param name="last">Inclusize last element, relative to this node.</param>
      <returns>Node with the given sub-range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.Validate">
      <summary>
            Validates the node for consistency, as much as possible. Also validates
            child nodes, if any.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.Print(System.String,System.String)">
      <summary>
            Print out the contents of this node.
            </summary>
      <param name="prefixNode">Prefix to use in front of this node.</param>
      <param name="prefixChildren">Prefixed to use in front of children of this node.</param>
    </member>
    <member name="T:Magnum.Collections.BigList`1.ConcatNode">
      <summary>
            A ConcatNode is an interior (non-leaf) node that represents the concatination of
            the left and right child nodes. Both children must always be non-null.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.GetAt(System.Int32)">
      <summary>
            Returns the items at the given index in this node.
            </summary>
      <param name="index">0-based index, relative to this node.</param>
      <returns>Item at that index.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.RemoveRangeInPlace(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A new node with the sub-range removed.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.Subrange(System.Int32,System.Int32)">
      <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive first element, relative to this node.</param>
      <param name="last">Inclusize last element, relative to this node.</param>
      <returns>Node with the given sub-range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.Validate">
      <summary>
            Validates the node for consistency, as much as possible. Also validates
            child nodes, if any.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.Print(System.String,System.String)">
      <summary>
            Print out the contents of this node.
            </summary>
      <param name="prefixNode">Prefix to use in front of this node.</param>
      <param name="prefixChildren">Prefixed to use in front of children of this node.</param>
    </member>
    <member name="P:Magnum.Collections.BigList`1.ConcatNode.Depth">
      <summary>
            The depth of this node -- the maximum length path to 
            a leaf. If this node has two children that are leaves, the
            depth in 1.
            </summary>
      <value>The depth of this node.</value>
    </member>
    <member name="T:Magnum.Collections.BigList`1.BigListRange">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of a BigList. The object stores a wrapped list, and a start/count indicating
            a sub-range of the list. Insertion/deletions through the sub-range view
            cause the count to change also; insertions and deletions directly on
            the wrapped list do not.
            </summary>
      <remarks>This is different from Algorithms.Range in a very few respects:
            it is specialized to only wrap BigList, and it is a lot more efficient in enumeration.</remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor">
      <summary>
            Creates a new BigList. The BigList is initially empty.
            </summary>
      <remarks>Creating a empty BigList takes constant time and consumes a very small amount of memory.</remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new BigList initialized with the items from <paramref name="collection" />, in order.
            </summary>
      <remarks>Initializing the tree list with the elements of collection takes time O(N), where N is the number of
            items in <paramref name="collection" />.</remarks>
      <param name="collection">The collection used to initialize the BigList. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
      <summary>
            Creates a new BigList initialized with a given number of copies of the items from <paramref name="collection" />, in order. 
            </summary>
      <remarks>Initializing the tree list with the elements of collection takes time O(N + log K), where N is the number of
            items in <paramref name="collection" />, and K is the number of copies.</remarks>
      <param name="copies">Number of copies of the collection to use.</param>
      <param name="collection">The collection used to initialize the BigList. </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="copies" /> is negative.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(Magnum.Collections.BigList{`0})">
      <summary>
            Creates a new BigList that is a copy of <paramref name="list" />.
            </summary>
      <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <param name="list">The BigList to copy. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(Magnum.Collections.BigList{`0},System.Int32)">
      <summary>
            Creates a new BigList that is several copies of <paramref name="list" />.
            </summary>
      <remarks>Creating K copies of a BigList takes time O(log K), and O(log K) 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <param name="copies">Number of copies of the collection to use.</param>
      <param name="list">The BigList to copy. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(Magnum.Collections.BigList{`0}.Node)">
      <summary>
            Creates a new BigList from the indicated Node.
            </summary>
      <param name="node">Node that becomes the new root. If null, the new BigList is empty.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Clear">
      <summary>
            Removes all of the items from the BigList.
            </summary>
      <remarks>Clearing a BigList takes constant time.</remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Insert(System.Int32,`0)">
      <summary>
            Inserts a new item at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> move up one index.
            </summary>
      <remarks>The amount of time to insert an item is O(log N), no matter where
            in the list the insertion occurs. Inserting an item at the beginning or end of the 
            list is O(N). 
            </remarks>
      <param name="index">The index to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Inserts a collection of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices 
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert an arbitrary collection in the BigList is O(M + log N), 
            where M is the number of items inserted, and N is the number of items in the list.
            </remarks>
      <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
      <param name="collection">The collection of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.InsertRange(System.Int32,Magnum.Collections.BigList{`0})">
      <summary>
            Inserts a BigList of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices 
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert another BigList is O(log N), 
            where N is the number of items in the list, regardless of the number of items in the 
            inserted list. Storage is shared between the two lists until one of them is changed.
            </remarks>
      <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
      <param name="list">The BigList of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the given index in the BigList. All items at indexes 
            greater than <paramref name="index" /> move down one index.
            </summary>
      <remarks>The amount of time to delete an item in the BigList is O(log N),
            where N is the number of items in the list. 
            </remarks>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down <paramref name="count" /> indices
            in the Deque.
            </summary>
      <remarks>The amount of time to delete <paramref name="count" /> items in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus <paramref name="count" />: 
            O(count + Min(<paramref name="index" />, Count - 1 - <paramref name="index" />)).
            </remarks>
      <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
      <param name="count">The number of items to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count, or <paramref name="count" /> is less than zero
            or too large.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Add(`0)">
      <summary>
            Adds an item to the end of the BigList. The indices of all existing items
            in the Deque are unchanged. 
            </summary>
      <remarks>Adding an item takes, on average, constant time.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddToFront(`0)">
      <summary>
            Adds an item to the beginning of the BigList. The indices of all existing items
            in the Deque are increased by one, and the new item has index zero. 
            </summary>
      <remarks>Adding an item takes, on average, constant time.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in the added collection becomes the
            last item in the BigList.
            </summary>
      <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection" />, and N is the size of the BigList.</remarks>
      <param name="collection">The collection of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRangeToFront(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the front of BigList. The indices of all existing items
            in the are increased by the number of items in <paramref name="collection" />. 
            The first item in the added collection becomes the first item in the BigList.
            </summary>
      <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection" />, and N is the size of the BigList.</remarks>
      <param name="collection">The collection of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Clone">
      <summary>
            Creates a new BigList that is a copy of this list.
            </summary>
      <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <returns>A copy of the current list</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.CloneContents">
      <summary>
            Makes a deep clone of this BigList. A new BigList is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then this method is the same as Clone.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>If T is a reference type, cloning the list takes time approximate O(N), where N is the number of items in the list.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRange(Magnum.Collections.BigList{`0})">
      <summary>
            Adds a BigList of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in <paramref name="list" /> becomes the
            last item in this list. The added list <paramref name="list" /> is unchanged.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list" /> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
      <param name="list">The list of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRangeToFront(Magnum.Collections.BigList{`0})">
      <summary>
            Adds a BigList of items to the front of BigList. The indices of all existing items
            are increased by the number of items in <paramref name="list" />. The first item in <paramref name="list" /> 
            becomes the first item in this list. The added list <paramref name="list" /> is unchanged.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list" /> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
      <param name="list">The list of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.GetRange(System.Int32,System.Int32)">
      <summary>
            Creates a new list that contains a subrange of elements from this list. The
            current list is unchanged.
            </summary>
      <remarks>This method takes take O(log N), where N is the size of the current list. Although
            the sub-range is conceptually copied, storage is shared between the two lists until a change
            is made to the shared items.</remarks>
      <remarks>If a view of a sub-range is desired, instead of a copy, use the
            more efficient <see cref="M:Magnum.Collections.BigList`1.Range(System.Int32,System.Int32)" /> method, which provides a view onto a sub-range of items.</remarks>
      <param name="index">The starting index of the sub-range.</param>
      <param name="count">The number of items in the sub-range. If this is zero,
            the returned list is empty.</param>
      <returns>A new list with the <paramref name="count" /> items that start at <paramref name="index" />.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>
        <para>If a copy of the sub-range is desired, use the <see cref="M:Magnum.Collections.BigList`1.GetRange(System.Int32,System.Int32)" /> method instead.</para>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.ReverseInPlace(list.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="index">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> + <paramref name="count" /> is greater than the
            size of this list.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. Usually, the
            foreach statement is used to call this method implicitly.
            </summary>
      <remarks>Enumerating all of the items in the list take time O(N), where
            N is the number of items in the list. Using GetEnumerator() or foreach
            is much more efficient than accessing all items by index.</remarks>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConvertAll``1(System.Converter{`0,``0})">
      <summary>
            Convert the list to a new list by applying a delegate to each item in the collection. The resulting list
            contains the result of applying <paramref name="converter" /> to each item in the list, in
            order. The current list is unchanged.
            </summary>
      <typeparam name="TDest">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in <type name="BigList&lt;T&gt;" />.</param>
      <returns>The resulting BigList from applying <paramref name="converter" /> to each item in this list.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Reverse">
      <summary>
            Reverses the current list in place.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Reverse(System.Int32,System.Int32)">
      <summary>
            Reverses the items in the range of <paramref name="count" /> items starting from <paramref name="start" />, in place.
            </summary>
      <param name="start">The starting index of the range to reverse.</param>
      <param name="count">The number of items in range to reverse.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Sort">
      <summary>
            Sorts the list in place.
            </summary>
      <remarks>
        <para>The Quicksort algorithm is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Values are compared by using the IComparable or IComparable&lt;T&gt;
            interface implementation on the type T.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sorts the list in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Sort(System.Comparison{`0})">
      <summary>
            Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.BinarySearch(`0)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            in the order defined by the default ordering of the item type; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <param name="comparer">The IComparer&lt;T&gt; interface used to sort the list.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.BinarySearch(`0,System.Comparison{`0})">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <param name="comparison">The comparison delegate used to sort the list.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Validate">
      <summary>
            Attempts to validate the internal consistency of the tree.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Print">
      <summary>
            Prints out the internal structure of the tree, for debugging purposes.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Rebalance">
      <summary>
            Rebalance the current tree. Once rebalanced, the depth of the current tree is no more than
            two levels from fully balanced, where fully balanced is defined as having Fibonacci(N+2) or more items
            in a tree of depth N.
            </summary>
      <remarks>The rebalancing algorithm is from "Ropes: an Alternative to Strings", by 
            Boehm, Atkinson, and Plass, in SOFTWARE--PRACTICE AND EXPERIENCE, VOL. 25(12), 1315–1330 (DECEMBER 1995).
            </remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.GetEnumerator(System.Int32,System.Int32)">
      <summary>
            Enumerates a range of the items in the list, in order. The item at <paramref name="start" />
            is enumerated first, then the next item at index 1, and so on. At most <paramref name="maxItems" />
            items are enumerated. 
            </summary>
      <remarks>Enumerating all of the items in the list take time O(N), where
            N is the number of items being enumerated. Using GetEnumerator() or foreach
            is much more efficient than accessing all items by index.</remarks>
      <param name="start">Index to start enumerating at.</param>
      <param name="maxItems">Max number of items to enumerate.</param>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.CheckBalance">
      <summary>
            Check the balance of the current tree and rebalance it if it is more than BALANCEFACTOR
            levels away from fully balanced. Note that rebalancing a tree may leave it two levels away from 
            fully balanced.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddNodeToRebalanceArray(Magnum.Collections.BigList{`0}.Node[],Magnum.Collections.BigList{`0}.Node,System.Boolean)">
      <summary>
            Part of the rebalancing algorithm. Adds a node to the rebalance array. If it is already balanced, add it directly, otherwise
            add its children.
            </summary>
      <param name="rebalanceArray">Rebalance array to insert into.</param>
      <param name="node">Node to add.</param>
      <param name="shared">If true, mark the node as shared before adding, because one
            of its parents was shared.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.op_Addition(Magnum.Collections.BigList{`0},Magnum.Collections.BigList{`0})">
      <summary>
            Concatenates two lists together to create a new list. Both lists being concatenated
            are unchanged. The resulting list contains all the items in <paramref name="first" />, followed
            by all the items in <paramref name="second" />.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in both lists are
            copied, storage is shared until changes are made to the 
            shared sections.</remarks>
      <param name="first">The first list to concatenate.</param>
      <param name="second">The second list to concatenate.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.NodeFromEnumerable(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Given an IEnumerable&lt;T&gt;, create a new Node with all of the 
            items in the enumerable. Returns null if the enumerable has no items.
            </summary>
      <param name="collection">The collection to copy.</param>
      <returns>Returns a Node, not shared or with any shared children, 
            with the items from the collection. If the collection was empty,
            null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafFromEnumerator(System.Collections.Generic.IEnumerator{`0})">
      <summary>
            Consumes up to MAXLEAF items from an Enumerator and places them in a leaf
            node. If the enumerator is at the end, null is returned.
            </summary>
      <param name="enumerator">The enumerator to take items from.</param>
      <returns>A LeafNode with items taken from the enumerator. </returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.NCopiesOfNode(System.Int32,Magnum.Collections.BigList{`0}.Node)">
      <summary>
            Create a node that has N copies of the given node. 
            </summary>
      <param name="copies">Number of copies. Must be non-negative.</param>
      <param name="node">Node to make copies of.</param>
      <returns>null if node is null or copies is 0. Otherwise, a node consisting of <paramref name="copies" /> copies
            of node.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">copies is negative.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddBalancedNodeToRebalanceArray(Magnum.Collections.BigList{`0}.Node[],Magnum.Collections.BigList{`0}.Node)">
      <summary>
            Part of the rebalancing algorithm. Adds a balanced node to the rebalance array. 
            </summary>
      <param name="rebalanceArray">Rebalance array to insert into.</param>
      <param name="balancedNode">Node to add.</param>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Count">
      <summary>
            Gets the number of items stored in the BigList. The indices of the items
            range from 0 to Count-1.
            </summary>
      <remarks>Getting the number of items in the BigList takes constant time.</remarks>
      <value>The number of items in the BigList.</value>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Item(System.Int32)">
      <summary>
            Gets or sets an item in the list, by index.
            </summary>
      <remarks>
        <para> Gettingor setting an item takes time O(log N), where N is the number of items
            in the list.</para>
        <para>To process each of the items in the list, using GetEnumerator() or a foreach loop is more efficient
            that accessing each of the elements by index.</para>
      </remarks>
      <param name="index">The index of the item to get or set. The first item in the list
            has index 0, the last item has index Count-1.</param>
      <returns>The value of the item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero or 
            greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.Comparers">
      <summary>
            A collection of methods to create IComparer and IEqualityComparer instances in various ways.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.KeyValueEqualityComparer`2">
      <summary>
            Class to change an IEqualityComparer&lt;TKey&gt; to an IEqualityComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Only the keys are compared.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.KeyValueComparer`2">
      <summary>
            Class to change an IComparer&lt;TKey&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Only the keys are compared.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.PairComparer`2">
      <summary>
            Class to change an IComparer&lt;TKey&gt; and IComparer&lt;TValue&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Keys are compared, followed by values.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.ComparisonComparer`1">
      <summary>
            Class to change an Comparison&lt;T&gt; to an IComparer&lt;T&gt;.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.ComparisonKeyValueComparer`2">
      <summary>
            Class to change an Comparison&lt;TKey&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.
            GetHashCode cannot be used on this class.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerFromComparison``1(System.Comparison{``0})">
      <summary>
            Given an Comparison on a type, returns an IComparer on that type. 
            </summary>
      <typeparam name="T">T to compare.</typeparam>
      <param name="comparison">Comparison delegate on T</param>
      <returns>IComparer that uses the comparison.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerKeyValueFromComparerKey``2(System.Collections.Generic.IComparer{``0})">
      <summary>
            Given an IComparer on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparer">IComparer on TKey</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.EqualityComparerKeyValueFromComparerKey``2(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Given an IEqualityComparer on TKey, returns an IEqualityComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyEqualityComparer">IComparer on TKey</param>
      <returns>IEqualityComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerPairFromKeyValueComparers``2(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IComparer{``1})">
      <summary>
            Given an IComparer on TKey and TValue, returns an IComparer on
            key-value Pairs of TKey and TValue, comparing first keys, then values. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparer">IComparer on TKey</param>
      <param name="valueComparer">IComparer on TValue</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerKeyValueFromComparisonKey``2(System.Comparison{``0})">
      <summary>
            Given an Comparison on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparison">Comparison delegate on TKey</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.DefaultComparer``1">
      <summary>
            Given an element type, check that it implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare elements of that type.
            </summary>
      <returns>The IComparer&lt;T&gt; instance.</returns>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;T&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.Comparers.DefaultKeyValueComparer``2">
      <summary>
            Given an key and value type, check that TKey implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare KeyValuePairs of those types.
            </summary>
      <returns>The IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; instance.</returns>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;T&gt;.</exception>
    </member>
    <member name="T:Magnum.Collections.Deque`1">
      <summary>
        <para>The Deque class implements a type of list known as a Double Ended Queue. A Deque
            is quite similar to a List, in that items have indices (starting at 0), and the item at any
            index can be efficiently retrieved. The difference between a List and a Deque lies in the
            efficiency of inserting elements at the beginning. In a List, items can be efficiently added
            to the end, but inserting an item at the beginning of the List is slow, taking time 
            proportional to the size of the List. In a Deque, items can be added to the beginning 
            or end equally efficiently, regardless of the number of items in the Deque. As a trade-off
            for this increased flexibility, Deque is somewhat slower than List (but still constant time) when
            being indexed to get or retrieve elements. </para>
      </summary>
      <remarks>
        <para>The Deque class can also be used as a more flexible alternative to the Queue 
            and Stack classes. Deque is as efficient as Queue and Stack for adding or removing items, 
            but is more flexible: it allows access
            to all items in the queue, and allows adding or removing from either end.</para>
        <para>Deque is implemented as a ring buffer, which is grown as necessary. The size
            of the buffer is doubled whenever the existing capacity is too small to hold all the
            elements.</para>
      </remarks>
      <typeparam name="T">The type of items stored in the Deque.</typeparam>
    </member>
    <member name="M:Magnum.Collections.Deque`1.#ctor">
      <summary>
            Create a new Deque that is initially empty.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Create a new Deque initialized with the items from the passed collection,
            in order.
            </summary>
      <param name="collection">A collection of items to initialize the Deque with.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the Deque into an array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.TrimToSize">
      <summary>
            Trims the amount of memory used by the Deque by changing
            the Capacity to be equal to Count. If no more items will be added
            to the Deque, calling TrimToSize will reduce the amount of memory
            used by the Deque.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Clear">
      <summary>
            Removes all items from the Deque.
            </summary>
      <remarks>Clearing the Deque takes a small constant amount of time, regardless of
            how many items are currently in the Deque.</remarks>
    </member>
    <member name="M:Magnum.Collections.Deque`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. If the items
            are added to or removed from the Deque during enumeration, the 
            enumeration ends with an InvalidOperationException.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Insert(System.Int32,`0)">
      <summary>
            Inserts a new item at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index" /> move up one index
            in the Deque.
            </summary>
      <remarks>The amount of time to insert an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - <paramref name="index" />)).
            Thus, inserting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to insert.
            </remarks>
      <param name="index">The index in the Deque to insert the item at. After the
            insertion, the inserted item is located at this index. The
            front item in the Deque has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Inserts a collection of items at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices in the Deque
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert a collection in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus the number of items
            inserted (M): 
            O(M + Min(<paramref name="index" />, Count - <paramref name="index" />)).
            </remarks>
      <param name="index">The index in the Deque to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            front item in the Deque has index 0.</param>
      <param name="collection">The collection of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down one index
            in the Deque.
            </summary>
      <remarks>The amount of time to delete an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - 1 - <paramref name="index" />)).
            Thus, deleting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to delete.
            </remarks>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down <paramref name="count" /> indices
            in the Deque.
            </summary>
      <remarks>The amount of time to delete <paramref name="count" /> items in the Deque is proportional
            to the distance to the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - <paramref name="index" /> - <paramref name="count" />)).
            </remarks>
      <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
      <param name="count">The number of items to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count, or <paramref name="count" /> is less than zero
            or too large.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddToFront(`0)">
      <summary>
            Adds an item to the front of the Deque. The indices of all existing items
            in the Deque are increased by 1. This method is 
            equivalent to <c>Insert(0, item)</c> but is a little more
            efficient.
            </summary>
      <remarks>Adding an item to the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddManyToFront(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the front of the Deque. The indices of all existing items
            in the Deque are increased by the number of items inserted. The first item in the added collection becomes the
            first item in the Deque. 
            </summary>
      <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection" />.</remarks>
      <param name="collection">The collection of items to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddToBack(`0)">
      <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>Insert(Count, item)</c> but is a little more
            efficient.
            </summary>
      <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Add(`0)">
      <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>AddToBack(item)</c>.
            </summary>
      <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddManyToBack(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. The last item in the added collection becomes the
            last item in the Deque.
            </summary>
      <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection" />.</remarks>
      <param name="collection">The collection of item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveFromFront">
      <summary>
            Removes an item from the front of the Deque. The indices of all existing items
            in the Deque are decreased by 1. This method is 
            equivalent to <c>RemoveAt(0)</c> but is a little more
            efficient.
            </summary>
      <remarks>Removing an item from the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item that was removed.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveFromBack">
      <summary>
            Removes an item from the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>RemoveAt(Count-1)</c> but is a little more
            efficient.
            </summary>
      <remarks>Removing an item from the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.GetAtFront">
      <summary>
            Retreives the item currently at the front of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[0]</c> (except that a different exception is thrown).
            </summary>
      <remarks>Retreiving the item at the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item at the front of the Deque.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.GetAtBack">
      <summary>
            Retreives the item currently at the back of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[deque.Count - 1]</c> (except that a different exception is thrown).
            </summary>
      <remarks>Retreiving the item at the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item at the back of the Deque.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Clone">
      <summary>
            Creates a new Deque that is a copy of this one.
            </summary>
      <remarks>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</remarks>
      <returns>A copy of the current deque.</returns>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CloneContents">
      <summary>
            Makes a deep clone of this Deque. A new Deque is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the Deque takes time O(N), where N is the number of items in the Deque.</para>
      </remarks>
      <returns>The cloned Deque.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Print">
      <summary>
            Print out the internal state of the Deque for debugging.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CreateInitialBuffer(`0)">
      <summary>
            Creates the initial buffer and initialized the Deque to contain one initial
            item.
            </summary>
      <param name="firstItem">First and only item for the Deque.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.IncreaseBuffer">
      <summary>
            Increase the amount of buffer space. When calling this method, the Deque
            must not be empty. If start and end are equal, that indicates a completely
            full Deque.
            </summary>
    </member>
    <member name="P:Magnum.Collections.Deque`1.Count">
      <summary>
            Gets the number of items currently stored in the Deque. The last item
            in the Deque has index Count-1.
            </summary>
      <remarks>Getting the count of items in the Deque takes a small constant
            amount of time.</remarks>
      <value>The number of items stored in this Deque.</value>
    </member>
    <member name="P:Magnum.Collections.Deque`1.Capacity">
      <summary>
            Gets or sets the capacity of the Deque. The Capacity is the number of
            items that this Deque can hold without expanding its internal buffer. Since
            Deque will automatically expand its buffer when necessary, in almost all cases
            it is unnecessary to worry about the capacity. However, if it is known that a
            Deque will contain exactly 1000 items eventually, it can slightly improve 
            efficiency to set the capacity to 1000 up front, so that the Deque does not
            have to expand automatically.
            </summary>
      <value>The number of items that this Deque can hold without expanding its
            internal buffer.</value>
      <exception cref="T:System.ArgumentOutOfRangeException">The capacity is being set
            to less than Count, or to too large a value.</exception>
    </member>
    <member name="P:Magnum.Collections.Deque`1.Item(System.Int32)">
      <summary>
            Gets or sets an item at a particular index in the Deque. 
            </summary>
      <remarks>Getting or setting the item at a particular index takes a small constant amount
            of time, no matter what index is used.</remarks>
      <param name="index">The index of the item to retrieve or change. The front item has index 0, and
            the back item has index Count-1.</param>
      <returns>The value at the indicated index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The index is less than zero or greater than or equal
            to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2">
      <summary>
            DictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
      <remarks>
        <para>To use DictionaryBase as a base class, the derived class must override
            Count, GetEnumerator, TryGetValue, Clear, Remove, and the indexer set accessor. </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2.DictionaryEnumeratorWrapper">
      <summary>
            A class that wraps a IDictionaryEnumerator around an IEnumerator that
            enumerates KeyValuePairs. This is useful in implementing IDictionary, because
            IEnumerator can be implemented with an iterator, but IDictionaryEnumerator cannot.
            </summary>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Clear">
      <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter. This method must be
            overridden by the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Add(`0,`1)">
      <summary>
            Adds a new key-value pair to the dictionary. 
            </summary>
      <remarks>The default implementation of this method
            checks to see if the key already exists using 
            ContainsKey, then calls the indexer setter if the key doesn't
            already exist. </remarks>
      <param name="key">Key to add.</param>
      <param name="value">Value to associated with the key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.AsReadOnly">
      <summary>
            Provides a read-only view of this dictionary. The returned IDictionary&lt;TKey,TValue&gt; provides
            a view of the dictionary that prevents modifications to the dictionary. Use the method to provide
            access to the dictionary without allowing changes. Since the returned object is just a view,
            changes to the dictionary will be reflected in the view.
            </summary>
      <returns>An IIDictionary&lt;TKey,TValue&gt; that provides read-only access to the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Adds a key-value pair to the collection. This implementation calls the Add method
            with the Key and Value from the item.
            </summary>
      <param name="item">A KeyValuePair contains the Key and Value to add.</param>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair, and if so, removes it. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value. If so, the key-value pair is removed.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>True if the item was found and removed. False otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.CheckGenericType``1(System.String,System.Object)">
      <summary>
            Check that the given parameter is of the expected generic type. Throw an ArgumentException
            if it isn't.
            </summary>
      <typeparam name="ExpectedType">Expected type of the parameter</typeparam>
      <param name="name">parameter name</param>
      <param name="value">parameter value</param>
    </member>
    <member name="P:Magnum.Collections.DictionaryBase`2.Item(`0)">
      <summary>
            The indexer of the dictionary. This is used to store keys and values and
            retrieve values from the dictionary. The setter
            accessor must be overridden in the derived class.
            </summary>
      <param name="key">Key to find in the dictionary.</param>
      <returns>The value associated with the key.</returns>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found in the dictionary.</exception>
    </member>
    <member name="P:Magnum.Collections.DictionaryBase`2.Keys">
      <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
      <value>A read-only collection of the keys in this dictionary.</value>
    </member>
    <member name="P:Magnum.Collections.DictionaryBase`2.Values">
      <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
      <value>A read-only collection of the values in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyCollectionBase`1">
      <summary>
            ReadOnlyCollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces for a read-only collection:
            a collection that does not allow adding or removing elements.
            </summary>
      <remarks>
        <para>To use ReadOnlyCollectionBase as a base class, the derived class must override
            the Count and GetEnumerator methods. </para>
        <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the ReadOnlyCollectionBase implementation
            may not be very efficient.</para>
      </remarks>
      <typeparam name="T">The item type of the collection.</typeparam>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.DebuggerDisplayString">
      <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ToString">
      <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection.
            </summary>
      <returns>The string representation of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.Exists(System.Predicate{`0})">
      <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.TrueForAll(System.Predicate{`0})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.CountWhere(System.Predicate{`0})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.FindAll(System.Predicate{`0})">
      <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ForEach(System.Action{`0})">
      <summary>
            Performs the specified action on each item in this collection.
            </summary>
      <param name="action">An Action delegate which is invoked for each item in this collection.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ConvertAll``1(System.Converter{`0,``0})">
      <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter" /> to each item in this collection, in
            order.
            </summary>
      <typeparam name="TOutput">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
      <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter" /> to each item in this collection in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.Contains(`0)">
      <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item" /> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
      <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation.</remarks>
      <param name="item">The item to check for in the collection.</param>
      <returns>True if the collection contains <paramref name="item" />, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ToArray">
      <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
      <returns>An array containing all the elements in the collection, in order.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.GetEnumerator">
      <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
      <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyCollectionBase`1.Count">
      <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
      <value>The number of items in the collection.</value>
    </member>
    <member name="T:Magnum.Collections.Hash`1">
      <summary>
             The base implementation for various collections classes that use hash tables
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package. The Hash
             does not handle duplicate values.
             </summary>
      <remarks>
             The Hash manages items of type T, and uses a IComparer&lt;ItemTYpe&gt; that
             hashes compares items to hash items into the table.  
            </remarks>
    </member>
    <member name="T:Magnum.Collections.Hash`1.Slot">
      <summary>
            The structure that has each slot in the hash table. Each slot has three parts:
            1. The collision bit. Indicates whether some item visited this slot but had to
            keep looking because the slot was full. 
            2. 31-bit full hash value of the item. If zero, the slot is empty.
            3. The item itself.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Slot.Clear">
      <summary>
            Clear this slot, leaving the collision bit alone.
            </summary>
    </member>
    <member name="P:Magnum.Collections.Hash`1.Slot.HashValue">
      <summary>
            The full hash value associated with the value in this slot, or zero
            if the slot is empty.
            </summary>
    </member>
    <member name="P:Magnum.Collections.Hash`1.Slot.Empty">
      <summary>
            Is this slot empty?
            </summary>
    </member>
    <member name="P:Magnum.Collections.Hash`1.Slot.Collision">
      <summary>
            The "Collision" bit indicates that some value hit this slot and
            collided, so had to try another slot.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructor. Create a new hash table.
            </summary>
      <param name="equalityComparer">The comparer to use to compare items. </param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetEnumerator">
      <summary>
            Enumerate all of the items in the hash table. The items
            are enumerated in a haphazard, unpredictable order.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates the items
            in the hash table.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Insert(`0,System.Boolean,`0@)">
      <summary>
            Insert a new item into the hash table. If a duplicate item exists, can replace or
            do nothing.
            </summary>
      <param name="item">The item to insert.</param>
      <param name="replaceOnDuplicate">If true, duplicate items are replaced. If false, nothing
            is done if a duplicate already exists.</param>
      <param name="previous">If a duplicate was found, returns it (whether replaced or not).</param>
      <returns>True if no duplicate existed, false if a duplicate was found.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Delete(`0,`0@)">
      <summary>
            Deletes an item from the hash table. 
            </summary>
      <param name="item">Item to search for and delete.</param>
      <param name="itemDeleted">If true returned, the actual item stored in the hash table (must be 
            equal to <paramref name="item" />, but may not be identical.</param>
      <returns>True if item was found and deleted, false if item wasn't found.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Find(`0,System.Boolean,`0@)">
      <summary>
            Find an item in the hash table. If found, optionally replace it with the
            finding item.
            </summary>
      <param name="find">Item to find.</param>
      <param name="replace">If true, replaces the equal item in the hash table
            with <paramref name="item" />.</param>
      <param name="item">Returns the equal item found in the table, if true was returned.</param>
      <returns>True if the item was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Clone(System.Converter{`0,`0})">
      <summary>
            Creates a clone of this hash table.
            </summary>
      <param name="cloneItem">If non-null, this function is applied to each item when cloning. It must be the 
            case that this function does not modify the hash code or equality function.</param>
      <returns>A shallow clone that contains the same items.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetEnumerationStamp">
      <summary>
            Gets the current enumeration stamp. Call CheckEnumerationStamp later
            with this value to throw an exception if the hash table is changed.
            </summary>
      <returns>The current enumeration stamp.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.PrintStats">
      <summary>
            Print out basic stats about the hash table.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Print">
      <summary>
            Print out the state of the hash table and each of the slots. Each slot looks like:
                Slot    4: C 4513e41e hello
            where the "C" indicates the collision bit is on
            the next hex number is the hash value
            followed by ToString() on the item.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Validate">
      <summary>
            Check that everything appears to be OK in the hash table.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetFullHash(`0)">
      <summary>
            Gets the full hash code for an item.
            </summary>
      <param name="item">Item to get hash code for.</param>
      <returns>The full hash code. It is never zero.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetHashValuesFromFullHash(System.Int32,System.Int32@,System.Int32@)">
      <summary>
            Get the initial bucket number and skip amount from the full hash value.
            </summary>
      <param name="hash">The full hash value.</param>
      <param name="initialBucket">Returns the initial bucket. Always in the range 0..(totalSlots - 1).</param>
      <param name="skip">Returns the skip values. Always odd in the range 0..(totalSlots - 1).</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetHashValues(`0,System.Int32@,System.Int32@)">
      <summary>
            Gets the full hash value, initial bucket number, and skip amount for an item.
            </summary>
      <param name="item">Item to get hash value of.</param>
      <param name="initialBucket">Returns the initial bucket. Always in the range 0..(totalSlots - 1).</param>
      <param name="skip">Returns the skip values. Always odd in the range 0..(totalSlots - 1).</param>
      <returns>The full hash value. This is never zero.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.EnsureEnoughSlots(System.Int32)">
      <summary>
            Make sure there are enough slots in the hash table that <paramref name="additionalItems" />
            items can be inserted into the table.
            </summary>
      <param name="additionalItems">Number of additional items we are inserting.</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.ShrinkIfNeeded">
      <summary>
            Check if the number of items in the table is small enough that
            we should shrink the table again.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.ResizeTable(System.Int32)">
      <summary>
            Resize the hash table to the given new size, moving all items into the
            new hash table.
            </summary>
      <param name="newSize">The new size of the hash table. Must be a power
            of two.</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Called on deserialization. We cannot deserialize now, because hash codes
            might not be correct now. We do real deserialization in the OnDeserialization call.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetSecondaryShift(System.Int32)">
      <summary>
            Given the size of a hash table, compute the "secondary shift" value -- the shift
            that is used to determine the skip amount for collision resolution.
            </summary>
      <param name="newSize">The new size of the table.</param>
      <returns>The secondary skip amount.</returns>
    </member>
    <member name="P:Magnum.Collections.Hash`1.ElementCount">
      <summary>
            Get the number of items in the hash table.
            </summary>
      <value>The number of items stored in the hash table.</value>
    </member>
    <member name="P:Magnum.Collections.Hash`1.LoadFactor">
      <summary>
            Get or change the load factor. Changing the load factor may cause
            the size of the table to grow or shrink accordingly.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Magnum.Collections.Hash`1.SlotCount">
      <summary>
            Get the number of slots in the hash table. Exposed internally
            for testing purposes.
            </summary>
      <value>The number of slots in the hash table.</value>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2">
      <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface.
            </summary>
      <remarks>
        <para>To use MultiDictionaryBase as a base class, the derived class must override
            Count, Clear, Add, Remove(TKey), Remove(TKey,TValue), Contains(TKey,TValue), 
            EnumerateKeys, and TryEnumerateValuesForKey. </para>
        <para>It may wish consider overriding CountValues, CountAllValues, ContainsKey,
            and EqualValues, but these are not required.
            </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection">
      <summary>
            A private class that provides the ICollection&lt;TValue&gt; for a particular key. This is the collection
            that is returned from the indexer. The collections is read-write, live, and can be used to add, remove,
            etc. values from the multi-dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Clear">
      <summary>
            Remove the key and all values associated with it.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.GetEnumerator">
      <summary>
            Enumerate all the values associated with key.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that enumerates all the values associated with key.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.NoValues">
      <summary>
            A simple function that returns an IEnumerator&lt;TValue&gt; that
            doesn't yield any values. A helper.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that yields no values.</returns>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Count">
      <summary>
            Get the number of values associated with the key.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.EnumerableValuesCollection">
      <summary>
            A private class that implements ICollection&lt;ICollection&lt;TValue&gt;&gt; and ICollection for the
            Values collection on IDictionary. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.KeyValuePairsCollection">
      <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Clear">
      <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Adds a key-value pair to the collection. The value part of the pair must be a collection
            of values to associate with the key. If values are already associated with the given
            key, the new values are added to the ones associated with that key.
            </summary>
      <param name="item">A KeyValuePair contains the Key and Value collection to add.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Removes a set of values from a given key. If all values associated with a key are
            removed, then the key is removed also.
            </summary>
      <param name="pair">A KeyValuePair contains a key and a set of values to remove from that key.</param>
      <returns>True if at least one values was found and removed.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryEnumerateValuesForKey.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
      <param name="pair">A key and collection of values to search for.</param>
      <returns>True if the dictionary has associated all of the values in <paramref name="pair" />.Value with <paramref name="pair" />.Key.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.GetEnumerator">
      <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
      <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.AddMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
        <para>Adds new values to be associated with a key. If duplicate values are permitted, this
            method always adds new key-value pairs to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to one of <paramref name="values" /> associated with it, then that value is replaced,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="values">A collection of values to associate with <paramref name="key" />.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Add(`0,`1)">
      <summary>
            Adds a new key-value pair to the dictionary.  This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to add.</param>
      <param name="value">Value to associated with the key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Remove(`0,`1)">
      <summary>
            Removes a key-value pair from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <param name="value">Associated value to remove from the dictionary.</param>
      <returns>True if the key-value pair was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.RemoveMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Removes a collection of values from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove values from.</param>
      <param name="values">A collection of values to remove.</param>
      <returns>The number of values that were present and removed. </returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all of the keys (and any associated values) in a collection
            of keys. If a key is not present in the dictionary, nothing happens.
            </summary>
      <param name="keyCollection">A collection of key values to remove.</param>
      <returns>The number of keys from the collection that were present and removed.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Contains(`0,`1)">
      <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key" /> and 
            <paramref name="value" />. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">The value to search for.</param>
      <returns>True if the dictionary has associated <paramref name="value" /> with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Replace(`0,`1)">
      <summary>
            Replaces all values associated with <paramref name="key" /> with the single value <paramref name="value" />.
            </summary>
      <remarks>This implementation simply calls Remove, followed by Add.</remarks>
      <param name="key">The key to associate with.</param>
      <param name="value">The new values to be associated with <paramref name="key" />.</param>
      <returns>Returns true if some values were removed. Returns false if <paramref name="key" /> was not
            present in the dictionary before Replace was called.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ReplaceMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Replaces all values associated with <paramref name="key" /> with a new collection
            of values. If the collection does not permit duplicate values, and <paramref name="values" /> has duplicate
            items, then only the last of duplicates is added.
            </summary>
      <param name="key">The key to associate with.</param>
      <param name="values">The new values to be associated with <paramref name="key" />.</param>
      <returns>Returns true if some values were removed. Returns false if <paramref name="key" /> was not
            present in the dictionary before Replace was called.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values" />. If the key does not exist, false is returned.
            </summary>
      <param name="key">The key to get values for.</param>
      <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
      <returns>True if the key exists and has values associated with it. False otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.EqualValues(`1,`1)">
      <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.CountValues(`0)">
      <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
      <param name="key">The key to count values for.</param>
      <returns>The number of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Values">
      <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
      <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Item(`0)">
      <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key" />,
            or changes the set of values associated with <paramref name="key" />.
            If the key is not present in the dictionary, an ICollection enumerating no
            values is returned. The returned collection of values is read-write, and can be used to 
            modify the collection of values associated with the key.
            </summary>
      <param name="key">The key to get the values associated with.</param>
      <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key" />.</value>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Count">
      <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Keys">
      <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
      <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.MultiDictionary`2">
      <summary>
        <para>The MultiDictionary class that associates values with a key. Unlike an Dictionary,
             each key can have multiple values associated with it. When indexing an MultiDictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
        <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
      </summary>
      <typeparam name="TKey">The type of the keys.</typeparam>
      <typeparam name="TValue">The of values associated with the keys.</typeparam>
      <seealso cref="T:System.Collections.Generic.Dictionary`2" />
      <seealso cref="T:Magnum.Collections.OrderedMultiDictionary`2" />
    </member>
    <member name="T:Magnum.Collections.MultiDictionary`2.KeyAndValuesEqualityComparer">
      <summary>
            This class implements IEqualityComparer for KeysAndValues, allowing them to be
            compared by their keys. An IEqualityComparer on keys is required.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionary`2.KeyAndValues">
      <summary>
            A structure to hold the key and the values associated with the key.
            The number of values must always be 1 or greater in a version that is stored, but 
            can be zero in a dummy version used only for lookups.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean)">
      <summary>
            Create a new MultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Collections.Generic.IEqualityComparer{Magnum.Collections.MultiDictionary{`0,`1}.KeyAndValues},Magnum.Collections.Hash{Magnum.Collections.MultiDictionary{`0,`1}.KeyAndValues})">
      <summary>
            Create a new MultiDictionary. Private constructor, for use by Clone().
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Add(`0,`1)">
      <summary>
        <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to <paramref name="value" /> associated with it, then that value is replaced with <paramref name="value" />,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="value">The value to associated with <paramref name="key" />.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Remove(`0,`1)">
      <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove a value from.</param>
      <param name="value">The value to remove.</param>
      <returns>True if <paramref name="value" /> was associated with <paramref name="key" /> (and was
            therefore removed). False if <paramref name="value" /> was not associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Remove(`0)">
      <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Contains(`0,`1)">
      <summary>
            Checks to see if <paramref name="value" /> is associated with <paramref name="key" />
            in the dictionary.
            </summary>
      <param name="key">The key to check.</param>
      <param name="value">The value to check.</param>
      <returns>True if <paramref name="value" /> is associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.ContainsKey(`0)">
      <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
      <param name="key">The key to check.</param>
      <returns>True if <paramref name="key" /> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.EqualValues(`1,`1)">
      <summary>
            Determine if two values are equal.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the dictionary that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
      <param name="key">The key to search for.</param>
      <param name="values">Returns all values associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.CountValues(`0)">
      <summary>
            Gets the number of values associated with a given key.
            </summary>
      <param name="key">The key to count values of.</param>
      <returns>The number of values associated with <paramref name="key" />. If <paramref name="key" />
            is not present in the dictionary, zero is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.EnumerateValues(Magnum.Collections.MultiDictionary{`0,`1}.KeyAndValues)">
      <summary>
             Enumerate the values in the a KeyAndValues structure. Can't return
            the array directly because:
              a) The array might be larger than the count.
              b) We can't allow clients to down-cast to the array and modify it.
              c) We have to abort enumeration if the hash changes.
            </summary>
      <param name="keyAndValues">Item with the values to enumerate..</param>
      <returns>An enumerable that enumerates the items in the KeyAndValues structure.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.NonCloneableType(System.Type)">
      <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
      <param name="t">Type to test.</param>
    </member>
    <member name="P:Magnum.Collections.MultiDictionary`2.KeyComparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TKey (EqualityComparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.MultiDictionary`2.ValueComparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TValue (EqualityComparer&lt;TValue&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.MultiDictionary`2.Count">
      <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
      <value>The number of key-value pairs in the dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.ObjectToDictionaryConverter">
      <summary>
            Converts an object of an anonymous type to a dictionary
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedBag`1">
      <summary>
             OrderedBag&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order. Unlike a OrderedSet, duplicate items (items that
             compare equal to each other) are allows in an OrderedBag.
             </summary>
      <remarks>
        <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedBag is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) + M time, where N is the number of keys in the tree, and M is the current number
             of copies of the element being handled.</p>
        <p>
          <see cref="T:Magnum.Collections.Bag`1" /> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.Bag`1" />
    </member>
    <member name="T:Magnum.Collections.OrderedBag`1.ListView">
      <summary>
            The nested class that provides a read-only list view
            of all or part of the collection.
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedBag`1.View">
      <summary>
             The OrderedBag&lt;T&gt;.View class is used to look at a subset of the items
             inside an ordered bag. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying bag changes, the view changes in sync. If a change is made
             to the view, the underlying bag changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedBag. For example:</p>
        <code>
             foreach(T item in bag.Range(from, to)) {
                // process item
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.GetEnumerator">
      <summary>
            Enumerate all the items in this view.
            </summary>
      <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.Clear">
      <summary>
            Removes all the items within this view from the underlying bag.
            </summary>
      <example>The following removes all the items that start with "A" from an OrderedBag.
            <code>
            bag.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.AsList">
      <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.Reversed">
      <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.GetFirst">
      <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The first item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.GetLast">
      <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The last item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.View.Count">
      <summary>
            Number of items in this view.
            </summary>
      <value>Number of items that lie within the bounds the view.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.View.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor">
      <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag. The bag is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
      <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            The bag is initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IComparer{`0},Magnum.Collections.RedBlackTree{`0})">
      <summary>
            Creates a new OrderedBag given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
      <param name="comparer">Comparer for the bag.</param>
      <param name="tree">Data for the bag.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Clone">
      <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the bag takes time O(N), where N is the number of items in the bag.</remarks>
      <returns>The cloned bag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.CloneContents">
      <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para>
      </remarks>
      <returns>The cloned bag.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.NumberOfCopies(`0)">
      <summary>
            Returns the number of copies of <paramref name="item" /> in the bag. More precisely, returns
            the number of items in the bag that compare equal to <paramref name="item" />.
            </summary>
      <remarks>NumberOfCopies() takes time O(log N + M), where N is the total number of items in the
            bag, and M is the number of copies of <paramref name="item" /> in the bag.</remarks>
      <param name="item">The item to search for in the bag.</param>
      <returns>The number of items in the bag that compare equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the OrderedBag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Contains(`0)">
      <summary>
            Determines if this bag contains an item equal to <paramref name="item" />. The bag
            is not changed.
            </summary>
      <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the bag contains <paramref name="item" />. False if the bag does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetEqualItems(`0)">
      <summary>
        <para>Enumerates all of the items in this bag that are equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the bag was created. The bag
            is not changed.</para>
        <para>If the bag does contain an item equal to <paramref name="item" />, then the enumeration contains
            no items.</para>
      </summary>
      <remarks>Enumeration the items in the bag equal to <paramref name="item" /> takes time O(log N + M), where N 
            is the total number of items in the bag, and M is the number of items equal to <paramref name="item" />.</remarks>
      <param name="item">The item to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in the bag equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.DistinctItems">
      <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
      <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
      <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.LastIndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the largest index of the equal items is returned.
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the last item in the sorted bag equal to <paramref name="item" />, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the smallest index of the equal items is returned.
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the first item in the sorted bag equal to <paramref name="item" />, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Add(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case, the new item is placed after all equal items already present in the bag.
            </summary>
      <remarks>
        <para>Adding an item takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the bag. 
            </summary>
      <remarks>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the bag.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Remove(`0)">
      <summary>
            Searches the bag for one item equal to <paramref name="item" />, and if found,
            removes it from the bag. If not found, the bag is unchanged. If more than one item
            equal to <paramref name="item" />, the item that was last inserted is removed.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing an item from the bag takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the bag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveAllCopies(`0)">
      <summary>
            Searches the bag for all items equal to <paramref name="item" />, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item" />.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>The number of copies of <paramref name="item" /> that were found and removed. </returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the bag. Items not
            present in the bag are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the bag.</param>
      <returns>The number of items removed from the bag.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Clear">
      <summary>
            Removes all items from the bag.
            </summary>
      <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetFirst">
      <summary>
            Returns the first item in the bag: the item
            that would appear first if the bag was enumerated. This is also
            the smallest item in the bag.
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The first item in the bag. If more than one item
            is smallest, the first one added is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetLast">
      <summary>
            Returns the last item in the bag: the item
            that would appear last if the bag was enumerated. This is also the largest
            item in the bag.
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The last item in the bag. If more than one item
            is largest, the last one added is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveFirst">
      <summary>
            Removes the first item in the bag. This is also the smallest
            item in the bag.
            </summary>
      <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The item that was removed, which was the smallest item in the bag. </returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveLast">
      <summary>
            Removes the last item in the bag. This is also the largest item in the bag.
            </summary>
      <remarks>RemoveLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The item that was removed, which was the largest item in the bag. </returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.CheckEmpty">
      <summary>
            If the collection is empty, throw an invalid operation exception.
            </summary>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsSupersetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times.
            </summary>
      <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherBag" />, and N is the size of the this set.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsProperSupersetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsSubsetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherBag" />, and N is the size of the this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsProperSubsetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref nameb="otherBag" />, and N is the size of the this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsDisjointFrom(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherBag">Bag to check disjointness with.</param>
      <returns>True if the two bags are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsEqualTo(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag" /> if they contain the same items, each the
            same number of times.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to</param>
      <returns>True if this bag is equal to <paramref name="otherBag" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.UnionWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Union(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <returns>The union of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.SumWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Sum(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <returns>The sum of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IntersectionWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Intersection(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <returns>The intersection of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.DifferenceWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Difference(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <returns>The difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.SymmetricDifferenceWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.SymmetricDifference(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <returns>The symmetric difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.CheckConsistentComparison(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Check that this bag and another bag were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherBag">Other bag to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherBag and this bag don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.AsList">
      <summary>
            Get a read-only list view of the items in this ordered bag. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedBag.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this OrderedBag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the items in the bag in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Reversed()) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedBag.View of items in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeTo(to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
      <value>If the bag was created using a comparer, that comparer is returned. If the bag was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.Count">
      <summary>
            Returns the number of items in the bag.
            </summary>
      <remarks>The size of the bag is returned in constant time.</remarks>
      <value>The number of items in the bag.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyListBase`1">
      <summary>
            ReadOnlyListBase is an abstract class that can be used as a base class for a read-only collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the Count property and the get part of the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.Contains(`0)">
      <summary>
            Determines if the list contains any item that compares equal to <paramref name="item" />.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the list contains an item that compares equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.IndexOf(`0)">
      <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the first item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.CopyTo(`0[])">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at index 0.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
      <summary>
            Copies a range of elements from the list to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="index">The starting index in the source list of the range to copy.</param>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
      <param name="count">The number of items to copy.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.Find(System.Predicate{`0})">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLast(System.Predicate{`0})">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLastIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.IndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.IndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.LastIndexOf(`0)">
      <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the last item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, 
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. 
            </summary>
      <remarks>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.Reverse(deque.Range(3, 6))</code>
            will return the reverse opf the 6 items beginning at index 3.</remarks>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-part of this list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of the list.</exception>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyListBase`1.Count">
      <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
      <value>The number of items in the list.</value>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyListBase`1.Item(System.Int32)">
      <summary>
            The get part of the indexer must be overridden by the derived class to get 
            values of the list at a particular index.
            </summary>
      <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.OrderedDictionary`2">
      <summary>
             OrderedDictionary&lt;TKey, TValue&gt; is a collection that maps keys of type TKey
             to values of type TValue. The keys are maintained in a sorted order, and at most one value
             is permitted for each key.
             </summary>
      <remarks>
        <p>The keys are compared in one of three ways. If TKey implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare elements. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedDictionary is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
        <p>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
      </remarks>
      <seealso cref="T:System.Collections.Generic.Dictionary`2" />
    </member>
    <member name="T:Magnum.Collections.OrderedDictionary`2.View">
      <summary>
             The OrderedDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedDictionary. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.View.GetEnumerator">
      <summary>
            Enumerate all the keys and values in this view.
            </summary>
      <returns>An IEnumerator of KeyValuePairs with the keys and views in this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.View.Clear">
      <summary>
            Removes all the keys and values within this view from the underlying OrderedDictionary.
            </summary>
      <example>The following removes all the keys that start with "A" from an OrderedDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.View.Reversed">
      <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.View.Count">
      <summary>
            Number of keys in this view.
            </summary>
      <value>Number of keys that lie within the bounds the view.</value>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor">
      <summary>
            Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.
            </summary>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
      <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
        <para>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">
      <summary>
        <para>Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Comparison{`0})">
      <summary>
        <para>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="comparison">A delegate to a method that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Creates a new OrderedDictionary. The passed comparer 
            will be used to compare key-value pairs in this dictionary. Used internally  
            from other constructors.
            </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="keyComparer">An IComparer that will be used to compare keys.</param>
      <param name="pairComparer">An IComparer that will be used to compare key-value pairs.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}},Magnum.Collections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Creates a new OrderedDictionary. The passed comparison delegate 
            will be used to compare keys in this dictionary, and the given tree is used. Used internally for Clone().
            </summary>
      <param name="keyComparer">An IComparer that will be used to compare keys.</param>
      <param name="pairComparer">A delegate to a method that will be used to compare key-value pairs.</param>
      <param name="tree">RedBlackTree that contains the data for the dictionary.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of keys in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of keys in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
        <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
        <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
        <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
        <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Remove(`0)">
      <summary>
            Removes the key (and associated value) from the collection that is equal to the passed in key. If
            no key in the dictionary is equal to the passed key, false is returned and the 
            dictionary is unchanged.
            </summary>
      <remarks>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</remarks>
      <param name="key">The key to remove.</param>
      <returns>True if the key was found and removed. False if the key was not found.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
      <remarks>Clearing the dictionary takes a constant amount of time, regardless of the number of keys in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.GetValueElseAdd(`0,`1@)">
      <summary>
            Finds a key in the dictionary. If the dictionary already contains
            a key equal to the passed key, then the existing value is returned via value. If the dictionary
            doesn't contain that key, then value is associated with that key.
            </summary>
      <remarks>
        <para> between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
        <para>This method takes time O(log N), where N is the number of keys in the dictionary. If a value is added, It is more efficient than
            calling TryGetValue followed by Add, because the dictionary is not searched twice.</para>
      </remarks>
      <param name="key">The new key. </param>
      <param name="value">The new value to associated with that key, if the key isn't present. If the key was present, 
            returns the exist value associated with that key.</param>
      <returns>True if key was already present, false if key wasn't present (and a new value was added).</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Add(`0,`1)">
      <summary>
            Adds a new key and value to the dictionary. If the dictionary already contains
            a key equal to the passed key, then an ArgumentException is thrown
            </summary>
      <remarks>
        <para>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
        <para>Adding an key and value takes time O(log N), where N is the number of keys in the dictionary.</para>
      </remarks>
      <param name="key">The new key. "null" is a valid key value.</param>
      <param name="value">The new value to associated with that key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Replace(`0,`1)">
      <summary>
            Changes the value associated with a given key. If the dictionary does not contain
            a key equal to the passed key, then an ArgumentException is thrown.
            </summary>
      <remarks>
        <p>Unlike adding or removing an element, changing the value associated with a key
            can be performed while an enumeration (foreach) on the the dictionary is in progress.</p>
        <p>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</p>
        <p>Replace takes time O(log N), where N is the number of entries in the dictionary.</p>
      </remarks>
      <param name="key">The new key. </param>
      <param name="value">The new value to associated with that key.</param>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">key is not present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd,
            then the value is updated with the value from <paramref name="keysAndValues&gt;" /> (no exception is thrown).
            Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this
            method can be used to merge one dictionary into another.
            </summary>
      <remarks>AddMany takes time O(M log (N+M)), where M is the size of <paramref name="keysAndValues&gt;" />, and N is the size of
            this dictionary.</remarks>
      <param name="keysAndValues">A collection of keys and values whose contents are added to the current dictionary.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove
            is removed from the dictionary. Keys that are not present are ignored.
            </summary>
      <remarks>RemoveMany takes time O(M log N), where M is the size of keyCollectionToRemove, and N is this
            size of this collection.</remarks>
      <returns>The number of keys removed from the dictionary.</returns>
      <param name="keyCollectionToRemove">A collection of keys to remove from the dictionary.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. The dictionary
            is not changed.
            </summary>
      <remarks>Searching the dictionary for a key takes time O(log N), where N is the number of keys in the dictionary.</remarks>
      <param name="key">The key to search for.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter.
            </summary>
      <remarks>TryGetValue takes time O(log N), where N is the number of entries in the dictionary.</remarks>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a KeyValuePair&lt;TKey,TValue&gt;.
            The entries are enumerated in the sorted order of the keys.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the elements of the dictionary, which uses this method implicitly.</p>
        <p>If an element is added to or deleted from the dictionary while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the entries in the dictionary takes time O(N log N), where N is the number
            of entries in the dictionary.</p>
      </remarks>
      <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.NewPair(`0,`1)">
      <summary>
            Helper function to create a new KeyValuePair struct.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.NewPair(`0)">
      <summary>
            Helper function to create a new KeyValuePair struct with a default value.
            </summary>
      <param name="key">The key.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.NonCloneableType(System.Type)">
      <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
      <param name="t">Type to test.</param>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.Item(`0)">
      <summary>
            Gets or sets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then an ArgumentException is thrown. When setting
            a value, the value replaces any existing value in the dictionary.
            </summary>
      <remarks>The indexer takes time O(log N), where N is the number of entries in the dictionary.</remarks>
      <value>The value associated with the key</value>
      <exception cref="T:System.ArgumentException">A value is being retrieved, and the key is not present in the dictionary.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.Count">
      <summary>
            Returns the number of keys in the dictionary.
            </summary>
      <remarks>The size of the dictionary is returned in constant time..</remarks>
      <value>The number of keys in the dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.OrderedMultiDictionary`2">
      <summary>
        <para>The OrderedMultiDictionary class that associates values with a key. Unlike an OrderedDictionary,
             each key can have multiple values associated with it. When indexing an OrderedMultidictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
        <para>All of the key are stored in sorted order. Also, the values associated with a given key 
             are kept in sorted order as well.</para>
        <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
      </summary>
      <typeparam name="TKey">The type of the keys.</typeparam>
      <typeparam name="TValue">The of values associated with the keys.</typeparam>
      <seealso cref="T:Magnum.Collections.MultiDictionary`2" />
      <seealso cref="T:Magnum.Collections.OrderedDictionary`2" />
    </member>
    <member name="T:Magnum.Collections.OrderedMultiDictionary`2.View">
      <summary>
             The OrderedMultiDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered multi-dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedMultiDictionary. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.View.Clear">
      <summary>
            Removes all the keys and values within this view from the underlying OrderedMultiDictionary.
            </summary>
      <example>The following removes all the keys that start with "A" from an OrderedMultiDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.View.Reversed">
      <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.View.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.View.Count">
      <summary>
            Number of keys in this view.
            </summary>
      <value>Number of keys that lie within the bounds the view.</value>
    </member>
    <member name="T:Magnum.Collections.OrderedMultiDictionary`2.KeyValuePairsCollection">
      <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.KeyRange(`0)">
      <summary>
            Get a RangeTester that maps to the range of all items with the 
            given key.
            </summary>
      <param name="key">Key in the given range.</param>
      <returns>A RangeTester delegate that selects the range of items with that range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.DoubleBoundedKeyRangeTester(`0,System.Boolean,`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <param name="last">The upper bound.</param>
      <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for a key in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.LowerBoundedKeyRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for a key in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.UpperBoundedKeyRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
      <param name="last">The upper bound.</param>
      <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for a key in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean)">
      <summary>
            Create a new OrderedMultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0},System.Comparison{`1})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
      <param name="valueComparison">A delegate to a method that will be used to compare values.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}},Magnum.Collections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Create a new OrderedMultiDictionary. Used internally for cloning.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyCount">Number of keys.</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
      <param name="comparer">Comparer of key-value pairs.</param>
      <param name="tree">The red-black tree used to store the data.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Add(`0,`1)">
      <summary>
        <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to <paramref name="value" /> associated with it, then that value is replaced with <paramref name="value" />,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="value">The value to associated with <paramref name="key" />.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Remove(`0,`1)">
      <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove a value from.</param>
      <param name="value">The value to remove.</param>
      <returns>True if <paramref name="value" /> was associated with <paramref name="key" /> (and was
            therefore removed). False if <paramref name="value" /> was not associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Remove(`0)">
      <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Contains(`0,`1)">
      <summary>
            Checks to see if <paramref name="value" /> is associated with <paramref name="key" />
            in the dictionary.
            </summary>
      <param name="key">The key to check.</param>
      <param name="value">The value to check.</param>
      <returns>True if <paramref name="value" /> is associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.ContainsKey(`0)">
      <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
      <param name="key">The key to check.</param>
      <returns>True if <paramref name="key" /> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EqualValues(`1,`1)">
      <summary>
            Determine if two values are equal.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
      <param name="key">The key to search for.</param>
      <param name="values">Returns all values associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EnumerateKeys">
      <summary>
            Enumerate all of the keys in the dictionary.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; of all of the keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.CountValues(`0)">
      <summary>
            Gets the number of values associated with a given key.
            </summary>
      <param name="key">The key to count values of.</param>
      <returns>The number of values associated with <paramref name="key" />. If <paramref name="key" />
            is not present in the dictionary, zero is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. 
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EnumerateKeys(Magnum.Collections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}}.RangeTester,System.Boolean)">
      <summary>
            A private helper method that returns an enumerable that
            enumerates all the keys in a range.
            </summary>
      <param name="rangeTester">Defines the range to enumerate.</param>
      <param name="reversed">Should the keys be enumerated in reverse order?</param>
      <returns>An IEnumerable&lt;TKey&gt; that enumerates the keys in the given range.
            in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EnumerateValuesForKey(`0)">
      <summary>
            A private helper method for the indexer to return an enumerable that
            enumerates all the values for a key. This is separate method because indexers
            can't use the yield return construct.
            </summary>
      <param name="key">
      </param>
      <returns>An IEnumerable&lt;TValue&gt; that can be used to enumerate all the
            values associated with <paramref name="key" />. If <paramref name="key" /> is not present,
            an enumerable that enumerates no items is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.NonCloneableType(System.Type)">
      <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
      <param name="t">Type to test.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
        <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
        <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
        <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
        <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.NewPair(`0,`1)">
      <summary>
            Helper function to create a new KeyValuePair struct.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.KeyComparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.ValueComparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TValue (Comparer&lt;TValue&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.Count">
      <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
      <value>The number of key-value pairs in the dictionary.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedSet`1">
      <summary>
             OrderedSet&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order, and duplicate items are not allowed. Each item has
             an index in the set: the smallest item has index 0, the next smallest item has index 1,
             and so forth.
             </summary>
      <remarks>
        <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedSet is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
        <p>
          <see cref="T:Magnum.Collections.Set`1" /> is similar, but uses hashing instead of comparison, and does not maintain
             the items in sorted order.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.Set`1" />
    </member>
    <member name="T:Magnum.Collections.OrderedSet`1.ListView">
      <summary>
            The nested class that provides a read-only list view
            of all or part of the collection.
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedSet`1.View">
      <summary>
             The OrderedSet&lt;T&gt;.View class is used to look at a subset of the Items
             inside an ordered set. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying set changes, the view changes in sync. If a change is made
             to the view, the underlying set changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedSet. For example:</p>
        <code>
             foreach(T item in set.Range(from, to)) {
                // process item
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.GetEnumerator">
      <summary>
            Enumerate all the items in this view.
            </summary>
      <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.Clear">
      <summary>
            Removes all the items within this view from the underlying set.
            </summary>
      <example>The following removes all the items that start with "A" from an OrderedSet.
            <code>
            set.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.AsList">
      <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.Reversed">
      <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.GetFirst">
      <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The first item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.GetLast">
      <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The last item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.View.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.View.Count">
      <summary>
            Number of items in this view.
            </summary>
      <value>Number of items that lie within the bounds the view.</value>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor">
      <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set. The set is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
      <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            The set is initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0},Magnum.Collections.RedBlackTree{`0})">
      <summary>
            Creates a new OrderedSet given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
      <param name="comparer">Comparer for the set.</param>
      <param name="tree">Data for the set.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Clone">
      <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
      <returns>The cloned set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.CloneContents">
      <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the set takes time O(N log N), where N is the number of items in the set.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the set takes time O(N log N), where N is the number
            of items in the set.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the OrderedSet.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Contains(`0)">
      <summary>
            Determines if this set contains an item equal to <paramref name="item" />. The set
            is not changed.
            </summary>
      <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.TryGetItem(`0,`0@)">
      <summary>
        <para>Determines if this set contains an item equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
        <para>If the set does contain an item equal to <paramref name="item" />, then the item from the set is returned.</para>
      </summary>
      <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
      <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            OrderedSet&lt;string&gt; set = new OrderedSet&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code></example>
      <param name="item">The item to search for.</param>
      <param name="foundItem">Returns the item from the set that was equal to <paramref name="item" />.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the item in the sorted set, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Add(`0)">
      <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item" />, that item is replaced with <paramref name="item" />.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding an item takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to add to the set.</param>
      <returns>True if the set already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection" />, that item will be replaced.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the set.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Remove(`0)">
      <summary>
            Searches the set for an item equal to <paramref name="item" />, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing an item from the set takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Clear">
      <summary>
            Removes all items from the set.
            </summary>
      <remarks>Clearing the sets takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the set. Items
            not present in the set are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the set.</param>
      <returns>The number of items removed from the set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.GetFirst">
      <summary>
            Returns the first item in the set: the item
            that would appear first if the set was enumerated. This is also
            the smallest item in the set.
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The first item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.GetLast">
      <summary>
            Returns the lastl item in the set: the item
            that would appear last if the set was enumerated. This is also the
            largest item in the set.
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The lastl item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RemoveFirst">
      <summary>
            Removes the first item in the set. This is also the smallest item in the set.
            </summary>
      <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The item that was removed, which was the smallest item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RemoveLast">
      <summary>
            Removes the last item in the set. This is also the largest item in the set.
            </summary>
      <remarks>RemoveLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The item that was removed, which was the largest item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.CheckEmpty">
      <summary>
            If the collection is empty, throw an invalid operation exception.
            </summary>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsSupersetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks></summary>
      <param name="otherSet">OrderedSet to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsProperSupersetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherSet" />.</remarks>
      <param name="otherSet">OrderedSet to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsSubsetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsProperSubsetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsEqualTo(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet" /> if they contain the same items.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
      <param name="otherSet">Set to compare to</param>
      <returns>True if this set is equal to <paramref name="otherSet" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.UnionWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsDisjointFrom(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to check disjointness with.</param>
      <returns>True if the two sets are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Union(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <returns>The union of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IntersectionWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Intersection(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <returns>The intersection of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.DifferenceWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Difference(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <returns>The difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.SymmetricDifferenceWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.SymmetricDifference(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <returns>The symmetric difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.CheckConsistentComparison(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Check that this set and another set were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherSet">Other set to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherSet and this set don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.AsList">
      <summary>
            Get a read-only list view of the items in this ordered set. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this OrderedSet.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the items in the set in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Reversed()) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedSet.View of items in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than <paramref name="to" />, the returned collection is empty. </p>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeTo(to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this set. 
            </summary>
      <value>If the set was created using a comparer, that comparer is returned. If the set was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.Count">
      <summary>
            Returns the number of items in the set.
            </summary>
      <remarks>The size of the set is returned in constant time.</remarks>
      <value>The number of items in the set.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.Pair`2">
      <summary>
            Stores a pair of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Pair`2.firstComparer">
      <summary>
            Comparers for the first and second type that are used to compare
            values.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Pair`2.First">
      <summary>
            The first element of the pair.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Pair`2.Second">
      <summary>
            The second element of the pair.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Pair`2.#ctor(`0,`1)">
      <summary>
            Creates a new pair with given first and second elements.
            </summary>
      <param name="first">The first element of the pair.</param>
      <param name="second">The second element of the pair.</param>
    </member>
    <member name="M:Magnum.Collections.Pair`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Creates a new pair using elements from a KeyValuePair structure. The
            First element gets the Key, and the Second elements gets the Value.
            </summary>
      <param name="keyAndValue">The KeyValuePair to initialize the Pair with .</param>
    </member>
    <member name="M:Magnum.Collections.Pair`2.CompareTo(Magnum.Collections.Pair{`0,`1})">
      <summary>
        <para> Compares this pair to another pair of the some type. The pairs are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst and TSecond. The pairs
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements.</para>
        <para>If either TFirst or TSecond does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the pairs cannot be compared.</para>
      </summary>
      <param name="other">The pair to compare to.</param>
      <returns>An integer indicating how this pair compares to <paramref name="other" />. Less
            than zero indicates this pair is less than <paramref name="other" />. Zero indicate this pair is
            equals to <paramref name="other" />. Greater than zero indicates this pair is greater than
            <paramref name="other" />.</returns>
      <exception cref="T:System.NotSupportedException">Either FirstSecond or TSecond is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.Pair`2.Equals(System.Object)">
      <summary>
            Determines if this pair is equal to another object. The pair is equal to another object 
            if that object is a Pair, both element types are the same, and the first and second elements
            both compare equal using object.Equals.
            </summary>
      <param name="obj">Object to compare for equality.</param>
      <returns>True if the objects are equal. False if the objects are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.Equals(Magnum.Collections.Pair{`0,`1})">
      <summary>
            Determines if this pair is equal to another pair. The pair is equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="other">Pair to compare with for equality.</param>
      <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.GetHashCode">
      <summary>
            Returns a hash code for the pair, suitable for use in a hash-table or other hashed collection.
            Two pairs that compare equal (using Equals) will have the same hash code. The hash code for
            the pair is derived by combining the hash codes for each of the two elements of the pair.
            </summary>
      <returns>The hash code.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.ToString">
      <summary>
            Returns a string representation of the pair. The string representation of the pair is
            of the form:
            <c>First: {0}, Second: {1}</c>
            where {0} is the result of First.ToString(), and {1} is the result of Second.ToString() (or
            "null" if they are null.)
            </summary>
      <returns> The string representation of the pair.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.ToKeyValuePair">
      <summary>
            Converts this Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
      <returns>The KeyValuePair created from this Pair.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Equality(Magnum.Collections.Pair{`0,`1},Magnum.Collections.Pair{`0,`1})">
      <summary>
            Determines if two pairs are equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First pair to compare.</param>
      <param name="pair2">Second pair to compare.</param>
      <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Inequality(Magnum.Collections.Pair{`0,`1},Magnum.Collections.Pair{`0,`1})">
      <summary>
            Determines if two pairs are not equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First pair to compare.</param>
      <param name="pair2">Second pair to compare.</param>
      <returns>True if the pairs are not equal. False if the pairs are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Explicit(Magnum.Collections.Pair{`0,`1})~System.Collections.Generic.KeyValuePair{`0,`1}">
      <summary>
            Converts a Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
      <param name="pair">Pair to convert.</param>
      <returns>The KeyValuePair created from <paramref name="pair" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Explicit(System.Collections.Generic.KeyValuePair{`0,`1})~Magnum.Collections.Pair{`0,`1}">
      <summary>
            Converts a KeyValuePair structure into a Pair. The
            First element gets the Key, and the Second element gets the Value.
            </summary>
      <param name="keyAndValue">The KeyValuePair to convert.</param>
      <returns>The Pair created by converted the KeyValuePair into a Pair.</returns>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2">
      <summary>
            ReadOnlyDictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
      <remarks>
        <para>To use ReadOnlyDictionaryBase as a base class, the derived class must override
            Count, TryGetValue, GetEnumerator. </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2.DictionaryEnumeratorWrapper">
      <summary>
            A class that wraps a IDictionaryEnumerator around an IEnumerator that
            enumerates KeyValuePairs. This is useful in implementing IDictionary, because
            IEnumerator can be implemented with an iterator, but IDictionaryEnumerator cannot.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
      <exception cref="T:System.NotSupportedException">Always thrown.</exception>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter. This method must be overridden 
            in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyDictionaryBase`2.Item(`0)">
      <summary>
            The indexer of the dictionary. The set accessor throws an NotSupportedException
            stating the dictionary is read-only.
            </summary>
      <remarks>The get accessor is implemented by calling TryGetValue.</remarks>
      <param name="key">Key to find in the dictionary.</param>
      <returns>The value associated with the key.</returns>
      <exception cref="T:System.NotSupportedException">Always thrown from the set accessor, indicating
            that the dictionary is read only.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found.</exception>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyDictionaryBase`2.Keys">
      <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
      <value>A read-only collection of the keys in this dictionary.</value>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyDictionaryBase`2.Values">
      <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
      <value>A read-only collection of the values in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2">
      <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface. The resulting collection
            is read-only -- items cannot be added or removed.
            </summary>
      <remarks>
        <para>To use ReadOnlyMultiDictionaryBase as a base class, the derived class must override
            Count, Contains(TKey,TValue), EnumerateKeys, and TryEnumerateValuesForKey . </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection">
      <summary>
            A private class that provides the ICollection&lt;TValue&gt; for a particular key. This is the collection
            that is returned from the indexer. The collections is read-write, live, and can be used to add, remove,
            etc. values from the multi-dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.GetEnumerator">
      <summary>
            Enumerate all the values associated with key.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that enumerates all the values associated with key.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.NoValues">
      <summary>
            A simple function that returns an IEnumerator&lt;TValue&gt; that
            doesn't yield any values. A helper.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that yields no values.</returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.Count">
      <summary>
            Get the number of values associated with the key.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.EnumerableValuesCollection">
      <summary>
            A private class that implements ICollection&lt;IEnumerable&lt;TValue&gt;&gt; and ICollection for the
            Values collection on IDictionary. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.KeyValuePairsCollection">
      <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
      <param name="pair">A key and collection of values to search for.</param>
      <returns>True if the dictionary has associated all of the values in <paramref name="pair" />.Value with <paramref name="pair" />.Key.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.GetEnumerator">
      <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
      <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Contains(`0,`1)">
      <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key" /> and 
            <paramref name="value" />. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">The value to search for.</param>
      <returns>True if the dictionary has associated <paramref name="value" /> with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values" />. If the key does not exist, false is returned.
            </summary>
      <param name="key">The key to get values for.</param>
      <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
      <returns>True if the key exists and has values associated with it. False otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.EqualValues(`1,`1)">
      <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.CountValues(`0)">
      <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
      <param name="key">The key to count values for.</param>
      <returns>The number of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Values">
      <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
      <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Item(`0)">
      <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key" />.
            If the key is not present in the dictionary, an ICollection with no
            values is returned. The returned ICollection is read-only.
            </summary>
      <param name="key">The key to get the values associated with.</param>
      <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key" />.</value>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Count">
      <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Keys">
      <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
      <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.DuplicatePolicy">
      <summary>
            Describes what to do if a key is already in the tree when doing an
            insertion.
            </summary>
    </member>
    <member name="T:Magnum.Collections.RedBlackTree`1">
      <summary>
             The base implementation for various collections classes that use Red-Black trees
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package.
             </summary>
      <remarks>
             The Red-Black tree manages items of type T, and uses a IComparer&lt;T&gt; that
             compares items to sort the tree. Multiple items can compare equal and be stored
             in the tree. Insert, Delete, and Find operations are provided in their full generality;
             all operations allow dealing with either the first or last of items that compare equal. 
            </remarks>
    </member>
    <member name="T:Magnum.Collections.RedBlackTree`1.RangeTester">
      <summary>
            A delegate that tests if an item is within a custom range. The range must be a contiguous
            range of items with the ordering of this tree. The range test function must test
            if an item is before, withing, or after the range.
            </summary>
      <param name="item">Item to test against the range.</param>
      <returns>Returns negative if item is before the range, zero if item is withing the range,
            and positive if item is after the range.</returns>
    </member>
    <member name="T:Magnum.Collections.RedBlackTree`1.Node">
      <summary>
            The class that is each node in the red-black tree.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Node.IncrementCount">
      <summary>
            Add one to the Count.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Node.DecrementCount">
      <summary>
            Subtract one from the Count. The current
            Count must be non-zero.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Node.Clone">
      <summary>
            Clones a node and all its descendants.
            </summary>
      <returns>The cloned node.</returns>
    </member>
    <member name="P:Magnum.Collections.RedBlackTree`1.Node.IsRed">
      <summary>
            Is this a red node?
            </summary>
    </member>
    <member name="P:Magnum.Collections.RedBlackTree`1.Node.Count">
      <summary>
            Get or set the Count field -- a 31-bit field
            that holds the number of nodes at or below this
            level.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Initialize a red-black tree, using the given interface instance to compare elements. Only
            Compare is used on the IComparer interface.
            </summary>
      <param name="comparer">The IComparer&lt;T&gt; used to sort keys.</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.GetEnumerator">
      <summary>
            Enumerate all the items in-order
            </summary>
      <returns>An enumerator for all the items, in order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.BoundedRangeTester(System.Boolean,`0,System.Boolean,`0)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="useFirst">If true, bound the range on the bottom by first.</param>
      <param name="first">If useFirst is true, the inclusive lower bound.</param>
      <param name="useLast">If true, bound the range on the top by last.</param>
      <param name="last">If useLast is true, the exclusive upper bound.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.DoubleBoundedRangeTester(`0,System.Boolean,`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <param name="last">The upper bound.</param>
      <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.LowerBoundedRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.UpperBoundedRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
      <param name="last">The upper bound.</param>
      <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EqualRangeTester(`0)">
      <summary>
            Gets a range tester that defines a range by all items equal to an item.
            </summary>
      <param name="equalTo">The item that is contained in the range.</param>
      <returns>A RangeTester delegate that tests for an item equal to <paramref name="equalTo" />.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EntireRangeTester(`0)">
      <summary>
            A range tester that defines a range that is the entire tree.
            </summary>
      <param name="item">Item to test.</param>
      <returns>Always returns 0.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRange(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Enumerate the items in a custom range in the tree. The range is determined by 
            a RangeTest delegate.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRangeReversed(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Enumerate the items in a custom range in the tree, in reversed order. The range is determined by 
            a RangeTest delegate.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in reversed order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.DeleteItemFromRange(Magnum.Collections.RedBlackTree{`0}.RangeTester,System.Boolean,`0@)">
      <summary>
            Deletes either the first or last item from a range, as identified by a RangeTester
            delegate. If the range is empty, returns false.
            </summary>
      <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
      <param name="rangeTester">Range to delete from.</param>
      <param name="deleteFirst">If true, delete the first item from the range, else the last.</param>
      <param name="item">Returns the item that was deleted, if true returned.</param>
      <returns>True if an element was deleted, false if the range is empty.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.DeleteRange(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Delete all the items in a range, identified by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range to delete.</param>
      <returns>The number of items deleted.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.CountRange(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Count the items in a custom range in the tree. The range is determined by 
            a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <returns>The number of items in the range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.FirstItemInRange(Magnum.Collections.RedBlackTree{`0}.RangeTester,`0@)">
      <summary>
            Find the first item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="item">Returns the item found, if true was returned.</param>
      <returns>Index of first item in range if range is non-empty, -1 otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.LastItemInRange(Magnum.Collections.RedBlackTree{`0}.RangeTester,`0@)">
      <summary>
            Find the last item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="item">Returns the item found, if true was returned.</param>
      <returns>Index of the item if range is non-empty, -1 otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRangeInOrder(Magnum.Collections.RedBlackTree{`0}.RangeTester,Magnum.Collections.RedBlackTree{`0}.Node)">
      <summary>
            Enumerate all the items in a custom range, under and including node, in-order.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <param name="node">Node to begin enumeration. May be null.</param>
      <returns>An enumerable of the items.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRangeInReversedOrder(Magnum.Collections.RedBlackTree{`0}.RangeTester,Magnum.Collections.RedBlackTree{`0}.Node)">
      <summary>
            Enumerate all the items in a custom range, under and including node, in reversed order.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <param name="node">Node to begin enumeration. May be null.</param>
      <returns>An enumerable of the items, in reversed oreder.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.CountRangeUnderNode(Magnum.Collections.RedBlackTree{`0}.RangeTester,Magnum.Collections.RedBlackTree{`0}.Node,System.Boolean,System.Boolean)">
      <summary>
            Count all the items in a custom range, under and including node.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="node">Node to begin enumeration. May be null.</param>
      <param name="belowRangeTop">This node and all under it are either in the range or below it.</param>
      <param name="aboveRangeBottom">This node and all under it are either in the range or above it.</param>
      <returns>The number of items in the range, under and include node.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Clone">
      <summary>
            Clone the tree, returning a new tree containing the same items. Should
            take O(N) take.
            </summary>
      <returns>Clone version of this tree.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Find(`0,System.Boolean,System.Boolean,`0@)">
      <summary>
            Finds the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. Optionally replaces the item
            with the one searched for.
            </summary>
      <param name="key">Key to search for.</param>
      <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
      <param name="replace">If true, replaces the item with key (if function returns true)</param>
      <param name="item">Returns the found item, before replacing (if function returns true).</param>
      <returns>True if the key was found.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.FindIndex(`0,System.Boolean)">
      <summary>
            Finds the index of the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. 
            </summary>
      <param name="key">Key to search for.</param>
      <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
      <returns>Index of the item found if the key was found, -1 if not found.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.GetItemByIndex(System.Int32)">
      <summary>
            Find the item at a particular index in the tree.
            </summary>
      <param name="index">The zero-based index of the item. Must be &gt;= 0 and &lt; Count.</param>
      <returns>The item at the particular index.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Insert(`0,Magnum.Collections.DuplicatePolicy,`0@)">
      <summary>
            Insert a new node into the tree, maintaining the red-black invariants.
            </summary>
      <remarks>Algorithm from Sedgewick, "Algorithms".</remarks>
      <param name="item">The new item to insert</param>
      <param name="dupPolicy">What to do if equal item is already present.</param>
      <param name="previous">If false, returned, the previous item.</param>
      <returns>false if duplicate exists, otherwise true.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Delete(`0,System.Boolean,`0@)">
      <summary>
            Deletes a key from the tree. If multiple elements are equal to key, 
            deletes the first or last. If no element is equal to the key, 
            returns false.
            </summary>
      <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
      <param name="key">Key to delete.</param>
      <param name="deleteFirst">Which item to delete if multiple are equal to key. True to delete the first, false to delete last.</param>
      <param name="item">Returns the item that was deleted, if true returned.</param>
      <returns>True if an element was deleted, false if no element had 
            specified key.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Print">
      <summary>
            Prints out the tree.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Validate">
      <summary>
            Validates that the tree is correctly sorted, and meets the red-black tree 
            axioms.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.GetNodeStack">
      <summary>
            Create an array of Nodes big enough for any path from top 
            to bottom. This is cached, and reused from call-to-call, so only one
            can be around at a time per tree.
            </summary>
      <returns>The node stack.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.InsertSplit(Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,System.Boolean@)">
      <summary>
            Split a node with two red children (a 4-node in the 2-3-4 tree formalism), as
            part of an insert operation.
            </summary>
      <param name="ggparent">great grand-parent of "node", can be null near root</param>
      <param name="gparent">grand-parent of "node", can be null near root</param>
      <param name="parent">parent of "node", can be null near root</param>
      <param name="node">Node to split, can't be null</param>
      <param name="rotated">Indicates that rotation(s) occurred in the tree.</param>
      <returns>Node to continue searching from.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Rotate(Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node)">
      <summary>
            Performs a rotation involving the node, it's child and grandchild. The counts of 
            childs and grand-child are set the correct values from their children; this is important
            if they have been adjusted on the way down the try as part of an insert/delete.
            </summary>
      <param name="node">Top node of the rotation. Can be null if child==root.</param>
      <param name="child">One child of "node". Not null.</param>
      <param name="gchild">One child of "child". Not null.</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.PrintSubTree(Magnum.Collections.RedBlackTree{`0}.Node,System.String,System.String)">
      <summary>
            Prints a sub-tree.
            </summary>
      <param name="node">Node to print from</param>
      <param name="prefixNode">Prefix for the node</param>
      <param name="prefixChildren">Prefix for the node's children</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.ValidateSubTree(Magnum.Collections.RedBlackTree{`0}.Node,System.Int32@)">
      <summary>
            Validates a sub-tree and returns the count and black height.
            </summary>
      <param name="node">Sub-tree to validate. May be null.</param>
      <param name="blackHeight">Returns the black height of the tree.</param>
      <returns>Returns the number of nodes in the sub-tree. 0 if node is null.</returns>
    </member>
    <member name="P:Magnum.Collections.RedBlackTree`1.ElementCount">
      <summary>
            Returns the number of elements in the tree.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Set`1">
      <summary>
             Set&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a haphazard, unpredictable order, and duplicate items are not allowed.
             </summary>
      <remarks>
        <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
        <p>Set is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the Set.</p>
        <p>
          <see cref="T:Magnum.Collections.OrderedSet`1" /> is similar, but uses comparison instead of hashing, and does maintains
             the items in sorted order.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.OrderedSet`1" />
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor">
      <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set.
            </summary>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
      <param name="collection">A collection with items to be placed into the Set.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the Set.</param>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Magnum.Collections.Hash{`0})">
      <summary>
            Creates a new Set given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
      <param name="equalityComparer">EqualityComparer for the set.</param>
      <param name="hash">Data for the set.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.Clone">
      <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
      <returns>The cloned set.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.CloneContents">
      <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the set takes time O(N), where N is the number of items in the set.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumerating all the items in the set takes time O(N), where N is the number
            of items in the set.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the Set.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.Contains(`0)">
      <summary>
            Determines if this set contains an item equal to <paramref name="item" />. The set
            is not changed.
            </summary>
      <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.TryGetItem(`0,`0@)">
      <summary>
        <para>Determines if this set contains an item equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
        <para>If the set does contain an item equal to <paramref name="item" />, then the item from the set is returned.</para>
      </summary>
      <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
      <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            Set&lt;string&gt; set = new Set&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code></example>
      <param name="item">The item to search for.</param>
      <param name="foundItem">Returns the item from the set that was equal to <paramref name="item" />.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.Add(`0)">
      <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item" />, that item is replaced with <paramref name="item" />.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the set.</para>
      </remarks>
      <param name="item">The item to add to the set.</param>
      <returns>True if the set already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection" />, that item will be replaced.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the set.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.Remove(`0)">
      <summary>
            Searches the set for an item equal to <paramref name="item" />, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing an item from the set takes approximately constant time, regardless of the size of the set.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.Clear">
      <summary>
            Removes all items from the set.
            </summary>
      <remarks>Clearing the set takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.Set`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the set. 
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the set.</param>
      <returns>The number of items removed from the set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsSupersetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M), where M is the size of the 
            <paramref name="otherSet" />.</remarks></summary>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsProperSupersetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(M), where M is the size of
            <paramref name="otherSet" />.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsSubsetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsProperSubsetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsEqualTo(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet" /> if they contain the same items.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
      <param name="otherSet">Set to compare to</param>
      <returns>True if this set is equal to <paramref name="otherSet" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsDisjointFrom(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to check disjointness with.</param>
      <returns>True if the two sets are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.UnionWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.Union(Magnum.Collections.Set{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            one set, and N is the size of the other set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <returns>The union of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IntersectionWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.Intersection(Magnum.Collections.Set{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <returns>The intersection of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.DifferenceWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.Difference(Magnum.Collections.Set{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <returns>The difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.SymmetricDifferenceWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.SymmetricDifference(Magnum.Collections.Set{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <returns>The symmetric difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.CheckConsistentComparison(Magnum.Collections.Set{`0})">
      <summary>
            Check that this set and another set were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherSet">Other set to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherSet and this set don't use the same method for comparing items.</exception>
    </member>
    <member name="P:Magnum.Collections.Set`1.Comparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this set. 
            </summary>
      <value>If the set was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.Set`1.Count">
      <summary>
            Returns the number of items in the set.
            </summary>
      <remarks>The size of the set is returned in constant time.</remarks>
      <value>The number of items in the set.</value>
    </member>
    <member name="T:Magnum.Collections.Strings">
      <summary>
            A holder class for localizable strings that are used. Currently, these are not loaded from resources, but 
            just coded into this class. To make this library localizable, simply change this class to load the
            given strings from resources.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Triple`3">
      <summary>
            Stores a triple of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.firstComparer">
      <summary>
            Comparers for the first and second type that are used to compare
            values.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.First">
      <summary>
            The first element of the triple.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.Second">
      <summary>
            The second element of the triple.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.Third">
      <summary>
            The thrid element of the triple.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Triple`3.#ctor(`0,`1,`2)">
      <summary>
            Creates a new triple with given elements.
            </summary>
      <param name="first">The first element of the triple.</param>
      <param name="second">The second element of the triple.</param>
      <param name="third">The third element of the triple.</param>
    </member>
    <member name="M:Magnum.Collections.Triple`3.CompareTo(Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
        <para> Compares this triple to another triple of the some type. The triples are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst, TSecond, and TThird. The triples
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements. If their second elements are also equal, then they
            are compared by their third elements.</para>
        <para>If TFirst, TSecond, or TThird does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the triples cannot be compared.</para>
      </summary>
      <param name="other">The triple to compare to.</param>
      <returns>An integer indicating how this triple compares to <paramref name="other" />. Less
            than zero indicates this triple is less than <paramref name="other" />. Zero indicate this triple is
            equals to <paramref name="other" />. Greater than zero indicates this triple is greater than
            <paramref name="other" />.</returns>
      <exception cref="T:System.NotSupportedException">Either FirstSecond, TSecond, or TThird is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.Triple`3.Equals(System.Object)">
      <summary>
            Determines if this triple is equal to another object. The triple is equal to another object 
            if that object is a Triple, all element types are the same, and the all three elements
            compare equal using object.Equals.
            </summary>
      <param name="obj">Object to compare for equality.</param>
      <returns>True if the objects are equal. False if the objects are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.Equals(Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
            Determines if this triple is equal to another triple. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="other">Triple to compare with for equality.</param>
      <returns>True if the triples are equal. False if the triples are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.GetHashCode">
      <summary>
            Returns a hash code for the triple, suitable for use in a hash-table or other hashed collection.
            Two triples that compare equal (using Equals) will have the same hash code. The hash code for
            the triple is derived by combining the hash codes for each of the two elements of the triple.
            </summary>
      <returns>The hash code.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.ToString">
      <summary>
            Returns a string representation of the triple. The string representation of the triple is
            of the form:
            <c>First: {0}, Second: {1}, Third: {2}</c>
            where {0} is the result of First.ToString(), {1} is the result of Second.ToString(), and
            {2} is the result of Third.ToString() (or "null" if they are null.)
            </summary>
      <returns> The string representation of the triple.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.op_Equality(Magnum.Collections.Triple{`0,`1,`2},Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
            Determines if two triples are equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First triple to compare.</param>
      <param name="pair2">Second triple to compare.</param>
      <returns>True if the triples are equal. False if the triples are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.op_Inequality(Magnum.Collections.Triple{`0,`1,`2},Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
            Determines if two triples are not equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First triple to compare.</param>
      <param name="pair2">Second triple to compare.</param>
      <returns>True if the triples are not equal. False if the triples are equal.</returns>
    </member>
    <member name="T:Magnum.Collections.Util">
      <summary>
            A holder class for various internal utility functions that need to be shared.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Util.WrapEnumerable`1">
      <summary>
            Wrap an enumerable so that clients can't get to the underlying 
            implementation via a down-cast.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Util.WrapEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Create the wrapper around an enumerable.
            </summary>
      <param name="wrapped">IEnumerable to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Util.IsCloneableType(System.Type,System.Boolean@)">
      <summary>
            Determine if a type is cloneable: either a value type or implementing
            ICloneable.
            </summary>
      <param name="type">Type to check.</param>
      <param name="isValue">Returns if the type is a value type, and does not implement ICloneable.</param>
      <returns>True if the type is cloneable.</returns>
    </member>
    <member name="M:Magnum.Collections.Util.SimpleClassName(System.Type)">
      <summary>
            Returns the simple name of the class, for use in exception messages. 
            </summary>
      <returns>The simple name of this class.</returns>
    </member>
    <member name="M:Magnum.Collections.Util.CreateEnumerableWrapper``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Wrap an enumerable so that clients can't get to the underlying
            implementation via a down-case
            </summary>
      <param name="wrapped">Enumerable to wrap.</param>
      <returns>A wrapper around the enumerable.</returns>
    </member>
    <member name="M:Magnum.Collections.Util.GetHashCode``1(``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Gets the hash code for an object using a comparer. Correctly handles
            null.
            </summary>
      <param name="item">Item to get hash code for. Can be null.</param>
      <param name="equalityComparer">The comparer to use.</param>
      <returns>The hash code for the item.</returns>
    </member>
    <member name="T:Magnum.CommandLineParser.CommandLine">
      <summary>
            Tools for parsing the command line
            </summary>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.GetUnparsedCommandLine">
      <summary>
            Gets the command line from the Environment.CommandLine, removing the application name if present
            </summary>
      <returns>The complete, unparsed command line that was specified when the program was executed</returns>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.Parse">
      <summary>
            Parses the command line
            </summary>
      <returns>The command line elements that were found</returns>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.Parse(System.String)">
      <summary>
            Parses the command line
            </summary>
      <param name="commandLine">The command line to parse</param>
      <returns>The command line elements that were found</returns>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.Parse``1(System.String,System.Action{Magnum.CommandLineParser.ICommandLineElementParser{``0}})">
      <summary>
            Parses the command line and matches any specified patterns
            </summary>
      <typeparam name="T">The output type of the parser</typeparam>
      <param name="commandLine">The command line text</param>
      <param name="initializer">Used by the caller to add patterns and object generators</param>
      <returns>The elements that were found on the command line</returns>
    </member>
    <member name="T:Magnum.CommandLineParser.ICommandLineElementParser`1">
      <summary>
            Used to configure the command line element parser
            </summary>
      <typeparam name="TResult">The type of object returned as a result of the parse</typeparam>
    </member>
    <member name="M:Magnum.CommandLineParser.ICommandLineElementParser`1.Add(Magnum.Monads.Parser.Parser{System.Collections.Generic.IEnumerable{Magnum.CommandLineParser.ICommandLineElement},`0})">
      <summary>
            Adds a new pattern to the parser
            </summary>
      <param name="parser">The pattern to match and return the resulting object</param>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToAttributes.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
            Returns the first attribute of the specified type for the object specified
            </summary>
      <typeparam name="T">The type of attribute</typeparam>
      <param name="provider">An attribute provider, which can be a MethodInfo, PropertyInfo, Type, etc.</param>
      <returns>The attribute instance if found, or null</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToAttributes.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
            Determines if the target has the specified attribute
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="provider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToAttributes.ForAttributesOf``1(System.Reflection.ICustomAttributeProvider,System.Action{``0})">
      <summary>
            Calls the provided action for each instance of the specified attribute type for the object specified
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="provider">
      </param>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDateTime.FromNow(System.TimeSpan)">
      <summary>
            Gets the current DateTime and adjusts it by the specified TimeSpan
            </summary>
      <param name="span">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDateTime.ToUnixTimestamp(System.DateTime)">
      <summary>
            Gets a Unix Timestamp from a DateTime, converting local time to UTC if necessary.
            </summary>
      <param name="date">The date to convert</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
      <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="missingValue">The value to add if the key is not found</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
      <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="valueProvider">The function to return the value to add if the key is not found</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.StrongGet``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
      <summary>
            Converts an object to the strongly typed version of a dictionary
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDisposable.AutoDispose``1(``0)">
      <summary>
            Wraps an object that implements IDisposable in an enumeration to make it safe for use in LINQ expressions
            </summary>
      <typeparam name="T">The type of the object, which must implement IDisposable</typeparam>
      <param name="target">The target to wrap</param>
      <returns>An enumeration with a single entry equal to the target</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToEnumerable.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Enumerates a collection, calling the specified action for each entry in the collection
            </summary>
      <typeparam name="T">The type of the enumeration</typeparam>
      <param name="collection">The collection to enumerate</param>
      <param name="callback">The action to call for each entry in the collection</param>
      <returns>The collection that was enumerated</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToEnumerable.WhileTrue``1(System.Collections.IEnumerable,System.Func{``0,System.Boolean})">
      <summary>
            Enumerates a collection, calling the callback until false is returned
            </summary>
      <typeparam name="T">The type of item being enumerated</typeparam>
      <param name="collection">The collection to enumerate</param>
      <param name="callback">The callback to call for each element</param>
      <returns>True if all of the elements were enumerated, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToEventHandler.Raise``1(System.EventHandler{``0},System.Object,``0)">
      <summary>
            thanks, http://kohari.org/2009/02/07/eventhandler-extension-method/
            </summary>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.MemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Gets the name of the member specified
            </summary>
      <typeparam name="T">The type referenced</typeparam>
      <typeparam name="TMember">The type of the member referenced</typeparam>
      <param name="expression">The expression referencing the member</param>
      <returns>The name of the member referenced by the expression</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.MemberName``1(System.Linq.Expressions.Expression{System.Action{``0}})">
      <summary>
            Gets the name of the member specified
            </summary>
      <typeparam name="T">The type referenced</typeparam>
      <param name="expression">The expression referencing the member</param>
      <returns>The name of the member referenced by the expression</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.MemberName``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})">
      <summary>
            Gets the name of the member specified
            </summary>
      <typeparam name="T1">The type referenced</typeparam>
      <typeparam name="T2">The type of the member referenced</typeparam>
      <param name="expression">The expression referencing the member</param>
      <returns>The name of the member referenced by the expression</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.WrapActionWithArgument``1(System.Linq.Expressions.Expression{System.Action})">
      <summary>
            Wraps an action expression with no arguments inside an expression that takes an 
            argument of the specified type (the argument is ignored, but the original expression is
            invoked)
            </summary>
      <typeparam name="TArgument">The type of argument to accept in the wrapping expression</typeparam>
      <param name="expression">The expression to wrap</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements``1(System.Object)">
      <summary>
              Checks if an object implements the specified interface
            </summary>
      <typeparam name="T">The interface type</typeparam>
      <param name="obj">The object to check</param>
      <returns>True if the interface is implemented by the object, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements(System.Object,System.Type)">
      <summary>
              Checks if an object implements the specified interface
            </summary>
      <param name="obj">The object to check</param>
      <param name="interfaceType">The interface type (can be generic, either specific or open)</param>
      <returns>True if the interface is implemented by the object, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements``1(System.Type)">
      <summary>
              Checks if a type implements the specified interface
            </summary>
      <typeparam name="T">The interface type (can be generic, either specific or open)</typeparam>
      <param name="objectType">The type to check</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements(System.Type,System.Type)">
      <summary>
              Checks if a type implements the specified interface
            </summary>
      <param name="objectType">The type to check</param>
      <param name="interfaceType">The interface type (can be generic, either specific or open)</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.ImplementsGeneric(System.Type,System.Type)">
      <summary>
              Checks if a type implements an open generic at any level of the inheritance chain, including all
              base classes
            </summary>
      <param name="objectType">The type to check</param>
      <param name="interfaceType">The interface type (must be a generic type definition)</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.ImplementsGeneric(System.Type,System.Type,System.Type@)">
      <summary>
              Checks if a type implements an open generic at any level of the inheritance chain, including all
              base classes
            </summary>
      <param name="objectType">The type to check</param>
      <param name="interfaceType">The interface type (must be a generic type definition)</param>
      <param name="matchedType">The matching type that was found for the interface type</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToObject.ValueOrDefault``2(``0,System.Func{``0,``1},``1)">
      <summary>
            Returns the value of the instance member, or the default value if the instance is null
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="instance">
      </param>
      <param name="accessor">
      </param>
      <param name="defaultValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.IsNotEmpty(System.String)">
      <summary>
            Checks if a string is not null or empty
            </summary>
      <param name="value">A string instance</param>
      <returns>True if the string has a value</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.IsEmpty(System.String)">
      <summary>
            Check if a string is null or empty
            </summary>
      <param name="value">A string instance</param>
      <returns>True if the string is null or empty, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.IsNull(System.String)">
      <summary>
            Returns true if a string is null (the string can, however, be empty)
            </summary>
      <param name="value">A string value</param>
      <returns>True if the string value is null, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.FormatWith(System.String,System.Object[])">
      <summary>
            Uses the string as a template and applies the specified arguments
            </summary>
      <param name="format">The format string</param>
      <param name="args">The arguments to pass to the format provider</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.ToUtf8String(System.Byte[])">
      <summary>
            Returns the UTF-8 encoded string from the specified byte array
            </summary>
      <param name="data">The byte array</param>
      <returns>The UTF-8 string</returns>
    </member>
    <member name="T:Magnum.Graphing.GraphData">
      <summary>
            A provider of graph data can return vertices and edges
            </summary>
    </member>
    <member name="M:Magnum.Reflection.ExtensionsToGet.Get``2(Magnum.Reflection.GetProperty{``0,``1},``0)">
      <summary>
            Returns the value for the property, or the default for the property type if
            the actual property value is unreachable (due to a null reference in the property chain)
            </summary>
      <typeparam name="T">The object type referenced</typeparam>
      <typeparam name="TValue">The property type</typeparam>
      <param name="getValue">
      </param>
      <param name="obj">The object from which the value should be retrieved</param>
      <returns>The value of the property, or default(TValue) if it cannot be accessed</returns>
    </member>
    <member name="T:Magnum.Reflection.SafeProperty">
      <summary>
            Use to safely set a property on an object, including the expansion of any lists as necessary
            and creation of reference properties. May not be suitable to all situations, but works great
            for deserializing data into an empty object graph.
            </summary>
    </member>
    <member name="T:Magnum.Metrics.IMonitor">
      <summary>
            Standard interface supported by all monitors
            </summary>
    </member>
    <member name="P:Magnum.Metrics.IMonitor.OwnerType">
      <summary>
            The type that owns this monitor
            </summary>
    </member>
    <member name="P:Magnum.Metrics.IMonitor.Name">
      <summary>
            The name of the monitor
            </summary>
    </member>
    <member name="T:Magnum.Pipeline.InterceptionBinder">
      <summary>
            Inserts a segment into the pipeline as an inline filter
            </summary>
    </member>
    <member name="T:Magnum.Pipeline.ISubscriptionScope">
      <summary>
            Provides an interface for adding consumers and interceptors to the pipeline
            </summary>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Subscribe``1(Magnum.Pipeline.MessageConsumer{``0})">
      <summary>
            Subscribes the message consumer to the pipeline. Can accept any method that matches the delegate
            syntax, including anonymous/lambda methods
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="consumer">The method that will consume the message</param>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Subscribe``1(``0)">
      <summary>
            Subscribes an instance of a class to the pipeline. Consumer interfaces that are implemented by the 
            object will be wired up to the pipeline with the appropriate message type
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="consumer">
      </param>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Subscribe``1(System.Func{``0})">
      <summary>
            Subscribes a type to the pipeline. When a message is delivered to the pipeline, the getConsumer function
            is called to get an instance of the consumer to which the message is delivered.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="getConsumer">
      </param>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Intercept``1(System.Action{Magnum.Pipeline.IInterceptorConfigurator{``0}})">
      <summary>
            Registers an interceptor on the pipeline, allowing actions to be performed before and after messages
            are delivered on the pipeline.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="configureAction">The block containing the configuration calls for the interceptor</param>
    </member>
    <member name="T:Magnum.Pipeline.Roles.ISubscriberEvent">
      <summary>
            A marker interface to define the role of the message (nod to Udi)
            </summary>
    </member>
    <member name="T:Magnum.Pipeline.Pipe">
      <summary>
            A pipeline is used for the delivery of messages (which are really just objects of any type)
            </summary>
    </member>
    <member name="M:Magnum.Pipeline.Pipe.Send``1(``0)">
      <summary>
            Sends a message through the pipe
            </summary>
      <typeparam name="T">Captures the generic type of the message</typeparam>
      <param name="message">The message to send</param>
    </member>
    <member name="M:Magnum.Pipeline.Pipe.Accept``1(``0)">
      <summary>
            Returns an enumeration of consumers that are interested in the message
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="message">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Magnum.Pipeline.Pipe.SegmentType">
      <summary>
            The type of this pipeline node
            </summary>
    </member>
    <member name="P:Magnum.Pipeline.Pipe.MessageType">
      <summary>
            The type accepted by this segment
            </summary>
    </member>
    <member name="T:Magnum.Collections.Empty`1">
      <summary>
            Used to provide empty collections for generic types
            </summary>
      <typeparam name="T">Type of elements in the collection</typeparam>
    </member>
    <member name="T:Magnum.Serialization.TypeSerializerCacheImpl">
      <summary>
              Wraps the cache for TypeSerializer implementations
            </summary>
    </member>
    <member name="T:Magnum.Serialization.Serializer">
      <summary>
            Serializers convert objects to some type of string output
            </summary>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Serialize``1(``0,System.IO.TextWriter)">
      <summary>
            Serialize an object to the specified TextWriter
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="obj">
      </param>
      <param name="writer">
      </param>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Serialize``1(``0)">
      <summary>
            Serialize an object and return the string representing the object data
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Deserialize``1(System.String)">
      <summary>
            Deserialize an object from a string
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Deserialize``1(System.IO.TextReader)">
      <summary>
            Deserialize an object from a TextReader
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="reader">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Serialization.TypeSerializerLoader">
      <summary>
              Scans the assembly for implementations of the TypeSerializer interface for 
              the built-in types
            </summary>
    </member>
    <member name="T:Magnum.StateMachine.Event">
      <summary>
            A basic event
            </summary>
    </member>
    <member name="T:Magnum.StateMachine.BasicEvent`1">
      <summary>
            A basic event that is raised without any additional data
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.StateMachine.BasicEventAction`1.Complete">
      <summary>
            Shortcut for TransitionTo(Completed)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.StateMachine.EventCombiner`1">
      <summary>
            A combined event is raised automatically after all of the combined events have been raised
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.StateMachine.Event`1">
      <summary>
            An event with associated data
            </summary>
      <typeparam name="V">
      </typeparam>
    </member>
    <member name="T:Magnum.StateMachine.DataEvent`2">
      <summary>
            An event that has a typed data structure associated with it
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="V">
      </typeparam>
    </member>
    <member name="M:Magnum.StateMachine.DataEventAction`2.Complete">
      <summary>
            Shortcut for TransitionTo(Completed)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.StateMachine.ExceptionAction`2.Complete">
      <summary>
            Shortcut for TransitionTo(Completed)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.RaiseEvent(Magnum.StateMachine.Event)">
      <summary>
            Send an event within the current state
            </summary>
      <param name="raised">The event to raise</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.RaiseEvent``1(Magnum.StateMachine.Event,``0)">
      <summary>
            Send an event within the current state passing the data associated with the event
            </summary>
      <typeparam name="TData">The type of data, must match the data type expected by the event</typeparam>
      <param name="raised">The event to raise</param>
      <param name="value">The data to associate with the event</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.Define(System.Action)">
      <summary>
            This must be called from the static constructor to define the states, events, and transitions
            
            This is performed as an expression because the base static class needs to perform setup
            before actually defining the state machine and derived classes don't call static base class 
            constructors
            </summary>
      <param name="definition">An expression to invoke to setup the state machine</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.SetCompletedState(Magnum.StateMachine.State)">
      <summary>
            Sets the state to use for a completed state machine. By default, the state named "Completed" is used.
            </summary>
      <param name="completedState">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.SetInitialState(Magnum.StateMachine.State)">
      <summary>
            Sets the state to use for a newly created state machine. By default, the state named "Initial" is used.
            </summary>
      <param name="initialState">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.When(Magnum.StateMachine.Event)">
      <summary>
            Defines an actions to take when an event is raised within a state
            </summary>
      <param name="raised">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.When``1(Magnum.StateMachine.Event{``0})">
      <summary>
            Starts the definition of actions to take when an event occurs
            </summary>
      <param name="raised">The event that would be raised</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.InCaseOf``1">
      <summary>
            Defines an action to take if an exception occurs while the event is being handled
            </summary>
      <typeparam name="TException">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.Initially(Magnum.StateMachine.StateEventAction{`0}[])">
      <summary>
            Opens the definition of the event actions for the initial state (shortcut for During(Initial))
            </summary>
      <param name="actions">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.During(Magnum.StateMachine.State,Magnum.StateMachine.StateEventAction{`0}[])">
      <summary>
            Opens the definition of the event actions for the specified state
            </summary>
      <param name="inputState">
      </param>
      <param name="actions">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.Anytime(Magnum.StateMachine.StateEventAction{`0}[])">
      <summary>
            Starts the definition of actions to take when events occur during any state
            </summary>
      <param name="actions">
      </param>
    </member>
    <member name="P:Magnum.StateMachine.StateMachine`1.CurrentState">
      <summary>
            Returns the current state of the StateMachine
            </summary>
    </member>
    <member name="T:Magnum.Range`1">
      <summary>
            Represents a range of enumerable items
            </summary>
      <typeparam name="T">The type of range</typeparam>
    </member>
    <member name="M:Magnum.Range`1.#ctor(`0,`0,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new Range
            </summary>
      <param name="lowerBound">The lower bound of the range</param>
      <param name="upperBound">The upper bound of the range</param>
      <param name="includeLowerBound">If the lower bound should be included</param>
      <param name="includeUpperBound">If the upper bound should be included</param>
    </member>
    <member name="M:Magnum.Range`1.#ctor(`0,`0,System.Boolean,System.Boolean,System.Collections.Generic.IComparer{`0})">
      <summary>
            Initializes a new Range
            </summary>
      <param name="lowerBound">The lower bound of the range</param>
      <param name="upperBound">The upper bound of the range</param>
      <param name="includeLowerBound">If the lower bound should be included</param>
      <param name="includeUpperBound">If the upper bound should be included</param>
      <param name="comparer">The comparison to use for the range elements</param>
    </member>
    <member name="M:Magnum.Range`1.Contains(`0)">
      <summary>
            Determines if the value specified is contained within the range
            </summary>
      <param name="value">The value to check</param>
      <returns>Returns true if the value is contained within the range, otherwise false</returns>
    </member>
    <member name="M:Magnum.Range`1.Forward(System.Func{`0,`0})">
      <summary>
            Returns a forward enumerator for the range
            </summary>
      <param name="step">A function used to step through the range</param>
      <returns>An enumerator for the range</returns>
    </member>
    <member name="P:Magnum.Range`1.LowerBound">
      <summary>
            The lower bound of the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.UpperBound">
      <summary>
            The upper bound of the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.Comparer">
      <summary>
            The comparison used for the elements in the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.IncludeLowerBound">
      <summary>
            If the lower bound is included in the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.IncludeUpperBound">
      <summary>
            If the upper bound is included in the range
            </summary>
    </member>
    <member name="M:Magnum.RangeBuilder`1.Through(`0)">
      <summary>
            Specifies the upper bound for the range
            </summary>
      <param name="upperBound">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Weeks(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of weeks
            </summary>
      <param name="value">The number of weeks</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Days(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of days
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Hours(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of hours
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Minutes(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of minutes
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Seconds(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of seconds
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Milliseconds(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of milliseconds
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Repeat(System.TimeSpan,System.Int32)">
      <summary>
            Returns an enumeration of the specified TimeSpan with the specified number of elements
            </summary>
      <param name="value">The TimeSpan to repeat</param>
      <param name="times">The number of times to repeat the TimeSpan</param>
      <returns>An enumeration of TimeSpan</returns>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.Execute(System.Collections.Generic.IEnumerator{System.Int32})">
      <summary>
            Executes a method containing yields, but waits for said method to complete
            </summary>
      <param name="enumerator">The method to execute</param>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.BeginExecute(System.Collections.Generic.IEnumerator{System.Int32},System.AsyncCallback,System.Object)">
      <summary>
            Asynchronously executes a method containing yields
            </summary>
      <param name="enumerator">The method to execute</param>
      <param name="callback">The asynchronous method to call back</param>
      <param name="state">A state object passed to the asynchronous callback</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.EndExecute(System.IAsyncResult)">
      <summary>
            Completes the execution of an asynchronous methods
            </summary>
      <param name="asyncResult">
      </param>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.Cancel">
      <summary>
            Cancel the execution of an asynchronous method
            </summary>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.End">
      <summary>
            Returns a callback for the BeginXXX method being yielded
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.Result">
      <summary>
            Returns the next async result in the queue of completed asynchronous methods
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Threading.AsyncExecutor">
      <summary>
            Attempts to provide a method of running asynchronous methods (the BeginXXX/EndXXX style)
            in a linear manner avoiding all the propogation of those methods up the call stack
            
            Slightly influence by Jeffrey Richter's PowerThreading library
            http://wintellect.com/PowerThreading.aspx
            
            </summary>
    </member>
    <member name="T:Magnum.Threading.ILockedObject`1">
      <summary>
            Interface to a locked object of type T
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.ReadUnlocked(System.Action{`0})">
      <summary>
            Access the contained object without any locking
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.ReadLock(System.Action{`0})">
      <summary>
            Access the contained object within a read lock
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.ReadLock(System.TimeSpan,System.Action{`0})">
      <summary>
            Access the contained object within a read lock if possible before the timeout expires
            </summary>
      <param name="timeout">The time to wait for a lock before returning false</param>
      <param name="action">
      </param>
      <returns>True if the lock was obtained and the action called, otherwise false</returns>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.UpgradeableReadLock(System.Action{`0})">
      <summary>
            Access the contained object within an upgradeable read lock
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.WriteLock(System.Func{`0,`0})">
      <summary>
            Access the contained object within a write lock
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="T:Magnum.Threading.ReaderWriterLockedObject`1">
      <summary>
            Contains an object within a ReaderWriterLockContext
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.ValueProviders.ValueProviderDecorator">
      <summary>
              Makes wrapping another value provider easy, including logging of values as they are utilized
            </summary>
    </member>
    <member name="M:Magnum.ValueProviders.CommandLineValueProvider.#ctor">
      <summary>
            Uses the default command-line for the process
            </summary>
    </member>
    <member name="T:Magnum.ValueProviders.FileValueProvider">
      <summary>
            Wraps the reading of a file containing value configuration, passing the appropriate context
            provider that is initialized from the stream.
            </summary>
    </member>
    <member name="T:Magnum.ValueProviders.MultipleValueProvider">
      <summary>
              Requests a value from an ordered list of value providers
            </summary>
    </member>
    <member name="T:Magnum.FileSystem.Directory">
      <summary>
            A directory is a logical reference to a hierarchical physical location containing files
            and directories.
            </summary>
    </member>
    <member name="M:Magnum.FileSystem.Directory.GetFiles">
      <summary>
            Returns all of the files contained in the directory
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.FileSystem.Directory.GetDirectories">
      <summary>
            Returns all of the subdirectories in the directory
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.FileSystem.Directory.Exists">
      <summary>
            Checks if the directory exists
            </summary>
      <returns>True if the directory exists, otherwise false</returns>
    </member>
    <member name="T:Magnum.FileSystem.DirectoryName">
      <summary>
            A specialization of the PathName class for directories
            </summary>
    </member>
    <member name="M:Magnum.FileSystem.DirectoryName.Combine(System.String)">
      <summary>
            Combines the directory name with a child directory/file name
            </summary>
      <param name="child">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Magnum.FileSystem.DirectoryName.Name">
      <summary>
            The contained PathName for the directory
            </summary>
    </member>
    <member name="T:Magnum.FileSystem.FileName">
      <summary>
            A specialization of the PathName class for files
            </summary>
    </member>
    <member name="T:Magnum.FileSystem.FileSystemLocator">
      <summary>
            Supported the resolution of FileName and DirectoryName into the appropriate File 
            or Directory implementations based on the available file systems.
            </summary>
    </member>
    <member name="M:Magnum.FileSystem.FileSystemLocator.GetFile(Magnum.FileSystem.FileName)">
      <summary>
            Given a FileName, returns the File interface for the requested file
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.FileSystem.FileSystemLocator.GetDirectory(Magnum.FileSystem.DirectoryName)">
      <summary>
            Given a DirectoryName, returns the Directory interface for the requested directory
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.FileSystem.LocalFileSystemLocator">
      <summary>
            Implementation of FileSystemLocator that resolves FileName and DirectoryName into the appropriate 
            classes
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonReader.State">
      <summary>
            Specifies the state of the reader.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader" /> class with the specified <see cref="T:System.IO.TextReader" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>true if the next token was read successfully; false if there are no more tokens to read.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Skip">
      <summary>
            Skips the children of the current token.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken)">
      <summary>
            Sets the current token.
            </summary>
      <param name="newToken">The new token.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken,System.Object)">
      <summary>
            Sets the current token and value.
            </summary>
      <param name="newToken">The new token.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetStateBasedOnCurrent">
      <summary>
            Sets the state based on current token type.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Close">
      <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State" /> to Closed. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.CurrentState">
      <summary>
            Gets the current reader state.
            </summary>
      <value>The current reader state.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.CloseInput">
      <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader" /> should be closed when the reader is closed.
            </summary>
      <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader" /> when
            the reader is closed; otherwise false. The default is true.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.QuoteChar">
      <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.TokenType">
      <summary>
            Gets the type of the current Json token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Value">
      <summary>
            Gets the text value of the current Json token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.ValueType">
      <summary>
            Gets The Common Language Runtime (CLR) type for the current Json token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Depth">
      <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
      <value>The depth of the current token in the JSON document.</value>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="stream">The stream.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream,System.Boolean,System.DateTimeKind)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="stream">The stream.</param>
      <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
      <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>
            A <see cref="T:System.Nullable`1" />.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.Close">
      <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State" /> to Closed.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.JsonNet35BinaryCompatibility">
      <summary>
            Gets or sets a value indicating whether binary data reading should compatible with incorrect Json.NET 3.5 written binary.
            </summary>
      <value>
        <c>true</c> if binary data reading will be compatible with incorrect Json.NET 3.5 written binary; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.ReadRootValueAsArray">
      <summary>
            Gets or sets a value indicating whether the root object will be read as a JSON array.
            </summary>
      <value>
        <c>true</c> if the root object will be read as a JSON array; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.DateTimeKindHandling">
      <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.
            </summary>
      <value>The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.#ctor">
      <summary>
            Creates an instance of the <c>JsonWriter</c> class. 
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndObject">
      <summary>
            Writes the end of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndArray">
      <summary>
            Writes the end of an array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndConstructor">
      <summary>
            Writes the end constructor.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd">
      <summary>
            Writes the end of the current Json object or array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteToken(Newtonsoft.Json.JsonReader)">
      <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader" /> token.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read the token from.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the specified end token.
            </summary>
      <param name="token">The end token to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteIndent">
      <summary>
            Writes indent characters.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValueDelimiter">
      <summary>
            Writes the JSON value delimiter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteIndentSpace">
      <summary>
            Writes an indent space.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON without changing the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteRawValue(System.String)">
      <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int32})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt32})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int64})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt64})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Single})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Double})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Boolean})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int16})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt16})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Char})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Byte})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.SByte})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Decimal})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTime})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTimeOffset})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Guid})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.TimeSpan})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteWhitespace(System.String)">
      <summary>
            Writes out the given white space.
            </summary>
      <param name="ws">The string of white space characters.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.CloseOutput">
      <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader" /> should be closed when the writer is closed.
            </summary>
      <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader" /> when
            the writer is closed; otherwise false. The default is true.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Top">
      <summary>
            Gets the top.
            </summary>
      <value>The top.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.WriteState">
      <summary>
            Gets the state of the writer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Formatting">
      <summary>
            Indicates how the output is formatted.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.#ctor(System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter" /> class.
            </summary>
      <param name="stream">The stream.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the end.
            </summary>
      <param name="token">The token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRawValue(System.String)">
      <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteObjectId(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value that represents a BSON object id.
            </summary>
      <param name="value">
      </param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRegex(System.String,System.String)">
      <summary>
            Writes a BSON regex.
            </summary>
      <param name="pattern">The regex pattern.</param>
      <param name="options">The regex options.</param>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonWriter.DateTimeKindHandling">
      <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.
            When set to <see cref="F:System.DateTimeKind.Unspecified" /> no conversion will occur.
            </summary>
      <value>The <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonObjectId">
      <summary>
            Represents a BSON Oid (object id).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonObjectId.#ctor(System.Byte[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> class.
            </summary>
      <param name="value">The Oid value.</param>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonObjectId.Value">
      <summary>
            Gets or sets the value of the Oid.
            </summary>
      <value>The value of the Oid.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverter">
      <summary>
            Converts an object to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.GetSchema">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of the JSON produced by the JsonConverter.
            </summary>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of the JSON produced by the JsonConverter.</returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverter.CanRead">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverter.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.BinaryConverter">
      <summary>
            Converts a binary value to and from a base 64 string value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DataSetConverter">
      <summary>
            Converts a <see cref="T:System.Data.DataSet" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DataTableConverter">
      <summary>
            Converts a <see cref="T:System.Data.DataTable" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.CustomCreationConverter`1">
      <summary>
            Create a custom object
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.Create(System.Type)">
      <summary>
            Creates an object which will then be populated by the serializer.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DateTimeConverterBase">
      <summary>
            Provides a base class for converting a <see cref="T:System.DateTime" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DateTimeConverterBase.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.EntityKeyMemberConverter">
      <summary>
            Converts an Entity Framework EntityKey to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.ExpandoObjectConverter">
      <summary>
            Converts an ExpandoObject to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.ExpandoObjectConverter.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.KeyValuePairConverter">
      <summary>
            Converts a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.BsonObjectIdConverter">
      <summary>
            Converts a <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> to and from JSON and BSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.RegexConverter">
      <summary>
            Converts a <see cref="T:System.Text.RegularExpressions.Regex" /> to and from JSON and BSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.StringEnumConverter">
      <summary>
            Converts an <see cref="T:System.Enum" /> to and from its name string value.
            </summary>
      <summary>
            Converts an <see cref="T:System.Enum" /> to and from its name string value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.GetEnumNameMap(System.Type)">
      <summary>
            A cached representation of the Enum string representation to respect per Enum field name.
            </summary>
      <param name="t">The type of the Enum.</param>
      <returns>A map of enum field name to either the field name, or the configured enum member name (<see cref="T:System.Runtime.Serialization.EnumMemberAttribute" />).</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.StringEnumConverter.CamelCaseText">
      <summary>
            Gets or sets a value indicating whether the written enum text should be camel case.
            </summary>
      <value>
        <c>true</c> if the written enum text will be camel case; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.ConstructorHandling">
      <summary>
            Specifies how constructors are used when initializing objects during deserialization by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ConstructorHandling.Default">
      <summary>
            First attempt to use the public default constructor then fall back to single paramatized constructor.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ConstructorHandling.AllowNonPublicDefaultConstructor">
      <summary>
            Allow Json.NET to use a non-public default constructor.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConstructorAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> not to serialize the public field or public read/write property value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.IJEnumerable`1">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
      <typeparam name="T">The type of token</typeparam>
    </member>
    <member name="P:Newtonsoft.Json.Linq.IJEnumerable`1.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Newtonsoft.Json.IJsonLineInfo">
      <summary>
            Provides an interface to enable a class to return line and position information.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.IJsonLineInfo.HasLineInfo">
      <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
      <returns>
        <c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.IJsonLineInfo.LineNumber">
      <summary>
            Gets the current line number.
            </summary>
      <value>The current line number or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    </member>
    <member name="P:Newtonsoft.Json.IJsonLineInfo.LinePosition">
      <summary>
            Gets the current line position.
            </summary>
      <value>The current line position or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JToken">
      <summary>
            Represents an abstract JSON token.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.DeepEquals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Compares the values of two tokens, including the values of all descendant tokens.
            </summary>
      <param name="t1">The first <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <param name="t2">The second <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <returns>true if the tokens are equal; otherwise false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AddAfterSelf(System.Object)">
      <summary>
            Adds the specified content immediately after this token.
            </summary>
      <param name="content">A content object that contains simple content or a collection of content objects to be added after this token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AddBeforeSelf(System.Object)">
      <summary>
            Adds the specified content immediately before this token.
            </summary>
      <param name="content">A content object that contains simple content or a collection of content objects to be added before this token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Ancestors">
      <summary>
            Returns a collection of the ancestor tokens of this token.
            </summary>
      <returns>A collection of the ancestor tokens of this token.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AfterSelf">
      <summary>
            Returns a collection of the sibling tokens after this token, in document order.
            </summary>
      <returns>A collection of the sibling tokens after this tokens, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.BeforeSelf">
      <summary>
            Returns a collection of the sibling tokens before this token, in document order.
            </summary>
      <returns>A collection of the sibling tokens before this token, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Value``1(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key converted to the specified type.
            </summary>
      <typeparam name="T">The type to convert the token to.</typeparam>
      <param name="key">The token key.</param>
      <returns>The converted token value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Children">
      <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Children``1">
      <summary>
            Returns a collection of the child tokens of this token, in document order, filtered by the specified type.
            </summary>
      <typeparam name="T">The type to filter the child tokens on.</typeparam>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Values``1">
      <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
      <typeparam name="T">The type to convert the values to.</typeparam>
      <returns>A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Remove">
      <summary>
            Removes this token from its parent.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Replace(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Replaces this token with the specified token.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToString">
      <summary>
            Returns the indented JSON for this token.
            </summary>
      <returns>
            The indented JSON for this token.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToString(Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Returns the JSON for this token using the given formatting and converters.
            </summary>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
      <returns>The JSON for this token using the given formatting and converters.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Boolean">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Boolean" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTimeOffset">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.DateTimeOffset" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Boolean}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int64">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int64" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTime}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTimeOffset}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Decimal}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Double}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int32">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int32" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int16">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int16" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt16">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt16" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int32}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int16}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt16}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTime">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.DateTime" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int64}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Single}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Decimal">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Decimal" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt32}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt64}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Double">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Double" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Single">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Single" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.String">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.String" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt32">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt32" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt64">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt64" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Byte[]">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Byte[]" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Boolean)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Boolean" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTimeOffset)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.DateTimeOffset" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Boolean})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int64)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTime})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTimeOffset})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Decimal})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Double})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int16)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt16)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int32)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int32})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTime)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.DateTime" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int64})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Single})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Decimal)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Decimal" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int16})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt16})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt32})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt64})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Double)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Double" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Single)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Single" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.String)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.String" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt32)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt64)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt64" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Byte[])~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Byte[]" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.CreateReader">
      <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonReader" /> for this token.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.JsonReader" /> that can be used to read this token and its descendants.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when reading the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1(Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" /> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when creating the object.</param>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ReadFrom(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String)">
      <summary>
            Selects the token that matches the object path.
            </summary>
      <param name="path">
            The object path from the current <see cref="T:Newtonsoft.Json.Linq.JToken" /> to the <see cref="T:Newtonsoft.Json.Linq.JToken" />
            to be returned. This must be a string of property names or array indexes separated
            by periods, such as <code>Tables[0].DefaultView[0].Price</code> in C# or
            <code>Tables(0).DefaultView(0).Price</code> in Visual Basic.
            </param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that matches the object path or a null reference if no matching token is found.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String,System.Boolean)">
      <summary>
            Selects the token that matches the object path.
            </summary>
      <param name="path">
            The object path from the current <see cref="T:Newtonsoft.Json.Linq.JToken" /> to the <see cref="T:Newtonsoft.Json.Linq.JToken" />
            to be returned. This must be a string of property names or array indexes separated
            by periods, such as <code>Tables[0].DefaultView[0].Price</code> in C# or
            <code>Tables(0).DefaultView(0).Price</code> in Visual Basic.
            </param>
      <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no token is found.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that matches the object path.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.DeepClone">
      <summary>
            Creates a new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />. All child tokens are recursively cloned.
            </summary>
      <returns>A new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.EqualityComparer">
      <summary>
            Gets a comparer that can compare two tokens for value equality.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JTokenEqualityComparer" /> that can compare two nodes for value equality.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Parent">
      <summary>
            Gets or sets the parent.
            </summary>
      <value>The parent.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Root">
      <summary>
            Gets the root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.HasValues">
      <summary>
            Gets a value indicating whether this token has childen tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Next">
      <summary>
            Gets the next sibling token of this node.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the next sibling token.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Previous">
      <summary>
            Gets the previous sibling token of this node.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the previous sibling token.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.First">
      <summary>
            Get the first child token of this token.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Last">
      <summary>
            Get the last child token of this token.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JValue">
      <summary>
            Represents a value in JSON (string, integer, date, etc).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class from another <see cref="T:Newtonsoft.Json.Linq.JValue" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JValue" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.UInt64)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.DateTime)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Uri)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateComment(System.String)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.
            </summary>
      <param name="value">The value.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateString(System.String)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.
            </summary>
      <param name="value">The value.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.Equals(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="format">The format.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="formatProvider">The format provider.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String,System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="format">The format.</param>
      <param name="formatProvider">The format provider.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CompareTo(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
      <param name="obj">An object to compare with this instance.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings:
            Value
            Meaning
            Less than zero
            This instance is less than <paramref name="obj" />.
            Zero
            This instance is equal to <paramref name="obj" />.
            Greater than zero
            This instance is greater than <paramref name="obj" />.
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance.
            </exception>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.HasValues">
      <summary>
            Gets a value indicating whether this token has childen tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.Value">
      <summary>
            Gets or sets the underlying token value.
            </summary>
      <value>The underlying token value.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JRaw">
      <summary>
            Represents a raw JSON string.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(Newtonsoft.Json.Linq.JRaw)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class from another <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class.
            </summary>
      <param name="rawJson">The raw json.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.Create(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates an instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.
            </summary>
      <param name="reader">The reader.</param>
      <returns>An instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Required">
      <summary>
            Indicating whether a property is required.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.Default">
      <summary>
            The property is not required. The default state.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.AllowNull">
      <summary>
            The property must be defined in JSON but can be a null value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.Always">
      <summary>
            The property must be defined in JSON and cannot be a null value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.UnderlyingType">
      <summary>
            Gets the underlying type for the contract.
            </summary>
      <value>The underlying type for the contract.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.CreatedType">
      <summary>
            Gets or sets the type created during deserialization.
            </summary>
      <value>The type created during deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.IsReference">
      <summary>
            Gets or sets whether this type contract is serialized as a reference.
            </summary>
      <value>Whether this type contract is serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.Converter">
      <summary>
            Gets or sets the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for this contract.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserialized">
      <summary>
            Gets or sets the method called immediately after deserialization of the object.
            </summary>
      <value>The method called immediately after deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializing">
      <summary>
            Gets or sets the method called during deserialization of the object.
            </summary>
      <value>The method called during deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerialized">
      <summary>
            Gets or sets the method called after serialization of the object graph.
            </summary>
      <value>The method called after serialization of the object graph.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializing">
      <summary>
            Gets or sets the method called before serialization of the object.
            </summary>
      <value>The method called before serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator">
      <summary>
            Gets or sets the default creator method used to create the object.
            </summary>
      <value>The default creator method used to create the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreatorNonPublic">
      <summary>
            Gets or sets a value indicating whether [default creator non public].
            </summary>
      <value>
        <c>true</c> if the default object creator is non-public; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnError">
      <summary>
            Gets or sets the method called when an error is thrown during the serialization of the object.
            </summary>
      <value>The method called when an error is thrown during the serialization of the object.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonDynamicContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonDynamicContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDynamicContract.Properties">
      <summary>
            Gets the object's properties.
            </summary>
      <value>The object's properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDynamicContract.PropertyNameResolver">
      <summary>
            Gets or sets the property name resolver.
            </summary>
      <value>The property name resolver.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonISerializableContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonISerializableContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonISerializableContract.ISerializableCreator">
      <summary>
            Gets or sets the ISerializable object constructor.
            </summary>
      <value>The ISerializable object constructor.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonLinqContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonLinqContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPrimitiveContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IValueProvider">
      <summary>
            Provides methods to get and set values.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DynamicValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using dynamic methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DynamicValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ErrorEventArgs">
      <summary>
            Provides data for the Error event.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ErrorEventArgs.#ctor(System.Object,Newtonsoft.Json.Serialization.ErrorContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ErrorEventArgs" /> class.
            </summary>
      <param name="currentObject">The current object.</param>
      <param name="errorContext">The error context.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.CurrentObject">
      <summary>
            Gets the current object the error event is being raised against.
            </summary>
      <value>The current object the error event is being raised against.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.ErrorContext">
      <summary>
            Gets the error context.
            </summary>
      <value>The error context.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JPropertyDescriptor">
      <summary>
            Represents a view of a <see cref="T:Newtonsoft.Json.Linq.JProperty" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.#ctor(System.String,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JPropertyDescriptor" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="propertyType">Type of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.CanResetValue(System.Object)">
      <summary>
            When overridden in a derived class, returns whether resetting an object changes its value.
            </summary>
      <returns>
            true if resetting the component changes its value; otherwise, false.
            </returns>
      <param name="component">The component to test for reset capability. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.GetValue(System.Object)">
      <summary>
            When overridden in a derived class, gets the current value of the property on a component.
            </summary>
      <returns>
            The value of a property for a given component.
            </returns>
      <param name="component">The component with the property for which to retrieve the value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ResetValue(System.Object)">
      <summary>
            When overridden in a derived class, resets the value for this property of the component to the default value.
            </summary>
      <param name="component">The component with the property value that is to be reset to the default value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.SetValue(System.Object,System.Object)">
      <summary>
            When overridden in a derived class, sets the value of the component to a different value.
            </summary>
      <param name="component">The component with the property value that is to be set. 
                            </param>
      <param name="value">The new value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ShouldSerializeValue(System.Object)">
      <summary>
            When overridden in a derived class, determines a value indicating whether the value of this property needs to be persisted.
            </summary>
      <returns>
            true if the property should be persisted; otherwise, false.
            </returns>
      <param name="component">The component with the property to be examined for persistence. 
                            </param>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.ComponentType">
      <summary>
            When overridden in a derived class, gets the type of the component this property is bound to.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of component this property is bound to. When the <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> or <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> methods are invoked, the object specified might be an instance of this type.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.IsReadOnly">
      <summary>
            When overridden in a derived class, gets a value indicating whether this property is read-only.
            </summary>
      <returns>
            true if the property is read-only; otherwise, false.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.PropertyType">
      <summary>
            When overridden in a derived class, gets the type of the property.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of the property.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.NameHashCode">
      <summary>
            Gets the hash code for the name of the member.
            </summary>
      <value>
      </value>
      <returns>
            The hash code for the name of the member.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IReferenceResolver">
      <summary>
            Used to resolve references when serializing and deserializing JSON by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.ResolveReference(System.Object,System.String)">
      <summary>
            Resolves a reference to its object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="reference">The reference to resolve.</param>
      <returns>The object that</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.GetReference(System.Object,System.Object)">
      <summary>
            Gets the reference for the sepecified object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="value">The object to get a reference for.</param>
      <returns>The reference to the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.IsReferenced(System.Object,System.Object)">
      <summary>
            Determines whether the specified object is referenced.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="value">The object to test for a reference.</param>
      <returns>
        <c>true</c> if the specified object is referenced; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.AddReference(System.Object,System.String,System.Object)">
      <summary>
            Adds a reference to the specified object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="reference">The reference.</param>
      <param name="value">The object to reference.</param>
    </member>
    <member name="T:Newtonsoft.Json.PreserveReferencesHandling">
      <summary>
            Specifies reference handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.None">
      <summary>
            Do not preserve references when serializing types.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Objects">
      <summary>
            Preserve references when serializing into a JSON object structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Arrays">
      <summary>
            Preserve references when serializing into a JSON array structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.All">
      <summary>
            Preserve references when serializing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonContainerAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Id">
      <summary>
            Gets or sets the id.
            </summary>
      <value>The id.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Title">
      <summary>
            Gets or sets the title.
            </summary>
      <value>The title.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Description">
      <summary>
            Gets or sets the description.
            </summary>
      <value>The description.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.IsReference">
      <summary>
            Gets or sets a value that indicates whether to preserve object reference data.
            </summary>
      <value>
        <c>true</c> to keep object reference; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonArrayAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the collection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with a flag indicating whether the array can contain null items
            </summary>
      <param name="allowNullItems">A flag indicating whether the array can contain null items.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonArrayAttribute.AllowNullItems">
      <summary>
            Gets or sets a value indicating whether null items are allowed in the collection.
            </summary>
      <value>
        <c>true</c> if null items are allowed in the collection; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.DefaultValueHandling">
      <summary>
            Specifies default value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Include">
      <summary>
            Include members where the member value is the same as the member's default value when serializing objects.
            Included members are written to JSON. Has no effect when deserializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Ignore">
      <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            so that is is not written to JSON, and ignores setting members when the JSON value equals the member's default value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Populate">
      <summary>
            Members with a default value but no JSON will be set to their default value when deserializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.IgnoreAndPopulate">
      <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            and sets members to their default value when deserializing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverterAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to use the specified <see cref="T:Newtonsoft.Json.JsonConverter" /> when serializing the member or class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverterAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonConverterAttribute" /> class.
            </summary>
      <param name="converterType">Type of the converter.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverterAttribute.ConverterType">
      <summary>
            Gets the type of the converter.
            </summary>
      <value>The type of the converter.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonObjectAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(Newtonsoft.Json.MemberSerialization)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified member serialization.
            </summary>
      <param name="memberSerialization">The member serialization.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonObjectAttribute.MemberSerialization">
      <summary>
            Gets or sets the member serialization.
            </summary>
      <value>The member serialization.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializerSettings">
      <summary>
            Specifies the settings on a <see cref="T:Newtonsoft.Json.JsonSerializer" /> object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializerSettings.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> class.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceLoopHandling">
      <summary>
            Gets or sets how reference loops (e.g. a class referencing itself) is handled.
            </summary>
      <value>Reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.MissingMemberHandling">
      <summary>
            Gets or sets how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
      <value>Missing member handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ObjectCreationHandling">
      <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.NullValueHandling">
      <summary>
            Gets or sets how null values are handled during serialization and deserialization.
            </summary>
      <value>Null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DefaultValueHandling">
      <summary>
            Gets or sets how null default are handled during serialization and deserialization.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Converters">
      <summary>
            Gets or sets a collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.
            </summary>
      <value>The converters.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.PreserveReferencesHandling">
      <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
      <value>The preserve references handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameHandling">
      <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameAssemblyFormat">
      <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
      <value>The type name assembly format.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ConstructorHandling">
      <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
      <value>The constructor handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ContractResolver">
      <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
      <value>The contract resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceResolver">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
      <value>The reference resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Binder">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
      <value>The binder.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Error">
      <summary>
            Gets or sets the error handler called during serialization and deserialization.
            </summary>
      <value>The error handler called during serialization and deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Context">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
      <value>The context.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonValidatingReader">
      <summary>
            Represents a reader that provides <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> validation.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.#ctor(Newtonsoft.Json.JsonReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonValidatingReader" /> class that
            validates the content returned from the given <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from while validating.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Value">
      <summary>
            Gets the text value of the current Json token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Depth">
      <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
      <value>The depth of the current token in the JSON document.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.QuoteChar">
      <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.TokenType">
      <summary>
            Gets the type of the current Json token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.ValueType">
      <summary>
            Gets The Common Language Runtime (CLR) type for the current Json token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Schema">
      <summary>
            Gets or sets the schema.
            </summary>
      <value>The schema.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Reader">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.JsonReader" /> used to construct this <see cref="T:Newtonsoft.Json.JsonValidatingReader" />.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.JsonReader" /> specified in the constructor.</value>
    </member>
    <member name="E:Newtonsoft.Json.JsonValidatingReader.ValidationEventHandler">
      <summary>
            Sets an event handler for receiving schema validation errors.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenEqualityComparer">
      <summary>
            Compares tokens to determine whether they are equal.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.Equals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines whether the specified objects are equal.
            </summary>
      <param name="x">The first object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <param name="y">The second object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.GetHashCode(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Returns a hash code for the specified object.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
      <returns>A hash code for the specified object.</returns>
      <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.</exception>
    </member>
    <member name="T:Newtonsoft.Json.MemberSerialization">
      <summary>
            Specifies the member serialization options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.OptOut">
      <summary>
            All members are serialized by default. Members can be excluded using the <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.OptIn">
      <summary>
            Only members must be marked with the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> are serialized.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.ObjectCreationHandling">
      <summary>
            Specifies how object creation is handled by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Auto">
      <summary>
            Reuse existing objects, create new objects when needed.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Reuse">
      <summary>
            Only reuse existing objects.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Replace">
      <summary>
            Always create new objects.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Converters.IsoDateTimeConverter">
      <summary>
            Converts a <see cref="T:System.DateTime" /> to and from the ISO 8601 date format (e.g. 2008-04-12T12:53Z).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeStyles">
      <summary>
            Gets or sets the date time styles used when converting a date to and from JSON.
            </summary>
      <value>The date time styles used when converting a date to and from JSON.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeFormat">
      <summary>
            Gets or sets the date time format used when converting a date to and from JSON.
            </summary>
      <value>The date time format used when converting a date to and from JSON.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.Culture">
      <summary>
            Gets or sets the culture used when converting a date to and from JSON.
            </summary>
      <value>The culture used when converting a date to and from JSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter">
      <summary>
            Converts a <see cref="T:System.DateTime" /> to and from a JavaScript date constructor (e.g. new Date(52231943)).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing property value of the JSON that is being converted.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.JsonDateTimeSerializationMode">
      <summary>
            Specifies whether a DateTime object represents a local time, a Coordinated Universal Time (UTC), or is not specified as either local time or UTC.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Converters.JsonDateTimeSerializationMode.Local">
      <summary>
            The time represented is local time.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Converters.JsonDateTimeSerializationMode.Utc">
      <summary>
            The time represented is UTC.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Converters.JsonDateTimeSerializationMode.Unspecified">
      <summary>
            The time represented is not specified as either local time or Coordinated Universal Time (UTC).
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Converters.JsonDateTimeSerializationMode.RoundtripKind">
      <summary>
            Preserves the DateTimeKind field of a date when a DateTime object is converted to a string and the string is then converted back to a DateTime object.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Converters.XmlNodeConverter">
      <summary>
            Converts XML to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="serializer">The calling serializer.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.IsNamespaceAttribute(System.String,System.String@)">
      <summary>
            Checks if the attributeName is a namespace attribute.
            </summary>
      <param name="attributeName">Attribute name to test.</param>
      <param name="prefix">The attribute name prefix if it has one, otherwise an empty string.</param>
      <returns>True if attribute name is for a namespace attribute, otherwise false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.DeserializeRootElementName">
      <summary>
            Gets or sets the name of the root element to insert when deserializing to XML if the JSON structure has produces multiple root elements.
            </summary>
      <value>The name of the deserialize root element.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.WriteArrayAttribute">
      <summary>
            Gets or sets a flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </summary>
      <value>
        <c>true</c> if the array attibute is written to the XML; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.OmitRootObject">
      <summary>
            Gets or sets a value indicating whether to write the root JSON object.
            </summary>
      <value>
        <c>true</c> if the JSON root object is omitted; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonTextReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.#ctor(System.IO.TextReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader" /> class with the specified <see cref="T:System.IO.TextReader" />.
            </summary>
      <param name="reader">The <c>TextReader</c> containing the XML data to read.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.Close">
      <summary>
            Changes the state to closed. 
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.HasLineInfo">
      <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
      <returns>
        <c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextReader.Culture">
      <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextReader.LineNumber">
      <summary>
            Gets the current line number.
            </summary>
      <value>
            The current line number or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextReader.LinePosition">
      <summary>
            Gets the current line position.
            </summary>
      <value>
            The current line position or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonPropertyAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to always serialize the member with the specified name.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class with the specified name.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.NullValueHandling">
      <summary>
            Gets or sets the null value handling used when serializing this property.
            </summary>
      <value>The null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.DefaultValueHandling">
      <summary>
            Gets or sets the default value handling used when serializing this property.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ReferenceLoopHandling">
      <summary>
            Gets or sets the reference loop handling used when serializing this property.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ObjectCreationHandling">
      <summary>
            Gets or sets the object creation handling used when deserializing this property.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.TypeNameHandling">
      <summary>
            Gets or sets the type name handling used when serializing this property.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.IsReference">
      <summary>
            Gets or sets whether this property's value is serialized as a reference.
            </summary>
      <value>Whether this property's value is serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Order">
      <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
      <value>The numeric order of serialization or deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.PropertyName">
      <summary>
            Gets or sets the name of the property.
            </summary>
      <value>The name of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Required">
      <summary>
            Gets or sets a value indicating whether this property is required.
            </summary>
      <value>
            	A value indicating whether this property is required.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonIgnoreAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> not to serialize the public field or public read/write property value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonTextWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.#ctor(System.IO.TextWriter)">
      <summary>
            Creates an instance of the <c>JsonWriter</c> class using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <c>TextWriter</c> to write to.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the specified end token.
            </summary>
      <param name="token">The end token to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndent">
      <summary>
            Writes indent characters.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValueDelimiter">
      <summary>
            Writes the JSON value delimiter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndentSpace">
      <summary>
            Writes an indent space.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteWhitespace(System.String)">
      <summary>
            Writes out the given white space.
            </summary>
      <param name="ws">The string of white space characters.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.Indentation">
      <summary>
            Gets or sets how many IndentChars to write for each level in the hierarchy when <see cref="T:Newtonsoft.Json.Formatting" /> is set to <c>Formatting.Indented</c>.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteChar">
      <summary>
            Gets or sets which character to use to quote attribute values.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.IndentChar">
      <summary>
            Gets or sets which character to use for indenting when <see cref="T:Newtonsoft.Json.Formatting" /> is set to <c>Formatting.Indented</c>.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteName">
      <summary>
            Gets or sets a value indicating whether object names will be surrounded with quotes.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonWriterException">
      <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Newtonsoft.Json.JsonReaderException">
      <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.LineNumber">
      <summary>
            Gets the line number indicating where the error occurred.
            </summary>
      <value>The line number indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.LinePosition">
      <summary>
            Gets the line position indicating where the error occurred.
            </summary>
      <value>The line position indicating where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverterCollection">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConvert">
      <summary>
            Provides methods for converting between common language runtime types and JSON types.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.True">
      <summary>
            Represents JavaScript's boolean value true as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.False">
      <summary>
            Represents JavaScript's boolean value false as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.Null">
      <summary>
            Represents JavaScript's null as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.Undefined">
      <summary>
            Represents JavaScript's undefined as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.PositiveInfinity">
      <summary>
            Represents JavaScript's positive infinity as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.NegativeInfinity">
      <summary>
            Represents JavaScript's negative infinity as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.NaN">
      <summary>
            Represents JavaScript's NaN as a string. This field is read-only.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTime)">
      <summary>
            Converts the <see cref="T:System.DateTime" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTime" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTimeOffset)">
      <summary>
            Converts the <see cref="T:System.DateTimeOffset" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Boolean)">
      <summary>
            Converts the <see cref="T:System.Boolean" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Char)">
      <summary>
            Converts the <see cref="T:System.Char" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Char" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Enum)">
      <summary>
            Converts the <see cref="T:System.Enum" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Enum" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int32)">
      <summary>
            Converts the <see cref="T:System.Int32" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int16)">
      <summary>
            Converts the <see cref="T:System.Int16" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt16)">
      <summary>
            Converts the <see cref="T:System.UInt16" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt32)">
      <summary>
            Converts the <see cref="T:System.UInt32" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int64)">
      <summary>
            Converts the <see cref="T:System.Int64" />  to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt64)">
      <summary>
            Converts the <see cref="T:System.UInt64" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Single)">
      <summary>
            Converts the <see cref="T:System.Single" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Single" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Double)">
      <summary>
            Converts the <see cref="T:System.Double" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Byte)">
      <summary>
            Converts the <see cref="T:System.Byte" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.SByte)">
      <summary>
            Converts the <see cref="T:System.SByte" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Decimal)">
      <summary>
            Converts the <see cref="T:System.Decimal" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Guid)">
      <summary>
            Converts the <see cref="T:System.Guid" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.TimeSpan)">
      <summary>
            Converts the <see cref="T:System.TimeSpan" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.TimeSpan" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Uri)">
      <summary>
            Converts the <see cref="T:System.Uri" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Uri" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String)">
      <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String,System.Char)">
      <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <param name="delimter">The string delimiter character.</param>
      <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Object)">
      <summary>
            Converts the <see cref="T:System.Object" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object)">
      <summary>
            Serializes the specified object to a JSON string.
            </summary>
      <param name="value">The object to serialize.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the specified object to a JSON string.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Serializes the specified object to a JSON string using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="converters">A collection converters used while serializing.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Serializes the specified object to a JSON string using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="converters">A collection converters used while serializing.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String)">
      <summary>
            Deserializes the JSON to a .NET object.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <returns>The deserialized object from the Json string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to a .NET object.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The deserialized object from the Json string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <returns>The deserialized object from the Json string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0)">
      <summary>
            Deserializes the JSON to the given anonymous type.
            </summary>
      <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be infered from the anonymous type passed
            as a parameter.
            </typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="anonymousTypeObject">The anonymous type object.</param>
      <returns>The deserialized anonymous type from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="converters">Converters to use while deserializing.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The object to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize.</param>
      <param name="converters">Converters to use while deserializing.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize to.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object)">
      <summary>
            Populates the object with values from the JSON string.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Populates the object with values from the JSON string.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode)">
      <summary>
            Serializes the XML node to a JSON string.
            </summary>
      <param name="node">The node to serialize.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the XML node to a JSON string.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting,System.Boolean)">
      <summary>
            Serializes the XML node to a JSON string.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="omitRootObject">Omits writing the root object.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String)">
      <summary>
            Deserializes the XmlNode from a JSON string.
            </summary>
      <param name="value">The JSON string.</param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String)">
      <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String,System.Boolean)">
      <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string.
            </summary>
      <param name="node">The node to convert to JSON.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string.
            </summary>
      <param name="node">The node to convert to JSON.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting,System.Boolean)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="omitRootObject">Omits writing the root object.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string.
            </summary>
      <param name="value">The JSON string.</param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string nested in a root elment.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String,System.Boolean)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string nested in a root elment.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializationException">
      <summary>
            The exception thrown when an error occurs during Json serialization or deserialization.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializer">
      <summary>
            Serializes and deserializes objects into and from the JSON format.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> enables you to control how objects are encoded into JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializer" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Create(Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer" />.</param>
      <returns>A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Populate(System.IO.TextReader,System.Object)">
      <summary>
            Populates the JSON values onto the target object.
            </summary>
      <param name="reader">The <see cref="T:System.IO.TextReader" /> that contains the JSON structure to reader values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Populate(Newtonsoft.Json.JsonReader,System.Object)">
      <summary>
            Populates the JSON values onto the target object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to reader values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to deserialize.</param>
      <returns>The <see cref="T:System.Object" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(System.IO.TextReader,System.Type)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:System.IO.StringReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:System.IO.TextReader" /> containing the object.</param>
      <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize``1(Newtonsoft.Json.JsonReader)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
      <typeparam name="T">The type of the object to deserialize.</typeparam>
      <returns>The instance of <typeparamref name="T" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader,System.Type)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
      <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:Newtonsoft.Json.JsonWriter" />. 
            </summary>
      <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceResolver">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Binder">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling">
      <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameAssemblyFormat">
      <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
      <value>The type name assembly format.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.PreserveReferencesHandling">
      <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceLoopHandling">
      <summary>
            Get or set how reference loops (e.g. a class referencing itself) is handled.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.MissingMemberHandling">
      <summary>
            Get or set how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.NullValueHandling">
      <summary>
            Get or set how null values are handled during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DefaultValueHandling">
      <summary>
            Get or set how null default are handled during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ObjectCreationHandling">
      <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ConstructorHandling">
      <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
      <value>The constructor handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Converters">
      <summary>
            Gets a collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.
            </summary>
      <value>Collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ContractResolver">
      <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Context">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
      <value>The context.</value>
    </member>
    <member name="E:Newtonsoft.Json.JsonSerializer.Error">
      <summary>
            Occurs when the <see cref="T:Newtonsoft.Json.JsonSerializer" /> errors during serialization and deserialization.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.Extensions">
      <summary>
            Contains the LINQ to JSON extension methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Ancestors``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of tokens that contains the ancestors of every token in the source collection.
            </summary>
      <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JToken" />.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the ancestors of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Descendants``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of tokens that contains the descendants of every token in the source collection.
            </summary>
      <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JContainer" />.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the descendants of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Properties(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JObject})">
      <summary>
            Returns a collection of child properties of every object in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the properties of every object in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
      <summary>
            Returns a collection of child values of every object in the source collection with the given key.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <param name="key">The token key.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection with the given key.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns a collection of child values of every object in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
      <summary>
            Returns a collection of converted child values of every object in the source collection with the given key.
            </summary>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <param name="key">The token key.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection with the given key.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns a collection of converted child values of every object in the source collection.
            </summary>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Value``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Converts the value.
            </summary>
      <typeparam name="U">The type to convert the value to.</typeparam>
      <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A converted value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Value``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts the value.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <typeparam name="U">The type to convert the value to.</typeparam>
      <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A converted value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Children``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of child tokens of every array in the source collection.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Children``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of converted child tokens of every array in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <typeparam name="T">The source collection type.</typeparam>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JContainer">
      <summary>
            Represents a token that can contain other tokens.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnAddingNew(System.ComponentModel.AddingNewEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.AddingNew" /> event.
            </summary>
      <param name="e">The <see cref="T:System.ComponentModel.AddingNewEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnListChanged(System.ComponentModel.ListChangedEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.ListChanged" /> event.
            </summary>
      <param name="e">The <see cref="T:System.ComponentModel.ListChangedEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.CollectionChanged" /> event.
            </summary>
      <param name="e">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Children">
      <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
      <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Values``1">
      <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
      <typeparam name="T">The type to convert the values to.</typeparam>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Descendants">
      <summary>
            Returns a collection of the descendant tokens for this token in document order.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the descendant tokens of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Add(System.Object)">
      <summary>
            Adds the specified content as children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="content">The content to be added.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.AddFirst(System.Object)">
      <summary>
            Adds the specified content as the first children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="content">The content to be added.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.CreateWriter">
      <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonWriter" /> that can be used to add tokens to the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.JsonWriter" /> that is ready to have content written to it.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.ReplaceAll(System.Object)">
      <summary>
            Replaces the children nodes of this token with the specified content.
            </summary>
      <param name="content">The content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.RemoveAll">
      <summary>
            Removes the child nodes from this token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.HasValues">
      <summary>
            Gets a value indicating whether this token has childen tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.First">
      <summary>
            Get the first child token of this token.
            </summary>
      <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.Last">
      <summary>
            Get the last child token of this token.
            </summary>
      <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.Count">
      <summary>
            Gets the count of child JSON tokens.
            </summary>
      <value>The count of child JSON tokens</value>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.ListChanged">
      <summary>
            Occurs when the list changes or an item in the list changes.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.AddingNew">
      <summary>
            Occurs before an item is added to the collection.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.CollectionChanged">
      <summary>
            Occurs when the items list of the collection has changed, or the collection is reset.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JConstructor">
      <summary>
            Represents a JSON constructor.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(Newtonsoft.Json.Linq.JConstructor)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class from another <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
      <param name="name">The constructor name.</param>
      <param name="content">The contents of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
      <param name="name">The constructor name.</param>
      <param name="content">The contents of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name.
            </summary>
      <param name="name">The constructor name.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Name">
      <summary>
            Gets or sets the name of this constructor.
            </summary>
      <value>The constructor name.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JEnumerable`1">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
      <typeparam name="T">The type of token</typeparam>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JEnumerable`1.Empty">
      <summary>
            An empty collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> struct.
            </summary>
      <param name="enumerable">The enumerable.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JEnumerable`1.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JObject">
      <summary>
            Represents a JSON object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(Newtonsoft.Json.Linq.JObject)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class from another <see cref="T:Newtonsoft.Json.Linq.JObject" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JObject" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
      <param name="content">The contents of the object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
      <param name="content">The contents of the object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Properties">
      <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1" /> of this object's properties.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of this object's properties.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Property(System.String)">
      <summary>
            Gets a <see cref="T:Newtonsoft.Json.Linq.JProperty" /> the specified name.
            </summary>
      <param name="name">The property name.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> with the specified name or null.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.PropertyValues">
      <summary>
            Gets an <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of this object's property values.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of this object's property values.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Add(System.String,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Adds the specified property name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Remove(System.String)">
      <summary>
            Removes the property with the specified name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>true if item was successfully removed; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.TryGetValue(System.String,Newtonsoft.Json.Linq.JToken@)">
      <summary>
            Tries the get value.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
      <returns>true if a value was successfully retrieved; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanged(System.String)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanged" /> event with the provided arguments.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanging(System.String)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanging" /> event with the provided arguments.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.String)">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanged">
      <summary>
            Occurs when a property value changes.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanging">
      <summary>
            Occurs when a property value is changing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JArray">
      <summary>
            Represents a JSON array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(Newtonsoft.Json.Linq.JArray)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class from another <see cref="T:Newtonsoft.Json.Linq.JArray" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JArray" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
      <param name="content">The contents of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
      <param name="content">The contents of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.IndexOf(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Insert(System.Int32,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.RemoveAt(System.Int32)">
      <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Add(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Clear">
      <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Contains(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Remove(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> at the specified index.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.#ctor(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenReader" /> class.
            </summary>
      <param name="token">The token to read from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor(Newtonsoft.Json.Linq.JContainer)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class writing to the given <see cref="T:Newtonsoft.Json.Linq.JContainer" />.
            </summary>
      <param name="container">The container being written to.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the end.
            </summary>
      <param name="token">The token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JTokenWriter.Token">
      <summary>
            Gets the token being writen.
            </summary>
      <value>The token being writen.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JProperty">
      <summary>
            Represents a JSON property.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(Newtonsoft.Json.Linq.JProperty)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class from another <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
      <param name="name">The property name.</param>
      <param name="content">The property content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
      <param name="name">The property name.</param>
      <param name="content">The property content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JProperty" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JProperty" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Name">
      <summary>
            Gets the property name.
            </summary>
      <value>The property name.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Value">
      <summary>
            Gets or sets the property value.
            </summary>
      <value>The property value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenType">
      <summary>
            Specifies the type of token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.None">
      <summary>
            No token type has been set.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Object">
      <summary>
            A JSON object.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Array">
      <summary>
            A JSON array.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Constructor">
      <summary>
            A JSON constructor.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Property">
      <summary>
            A JSON object property.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Comment">
      <summary>
            A comment.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Integer">
      <summary>
            An integer value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Float">
      <summary>
            A float value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.String">
      <summary>
            A string value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Boolean">
      <summary>
            A boolean value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Null">
      <summary>
            A null value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Undefined">
      <summary>
            An undefined value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Date">
      <summary>
            A date value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Raw">
      <summary>
            A raw JSON value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Bytes">
      <summary>
            A collection of bytes value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Guid">
      <summary>
            A Guid value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Uri">
      <summary>
            A Uri value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.TimeSpan">
      <summary>
            A TimeSpan value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.Extensions">
      <summary>
            Contains the JSON schema extension methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.IsValid(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
      <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
      <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema,Newtonsoft.Json.Schema.ValidationEventHandler)">
      <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <param name="validationEventHandler">The validation event handler.</param>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaException">
      <summary>
            Returns detailed information about the schema exception.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LineNumber">
      <summary>
            Gets the line number indicating where the error occurred.
            </summary>
      <value>The line number indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LinePosition">
      <summary>
            Gets the line position indicating where the error occurred.
            </summary>
      <value>The line position indicating where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaResolver">
      <summary>
            Resolves <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from an id.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.GetSchema(System.String)">
      <summary>
            Gets a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> for the specified id.
            </summary>
      <param name="id">The id.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> for the specified id.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaResolver.LoadedSchemas">
      <summary>
            Gets or sets the loaded schemas.
            </summary>
      <value>The loaded schemas.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling">
      <summary>
            Specifies undefined schema Id handling options for the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaGenerator" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.None">
      <summary>
            Do not infer a schema Id.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseTypeName">
      <summary>
            Use the .NET type name as the schema Id.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseAssemblyQualifiedName">
      <summary>
            Use the assembly qualified .NET type name as the schema Id.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.ValidationEventArgs">
      <summary>
            Returns detailed information related to the <see cref="T:Newtonsoft.Json.Schema.ValidationEventHandler" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Exception">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> associated with the validation event.
            </summary>
      <value>The JsonSchemaException associated with the validation event.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Message">
      <summary>
            Gets the text description corresponding to the validation event.
            </summary>
      <value>The text description.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.ValidationEventHandler">
      <summary>
            Represents the callback method that will handle JSON schema validation events and the <see cref="T:Newtonsoft.Json.Schema.ValidationEventArgs" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IContractResolver">
      <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IContractResolver.ResolveContract(System.Type)">
      <summary>
            Resolves the contract for a given type.
            </summary>
      <param name="type">The type to resolve a contract for.</param>
      <returns>The contract for a given type.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DefaultContractResolver">
      <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> class.
            </summary>
      <param name="shareCache">
            If set to <c>true</c> the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> will use a cached shared with other resolvers of the same type.
            Sharing the cache will significantly performance because expensive reflection will only happen once but could cause unexpected
            behavior if different instances of the resolver are suppose to produce different results. When set to false it is highly
            recommended to reuse <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> instances with the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContract(System.Type)">
      <summary>
            Resolves the contract for a given type.
            </summary>
      <param name="type">The type to resolve a contract for.</param>
      <returns>The contract for a given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.GetSerializableMembers(System.Type)">
      <summary>
            Gets the serializable members for the type.
            </summary>
      <param name="objectType">The type to get serializable members for.</param>
      <returns>The serializable members for the type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateObjectContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateConstructorParameters(System.Reflection.ConstructorInfo,Newtonsoft.Json.Serialization.JsonPropertyCollection)">
      <summary>
            Creates the constructor parameters.
            </summary>
      <param name="constructor">The constructor to create properties for.</param>
      <param name="memberProperties">The type's member properties.</param>
      <returns>Properties for the given <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePropertyFromConstructorParameter(Newtonsoft.Json.Serialization.JsonProperty,System.Reflection.ParameterInfo)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="matchingMemberProperty">The matching member property.</param>
      <param name="parameterInfo">The constructor parameter.</param>
      <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContractConverter(System.Type)">
      <summary>
            Resolves the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for the contract.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateDictionaryContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateArrayContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePrimitiveContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateLinqContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateISerializableContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateDynamicContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateStringContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateContract(System.Type)">
      <summary>
            Determines which contract type is created for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperties(System.Type,Newtonsoft.Json.MemberSerialization)">
      <summary>
            Creates properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.
            </summary>
      <param name="type">The type to create properties for.</param>
            /// <param name="memberSerialization">The member serialization mode for the type.</param><returns>Properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.</returns></member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateMemberValueProvider(System.Reflection.MemberInfo)">
      <summary>
            Creates the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.
            </summary>
      <param name="member">The member.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperty(System.Reflection.MemberInfo,Newtonsoft.Json.MemberSerialization)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.
            </summary>
      <param name="memberSerialization">The member's parent <see cref="T:Newtonsoft.Json.MemberSerialization" />.</param>
      <param name="member">The member to create a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for.</param>
      <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolvePropertyName(System.String)">
      <summary>
            Resolves the name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>Name of the property.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DynamicCodeGeneration">
      <summary>
            Gets a value indicating whether members are being get and set using dynamic code generation.
            This value is determined by the runtime permissions available.
            </summary>
      <value>
        <c>true</c> if using dynamic code generation; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DefaultMembersSearchFlags">
      <summary>
            Gets or sets the default members search flags.
            </summary>
      <value>The default members search flags.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.SerializeCompilerGeneratedMembers">
      <summary>
            Gets or sets a value indicating whether compiler generated members should be serialized.
            </summary>
      <value>
        <c>true</c> if serialized compiler generated members; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver">
      <summary>
            Resolves member mappings for a type, camel casing property names.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.ResolvePropertyName(System.String)">
      <summary>
            Resolves the name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>The property name camel cased.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DefaultSerializationBinder">
      <summary>
            The default serialization binder used when resolving and loading classes from type names.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultSerializationBinder.BindToType(System.String,System.String)">
      <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
      <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly" /> name of the serialized object.</param>
      <param name="typeName">Specifies the <see cref="T:System.Type" /> name of the serialized object.</param>
      <returns>
            The type of the object the formatter creates a new instance of.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultSerializationBinder.BindToName(System.Type,System.String@,System.String@)">
      <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
      <param name="serializedType">The type of the object the formatter creates a new instance of.</param>
      <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly" /> name of the serialized object. </param>
      <param name="typeName">Specifies the <see cref="T:System.Type" /> name of the serialized object. </param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ErrorContext">
      <summary>
            Provides information surrounding an error.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Error">
      <summary>
            Gets or sets the error.
            </summary>
      <value>The error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.OriginalObject">
      <summary>
            Gets the original object that caused the error.
            </summary>
      <value>The original object that caused the error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Member">
      <summary>
            Gets the member that caused the error.
            </summary>
      <value>The member that caused the error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Handled">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.ErrorContext" /> is handled.
            </summary>
      <value>
        <c>true</c> if handled; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonArrayContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonArrayContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonDictionaryContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonDictionaryContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.PropertyNameResolver">
      <summary>
            Gets or sets the property name resolver.
            </summary>
      <value>The property name resolver.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonProperty">
      <summary>
            Maps a JSON property to a .NET member or constructor parameter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonProperty.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyName">
      <summary>
            Gets or sets the name of the property.
            </summary>
      <value>The name of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Order">
      <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
      <value>The numeric order of serialization or deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.UnderlyingName">
      <summary>
            Gets or sets the name of the underlying member or parameter.
            </summary>
      <value>The name of the underlying member or parameter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ValueProvider">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyType">
      <summary>
            Gets or sets the type of the property.
            </summary>
      <value>The type of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Converter">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.JsonConverter" /> for the property.
            If set this converter takes presidence over the contract converter for the property type.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.MemberConverter">
      <summary>
            Gets the member converter.
            </summary>
      <value>The member converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Ignored">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is ignored.
            </summary>
      <value>
        <c>true</c> if ignored; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Readable">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is readable.
            </summary>
      <value>
        <c>true</c> if readable; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Writable">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is writable.
            </summary>
      <value>
        <c>true</c> if writable; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValue">
      <summary>
            Gets the default value.
            </summary>
      <value>The default value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Required">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.
            </summary>
      <value>A value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.IsReference">
      <summary>
            Gets a value indicating whether this property preserves object references.
            </summary>
      <value>
        <c>true</c> if this instance is reference; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.NullValueHandling">
      <summary>
            Gets the property null value handling.
            </summary>
      <value>The null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValueHandling">
      <summary>
            Gets the property default value handling.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ReferenceLoopHandling">
      <summary>
            Gets the property reference loop handling.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ObjectCreationHandling">
      <summary>
            Gets the property object creation handling.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.TypeNameHandling">
      <summary>
            Gets or sets the type name handling.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ShouldSerialize">
      <summary>
            Gets or sets a predicate used to determine whether the property should be serialize.
            </summary>
      <value>A predicate used to determine whether the property should be serialize.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.GetIsSpecified">
      <summary>
            Gets or sets a predicate used to determine whether the property should be serialized.
            </summary>
      <value>A predicate used to determine whether the property should be serialized.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.SetIsSpecified">
      <summary>
            Gets or sets an action used to set whether the property has been deserialized.
            </summary>
      <value>An action used to set whether the property has been deserialized.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonPropertyCollection">
      <summary>
            A collection of <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> objects.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPropertyCollection" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetKeyForItem(Newtonsoft.Json.Serialization.JsonProperty)">
      <summary>
            When implemented in a derived class, extracts the key from the specified element.
            </summary>
      <param name="item">The element from which to extract the key.</param>
      <returns>The key for the specified element.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.AddProperty(Newtonsoft.Json.Serialization.JsonProperty)">
      <summary>
            Adds a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            </summary>
      <param name="property">The property to add to the collection.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetClosestMatchProperty(System.String)">
      <summary>
            Gets the closest matching <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            First attempts to get an exact case match of propertyName and then
            a case insensitive match.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>A matching property if found.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetProperty(System.String,System.StringComparison)">
      <summary>
            Gets a property by property name.
            </summary>
      <param name="propertyName">The name of the property to get.</param>
      <param name="comparisonType">Type property name string comparison.</param>
      <returns>A matching property if found.</returns>
    </member>
    <member name="T:Newtonsoft.Json.MissingMemberHandling">
      <summary>
            Specifies missing member handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MissingMemberHandling.Ignore">
      <summary>
            Ignore a missing member and do not attempt to deserialize it.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MissingMemberHandling.Error">
      <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a missing member is encountered during deserialization.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.NullValueHandling">
      <summary>
            Specifies null value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.NullValueHandling.Include">
      <summary>
            Include null values when serializing and deserializing objects.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.NullValueHandling.Ignore">
      <summary>
            Ignore null values when serializing and deserializing objects.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.ReferenceLoopHandling">
      <summary>
            Specifies reference loop handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Error">
      <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a loop is encountered.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Ignore">
      <summary>
            Ignore loop references and do not serialize.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Serialize">
      <summary>
            Serialize loop references.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchema">
      <summary>
            An in-memory representation of a JSON Schema.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader)">
      <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the JSON Schema to read.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> object representing the JSON Schema.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the JSON Schema to read.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> to use when resolving schema references.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> object representing the JSON Schema.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from a string that contains schema JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Parses the specified json.
            </summary>
      <param name="json">The json.</param>
      <param name="resolver">The resolver.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter)">
      <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter" /> using the specified <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="resolver">The resolver used.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Id">
      <summary>
            Gets or sets the id.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Title">
      <summary>
            Gets or sets the title.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Required">
      <summary>
            Gets or sets whether the object is required.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ReadOnly">
      <summary>
            Gets or sets whether the object is read only.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Hidden">
      <summary>
            Gets or sets whether the object is visible to users.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Transient">
      <summary>
            Gets or sets whether the object is transient.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Description">
      <summary>
            Gets or sets the description of the object.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Type">
      <summary>
            Gets or sets the types of values allowed by the object.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Pattern">
      <summary>
            Gets or sets the pattern.
            </summary>
      <value>The pattern.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumLength">
      <summary>
            Gets or sets the minimum length.
            </summary>
      <value>The minimum length.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumLength">
      <summary>
            Gets or sets the maximum length.
            </summary>
      <value>The maximum length.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.DivisibleBy">
      <summary>
            Gets or sets a number that the value should be divisble by.
            </summary>
      <value>A number that the value should be divisble by.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Minimum">
      <summary>
            Gets or sets the minimum.
            </summary>
      <value>The minimum.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Maximum">
      <summary>
            Gets or sets the maximum.
            </summary>
      <value>The maximum.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMinimum">
      <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "minimum" attribute.
            </summary>
      <value>A flag indicating whether the value can not equal the number defined by the "minimum" attribute.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMaximum">
      <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "maximum" attribute.
            </summary>
      <value>A flag indicating whether the value can not equal the number defined by the "maximum" attribute.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumItems">
      <summary>
            Gets or sets the minimum number of items.
            </summary>
      <value>The minimum number of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumItems">
      <summary>
            Gets or sets the maximum number of items.
            </summary>
      <value>The maximum number of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Items">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of items.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Properties">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of properties.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AdditionalProperties">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional properties.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.PatternProperties">
      <summary>
            Gets or sets the pattern properties.
            </summary>
      <value>The pattern properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AllowAdditionalProperties">
      <summary>
            Gets or sets a value indicating whether additional properties are allowed.
            </summary>
      <value>
        <c>true</c> if additional properties are allowed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Requires">
      <summary>
            Gets or sets the required property if this property is present.
            </summary>
      <value>The required property if this property is present.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Identity">
      <summary>
            Gets or sets the identity.
            </summary>
      <value>The identity.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Enum">
      <summary>
            Gets or sets the a collection of valid enum values allowed.
            </summary>
      <value>A collection of valid enum values allowed.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Options">
      <summary>
            Gets or sets a collection of options.
            </summary>
      <value>A collection of options.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Disallow">
      <summary>
            Gets or sets disallowed types.
            </summary>
      <value>The disallow types.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Default">
      <summary>
            Gets or sets the default value.
            </summary>
      <value>The default value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Extends">
      <summary>
            Gets or sets the extend <see cref="T:Newtonsoft.Json.Schema.JsonSchema" />.
            </summary>
      <value>The extended <see cref="T:Newtonsoft.Json.Schema.JsonSchema" />.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Format">
      <summary>
            Gets or sets the format.
            </summary>
      <value>The format.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaGenerator">
      <summary>
            Generates a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from a specified <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> used to resolve schema references.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,System.Boolean)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> will be nullable.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver,System.Boolean)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> used to resolve schema references.</param>
      <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> will be nullable.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.UndefinedSchemaIdHandling">
      <summary>
            Gets or sets how undefined schemas are handled by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.ContractResolver">
      <summary>
            Gets or sets the contract resolver.
            </summary>
      <value>The contract resolver.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaType">
      <summary>
            The value types allowed by the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.None">
      <summary>
            No type specified.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.String">
      <summary>
            String type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Float">
      <summary>
            Float type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Integer">
      <summary>
            Integer type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Boolean">
      <summary>
            Boolean type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Object">
      <summary>
            Object type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Array">
      <summary>
            Array type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Null">
      <summary>
            Null type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Any">
      <summary>
            Any type.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonObjectContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonObjectContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.MemberSerialization">
      <summary>
            Gets or sets the object member serialization.
            </summary>
      <value>The member object serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.Properties">
      <summary>
            Gets the object's properties.
            </summary>
      <value>The object's properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ConstructorParameters">
      <summary>
            Gets the constructor parameters required for any non-default constructor
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.OverrideConstructor">
      <summary>
            Gets or sets the override constructor used to create the object.
            This is set when a constructor is marked up using the
            JsonConstructor attribute.
            </summary>
      <value>The override constructor.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ParametrizedConstructor">
      <summary>
            Gets or sets the parametrized constructor used to create the object.
            </summary>
      <value>The parametrized constructor.</value>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeDynamic(Newtonsoft.Json.JsonWriter,System.Dynamic.IDynamicMetaObjectProvider,Newtonsoft.Json.Serialization.JsonDynamicContract)">
      <summary>
            Serializes the dynamic.
            </summary>
      <param name="writer">The writer.</param>
      <param name="value">The value.</param>
      <param name="contract">The contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonStringContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonStringContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ReflectionValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using reflection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ReflectionValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.OnErrorAttribute">
      <summary>
            When applied to a method, specifies that the method is called when an error occurs serializing an object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodWithResult(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback,Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic that returns a result
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodReturnLast(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodNoResult(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.GetRestrictions">
      <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ObjectConstructor`1">
      <summary>
            Represents a method that constructs an object.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.TypeNameHandling">
      <summary>
            Specifies type name handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.None">
      <summary>
            Do not include the .NET type name when serializing types.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Objects">
      <summary>
            Include the .NET type name when serializing into a JSON object structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Arrays">
      <summary>
            Include the .NET type name when serializing into a JSON array structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Auto">
      <summary>
            Include the .NET type name when the type of the object being serialized is not the same as its declared type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.All">
      <summary>
            Always include the .NET type name when serializing.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.Convert``1(System.Object)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <typeparam name="T">The type to convert the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <returns>The converted type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.Convert``1(System.Object,System.Globalization.CultureInfo)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <typeparam name="T">The type to convert the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <returns>The converted type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.Convert(System.Object,System.Globalization.CultureInfo,System.Type)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert the value to.</param>
      <returns>The converted type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvert``1(System.Object,``0@)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <typeparam name="T">The type to convert the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
      <returns>
        <c>true</c> if <c>initialValue</c> was converted successfully; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvert``1(System.Object,System.Globalization.CultureInfo,``0@)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <typeparam name="T">The type to convert the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
      <returns>
        <c>true</c> if <c>initialValue</c> was converted successfully; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvert(System.Object,System.Globalization.CultureInfo,System.Type,System.Object@)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert the value to.</param>
      <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
      <returns>
        <c>true</c> if <c>initialValue</c> was converted successfully; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast``1(System.Object)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <typeparam name="T">The type to convert or cast the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <returns>The converted type. If conversion was unsuccessful, the initial value is returned if assignable to the target type</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast``1(System.Object,System.Globalization.CultureInfo)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <typeparam name="T">The type to convert or cast the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <returns>The converted type. If conversion was unsuccessful, the initial value is returned if assignable to the target type</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(System.Object,System.Globalization.CultureInfo,System.Type)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert or cast the value to.</param>
      <returns>
            The converted type. If conversion was unsuccessful, the initial value
            is returned if assignable to the target type.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvertOrCast``1(System.Object,``0@)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <typeparam name="T">The type to convert the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
      <returns>
        <c>true</c> if <c>initialValue</c> was converted successfully or is assignable; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvertOrCast``1(System.Object,System.Globalization.CultureInfo,``0@)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <typeparam name="T">The type to convert the value to.</typeparam>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
      <returns>
        <c>true</c> if <c>initialValue</c> was converted successfully or is assignable; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvertOrCast(System.Object,System.Globalization.CultureInfo,System.Type,System.Object@)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert the value to.</param>
      <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
      <returns>
        <c>true</c> if <c>initialValue</c> was converted successfully or is assignable; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.Parse``1(System.String)">
      <summary>
            Parses the specified enum member name, returning it's value.
            </summary>
      <param name="enumMemberName">Name of the enum member.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.Parse``1(System.String,System.Boolean)">
      <summary>
            Parses the specified enum member name, returning it's value.
            </summary>
      <param name="enumMemberName">Name of the enum member.</param>
      <param name="ignoreCase">If set to <c>true</c> ignore case.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1">
      <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``2">
      <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1(System.Type)">
      <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
      <param name="enumType">The enum type to get names and values for.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetMaximumValue``1(System.Type)">
      <summary>
            Gets the maximum valid value of an Enum type. Flags enums are ORed.
            </summary>
      <typeparam name="TEnumType">The type of the returned value. Must be assignable from the enum's underlying value type.</typeparam>
      <param name="enumType">The enum type to get the maximum value for.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Newtonsoft.Json.JsonToken">
      <summary>
            Specifies the type of Json token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.None">
      <summary>
            This is returned by the <see cref="T:Newtonsoft.Json.JsonReader" /> if a <see cref="M:Newtonsoft.Json.JsonReader.Read" /> method has not been called. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartObject">
      <summary>
            An object start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartArray">
      <summary>
            An array start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartConstructor">
      <summary>
            A constructor start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.PropertyName">
      <summary>
            An object property name.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Comment">
      <summary>
            A comment.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Raw">
      <summary>
            Raw JSON.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Integer">
      <summary>
            An interger.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Float">
      <summary>
            A float.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.String">
      <summary>
            A string.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Boolean">
      <summary>
            A boolean.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Null">
      <summary>
            A null token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Undefined">
      <summary>
            An undefined token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndObject">
      <summary>
            An object end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndArray">
      <summary>
            An array end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndConstructor">
      <summary>
            A constructor end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Date">
      <summary>
            A Date.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Bytes">
      <summary>
            Byte data.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.WriteState">
      <summary>
            Specifies the state of the <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Error">
      <summary>
            An exception has been thrown, which has left the <see cref="T:Newtonsoft.Json.JsonWriter" /> in an invalid state.
            You may call the <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method to put the <see cref="T:Newtonsoft.Json.JsonWriter" /> in the <c>Closed</c> state.
            Any other <see cref="T:Newtonsoft.Json.JsonWriter" /> method calls results in an <see cref="T:System.InvalidOperationException" /> being thrown. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Closed">
      <summary>
            The <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method has been called. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Object">
      <summary>
            An object is being written. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Array">
      <summary>
            A array is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Constructor">
      <summary>
            A constructor is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Property">
      <summary>
            A property is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Start">
      <summary>
            A write method has not been called.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Formatting">
      <summary>
            Specifies formatting options for the <see cref="T:Newtonsoft.Json.JsonTextWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Formatting.None">
      <summary>
            No special formatting is applied. This is the default.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Formatting.Indented">
      <summary>
            Causes child objects to be indented according to the <see cref="P:Newtonsoft.Json.JsonTextWriter.Indentation" /> and <see cref="P:Newtonsoft.Json.JsonTextWriter.IndentChar" /> settings.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Utilities.StringBuffer">
      <summary>
            Builds a string. Unlike StringBuilder this class lets you reuse it's internal buffer.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IsNullOrEmpty(System.Collections.ICollection)">
      <summary>
            Determines whether the collection is null or empty.
            </summary>
      <param name="collection">The collection.</param>
      <returns>
        <c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Determines whether the collection is null or empty.
            </summary>
      <param name="collection">The collection.</param>
      <returns>
        <c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IsNullOrEmptyOrDefault``1(System.Collections.Generic.IList{``0})">
      <summary>
            Determines whether the collection is null, empty or its contents are uninitialized values.
            </summary>
      <param name="list">The list.</param>
      <returns>
        <c>true</c> if the collection is null or empty or its contents are uninitialized values; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.Slice``1(System.Collections.Generic.IList{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
      <summary>
            Makes a slice of the specified list in between the start and end indexes.
            </summary>
      <param name="list">The list.</param>
      <param name="start">The start index.</param>
      <param name="end">The end index.</param>
      <returns>A slice of the list.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.Slice``1(System.Collections.Generic.IList{``0},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
      <summary>
            Makes a slice of the specified list in between the start and end indexes,
            getting every so many items based upon the step.
            </summary>
      <param name="list">The list.</param>
      <param name="start">The start index.</param>
      <param name="end">The end index.</param>
      <param name="step">The step.</param>
      <returns>A slice of the list.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.GroupBy``2(System.Collections.Generic.ICollection{``1},System.Func{``1,``0})">
      <summary>
            Group the collection using a function which returns the key.
            </summary>
      <param name="source">The source collection to group.</param>
      <param name="keySelector">The key selector.</param>
      <returns>A Dictionary with each key relating to a list of objects in a list grouped under it.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds the elements of the specified collection to the specified generic IList.
            </summary>
      <param name="initial">The list to add to.</param>
      <param name="collection">The collection of elements to add.</param>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Returns the index of the first occurrence in a sequence by using the default equality comparer.
            </summary>
      <typeparam name="TSource">The type of the elements of source.</typeparam>
      <param name="list">A sequence in which to locate a value.</param>
      <param name="value">The object to locate in the sequence</param>
      <returns>The zero-based index of the first occurrence of value within the entire sequence, if found; otherwise, –1.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Returns the index of the first occurrence in a sequence by using a specified IEqualityComparer.
            </summary>
      <typeparam name="TSource">The type of the elements of source.</typeparam>
      <param name="list">A sequence in which to locate a value.</param>
      <param name="value">The object to locate in the sequence</param>
      <param name="comparer">An equality comparer to compare values.</param>
      <returns>The zero-based index of the first occurrence of value within the entire sequence, if found; otherwise, –1.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetCollectionItemType(System.Type)">
      <summary>
            Gets the type of the typed collection's items.
            </summary>
      <param name="type">The type.</param>
      <returns>The type of the typed collection's items.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.ItemsUnitializedValue``1(System.Collections.Generic.IList{``0})">
      <summary>
            Tests whether the list's items are their unitialized value.
            </summary>
      <param name="list">The list.</param>
      <returns>Whether the list's items are their unitialized value</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(System.Reflection.MemberInfo)">
      <summary>
            Gets the member's underlying type.
            </summary>
      <param name="member">The member.</param>
      <returns>The underlying type of the member.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.MemberInfo)">
      <summary>
            Determines whether the member is an indexed property.
            </summary>
      <param name="member">The member.</param>
      <returns>
        <c>true</c> if the member is an indexed property; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.PropertyInfo)">
      <summary>
            Determines whether the property is an indexed property.
            </summary>
      <param name="property">The property.</param>
      <returns>
        <c>true</c> if the property is an indexed property; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberValue(System.Reflection.MemberInfo,System.Object)">
      <summary>
            Gets the member's value on the object.
            </summary>
      <param name="member">The member.</param>
      <param name="target">The target object.</param>
      <returns>The member's value on the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.SetMemberValue(System.Reflection.MemberInfo,System.Object,System.Object)">
      <summary>
            Sets the member's value on the target object.
            </summary>
      <param name="member">The member.</param>
      <param name="target">The target.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanReadMemberValue(System.Reflection.MemberInfo,System.Boolean)">
      <summary>
            Determines whether the specified MemberInfo can be read.
            </summary>
      <param name="member">The MemberInfo to determine whether can be read.</param>
            /// <param name="nonPublic">if set to <c>true</c> then allow the member to be gotten non-publicly.</param><returns><c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
            </returns></member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanSetMemberValue(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
      <summary>
            Determines whether the specified MemberInfo can be set.
            </summary>
      <param name="member">The MemberInfo to determine whether can be set.</param>
      <param name="nonPublic">if set to <c>true</c> then allow the member to be set non-publicly.</param>
      <param name="canSetReadOnly">if set to <c>true</c> then allow the member to be set if read-only.</param>
      <returns>
        <c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.ContainsWhiteSpace(System.String)">
      <summary>
            Determines whether the string contains white space.
            </summary>
      <param name="s">The string to test for white space.</param>
      <returns>
        <c>true</c> if the string contains white space; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.IsWhiteSpace(System.String)">
      <summary>
            Determines whether the string is all white space. Empty string will return false.
            </summary>
      <param name="s">The string to test whether it is all white space.</param>
      <returns>
        <c>true</c> if the string is all white space; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.EnsureEndsWith(System.String,System.String)">
      <summary>
            Ensures the target string ends with the specified string.
            </summary>
      <param name="target">The target.</param>
      <param name="value">The value.</param>
      <returns>The target string with the value string at the end.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.IfNotNullOrEmpty(System.String,System.Action{System.String})">
      <summary>
            Perform an action if the string is not null or empty.
            </summary>
      <param name="value">The value.</param>
      <param name="action">The action to perform.</param>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.Indent(System.String,System.Int32)">
      <summary>
            Indents the specified string.
            </summary>
      <param name="s">The string to indent.</param>
      <param name="indentation">The number of characters to indent by.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.Indent(System.String,System.Int32,System.Char)">
      <summary>
            Indents the specified string.
            </summary>
      <param name="s">The string to indent.</param>
      <param name="indentation">The number of characters to indent by.</param>
      <param name="indentChar">The indent character.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.NumberLines(System.String)">
      <summary>
            Numbers the lines.
            </summary>
      <param name="s">The string to number.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.NullEmptyString(System.String)">
      <summary>
            Nulls an empty string.
            </summary>
      <param name="s">The string.</param>
      <returns>Null if the string was null, otherwise the string unchanged.</returns>
    </member>
  </members>
</doc>