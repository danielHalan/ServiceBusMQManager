<?xml version="1.0"?>
<doc>
  <assembly>
    <name>MassTransit</name>
  </assembly>
  <members>
    <member name="T:MassTransit.Bus">
      <summary>
            This is a static singleton instance of an IServiceBus. While it goes
            against my very soul, it is here to ensure consistent usage of MassTransit
            as a singleton. It is highly recommended that <see cref="M:MassTransit.ServiceBusFactory.New(System.Action{MassTransit.BusConfigurators.ServiceBusConfigurator})" /> be
            used instead and the application maintain the reference to the IServiceBus.
            </summary>
    </member>
    <member name="M:MassTransit.Bus.Initialize(System.Action{MassTransit.BusConfigurators.ServiceBusConfigurator})">
      <summary>
            Call to initialize the service bus instance, including any configuration.
            </summary>
      <param name="configure">A lambda/action that does the bus configugration.</param>
      <exception cref="T:MassTransit.Exceptions.ConfigurationException">
            If the bus has already been initialized by a call
            to this method.</exception>
    </member>
    <member name="M:MassTransit.Bus.Shutdown">
      <summary>
            Shuts down the service bus and disposes any used resources
            </summary>
    </member>
    <member name="P:MassTransit.Bus.Instance">
      <summary>
            The configured instance of the service bus.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            If you call this method before you call
            <see cref="M:MassTransit.Bus.Initialize(System.Action{MassTransit.BusConfigurators.ServiceBusConfigurator})" />.
            </exception>
    </member>
    <member name="M:MassTransit.Advanced.EnvironmentExtensions.Add``1(MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator)">
      <summary>
            Add an environment to the configuration
            </summary>
      <typeparam name="TEnvironment">The environment class to add</typeparam>
      <param name="configurator">
      </param>
    </member>
    <member name="M:MassTransit.Advanced.EnvironmentExtensions.Add``1(MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator,``0)">
      <summary>
            Add an environment to the configuration
            </summary>
      <typeparam name="TEnvironment">The environment class to add</typeparam>
      <param name="configurator">
      </param>
      <param name="environment">The environment instance already created and ready to use</param>
    </member>
    <member name="M:MassTransit.Advanced.EnvironmentExtensions.Add``1(MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator,System.Func{``0})">
      <summary>
            Add an environment to the configuration
            </summary>
      <typeparam name="TEnvironment">The environment class to add</typeparam>
      <param name="configurator">
      </param>
      <param name="environmentFactory">The factory method to create the environment instance</param>
    </member>
    <member name="M:MassTransit.Advanced.EnvironmentExtensions.SelectByAppSetting(MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator,System.String)">
      <summary>
            Selects the current environment using an application setting from the App.config/Web.config
            </summary>
      <param name="configurator">
      </param>
      <param name="settingName">
      </param>
    </member>
    <member name="M:MassTransit.Advanced.EnvironmentExtensions.SelectByEnvironmentVariable(MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator,System.String)">
      <summary>
            Selects the current environment using an environment variable from the current process
            </summary>
      <param name="configurator">
      </param>
      <param name="valueName">
      </param>
    </member>
    <member name="M:MassTransit.Advanced.EnvironmentExtensions.SelectByMachineName(MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator)">
      <summary>
            Selects the current environment using the local machine name
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="T:MassTransit.Builders.BusBuilder">
      <summary>
            A BusBuilder is the base interface for building service, and includes things like
            control bus, subscription bus, and other limited-functionality bus instances
            </summary>
    </member>
    <member name="M:MassTransit.Builders.BusBuilder.Build">
      <summary>
            Builds the bus instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Builders.BusBuilder.AddPostCreateAction(System.Action{MassTransit.ServiceBus})">
      <summary>
            Adds an action to be performed after bus creation to adjust settings, etc.
            but before the bus is started.
            </summary>
      <param name="postCreateAction">
      </param>
    </member>
    <member name="M:MassTransit.Builders.BusBuilder.AddBusServiceConfigurator(MassTransit.BusServiceConfigurators.BusServiceConfigurator)">
      <summary>
            Adds a bus service that will be started and stopped with the service bus 
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="M:MassTransit.Builders.BusBuilder.Match``1(System.Action{``0})">
      <summary>
            Used to match a builder with a specific type, to allow customization of class properties
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="callback">
      </param>
    </member>
    <member name="P:MassTransit.Builders.BusBuilder.Settings">
      <summary>
            The settings to creating the bus, including address, etc.
            </summary>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.Build">
      <summary>
            Create the endpoint factory
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetDefaultSerializer(MassTransit.Serialization.IMessageSerializer)">
      <summary>
            Sets the default serializer used for endpoints
            </summary>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetDefaultTransactionTimeout(System.TimeSpan)">
      <summary>
            Sets the default transaction timeout for transactional queue operations
            </summary>
      <param name="transactionTimeout">
      </param>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetCreateMissingQueues(System.Boolean)">
      <summary>
            Sets the flag indicating that missing queues should be created
            </summary>
      <param name="createMissingQueues">
      </param>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetCreateTransactionalQueues(System.Boolean)">
      <summary>
            When creating queues, attempt to create transactional queues if available
            </summary>
      <param name="createTransactionalQueues">
      </param>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetPurgeOnStartup(System.Boolean)">
      <summary>
            Specifies if the input queue should be purged on startup
            </summary>
      <param name="purgeOnStartup">
      </param>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.AddEndpointBuilder(System.Uri,MassTransit.Builders.EndpointBuilder)">
      <summary>
            Provides a configured endpoint builder for the specified URI
            </summary>
      <param name="uri">
      </param>
      <param name="endpointBuilder">
      </param>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.AddTransportFactory(MassTransit.Transports.ITransportFactory)">
      <summary>
            Adds a transport factory to the builder
            </summary>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.AddMessageSerializer(MassTransit.Serialization.IMessageSerializer)">
      <summary>
            Add a message serializer to the builder so that messages with other serialization types
            can be received without conflicts
            </summary>
      <param name="serializer">
      </param>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetDefaultIsolationLevel(System.Transactions.IsolationLevel)">
      <summary>
            Sets the default isolation level for transports that perform transactional operations
            </summary>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetDefaultRetryLimit(System.Int32)">
      <summary>
            Sets the default retry limit for inbound messages
            </summary>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetDefaultInboundMessageTrackerFactory(MassTransit.Transports.MessageTrackerFactory)">
      <summary>
            Sets the default message tracker factory for all endpoints
            </summary>
    </member>
    <member name="M:MassTransit.Builders.EndpointFactoryBuilder.SetSupportedMessageSerializers(MassTransit.Serialization.ISupportedMessageSerializers)">
      <summary>
            Sets the supported message serializers for all endpoints
            </summary>
    </member>
    <member name="T:MassTransit.Builders.ServiceBusBuilder">
      <summary>
            A ServiceBusBuilder includes everything for configuring a complete service bus instance,
            and is an extension of the BusBuilder (which can only build a limited, dependent bus)
            </summary>
    </member>
    <member name="M:MassTransit.Builders.ServiceBusBuilder.UseControlBus(MassTransit.IControlBus)">
      <summary>
            Specifies a control bus to associate with the service bus once created
            </summary>
      <param name="controlBus">
      </param>
    </member>
    <member name="M:MassTransit.Advanced.AdvancedBusConfiguratorExtensions.SetConcurrentReceiverLimit(MassTransit.BusConfigurators.ServiceBusConfigurator,System.Int32)">
      <summary>
            Sets the number of concurrent receive threads that can execute simultaneously. In many cases, such as when
            using non-transactional transports, this can lead to very-bad-things(TM)
            </summary>
      <param name="configurator">
      </param>
      <param name="concurrentReceiverLimit">
      </param>
    </member>
    <member name="M:MassTransit.Advanced.AdvancedBusConfiguratorExtensions.SetReceiveTimeout(MassTransit.BusConfigurators.ServiceBusConfigurator,System.TimeSpan)">
      <summary>
            Sets the receive timeout on the service bus endpoint receiver. Settings this to a lower value has limited
            benefit other than in unit testing to reduce bus disposal time
            </summary>
      <param name="configurator">
      </param>
      <param name="receiveTimeout">
      </param>
    </member>
    <member name="T:MassTransit.Configurators.Configurator">
      <summary>
            Base interface for all MassTransit configurators. This interface only
            contains a method for validating the validity of the configuration.
            </summary>
    </member>
    <member name="M:MassTransit.Configurators.Configurator.Validate">
      <summary>
            Validate the configuration of this configurator, to make sure
            that you haven't done silly mistakes.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.InterceptorExtensions.AddInboundInterceptor(MassTransit.BusConfigurators.ServiceBusConfigurator,MassTransit.IInboundMessageInterceptor)">
      <summary>
            Adds an inbound message interceptor to the bus configuration
            </summary>
      <param name="configurator">
      </param>
      <param name="interceptor">
      </param>
    </member>
    <member name="M:MassTransit.EndpointExtensions.Forward``1(MassTransit.IEndpoint,MassTransit.IConsumeContext,``0)">
      <summary>
            Forwards the message to the endpoint
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="endpoint">The destination endpoint to which the message should be sent</param>
      <param name="context">The message context</param>
      <param name="message">The message to forward to the endpoint</param>
    </member>
    <member name="M:MassTransit.EndpointExtensions.Forward``1(MassTransit.IEndpoint,MassTransit.IConsumeContext{``0})">
      <summary>
            Forwards the message to the endpoint
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="endpoint">The destination endpoint to which the message should be sent</param>
      <param name="context">The message context</param>
    </member>
    <member name="P:MassTransit.IFault.FaultType">
      <summary>
            The type of fault that occurred
            </summary>
    </member>
    <member name="P:MassTransit.IFault.Messages">
      <summary>
            Messages associated with the exception
            </summary>
    </member>
    <member name="P:MassTransit.IFault.OccurredAt">
      <summary>
            When the exception occurred
            </summary>
    </member>
    <member name="P:MassTransit.IFault.StackTrace">
      <summary>
            A stack trace related to the exception
            </summary>
    </member>
    <member name="T:MassTransit.Serialization.ISupportedMessageSerializers">
      <summary>
            The supported message serializers contains an implementation for each contentType
            </summary>
    </member>
    <member name="M:MassTransit.Serialization.ISupportedMessageSerializers.TryGetSerializer(System.String,MassTransit.Serialization.IMessageSerializer@)">
      <summary>
            Try to return a message serializer for the content type specified
            </summary>
      <param name="contentType">The content type string from the transport header</param>
      <param name="serializer">The serializer</param>
      <returns>True if the serializer was found, otherwise false</returns>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.SubscriptionStorage.Load(System.Uri)">
      <summary>
            Load the existing subscriptions for the specified BusUri
            </summary>
      <param name="busUri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.IConsumerFactory`1">
      <summary>
            Maps an instance of a consumer to one or more Consume methods for the specified message type
            
            The whole purpose for this interface is to allow the creator of the consumer to manage the lifecycle
            of the consumer, along with anything else that needs to be managed by the factory, container, etc.
            </summary>
      <typeparam name="TConsumer">The Consumer type</typeparam>
    </member>
    <member name="M:MassTransit.IConsumerFactory`1.GetConsumer``1(MassTransit.IConsumeContext{``0},MassTransit.Pipeline.InstanceHandlerSelector{`0,``0})">
      <summary>
            Returns the Consume actions for the Consumer that should handle the specified message type
            </summary>
      <typeparam name="TMessage">The type of message being handled</typeparam>
      <param name="context">The context of the message being handled</param>
      <param name="selector">The selector to obtain the handlers from the consumer instance</param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.SubscriptionConnectors.MessageInterfaceTypeReflector`1">
      <summary>
            Helper class for providing the message reflection for consumers.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:MassTransit.IntrospectionExtensions.Probe(MassTransit.IServiceBus)">
      <summary>
            A convenience method for inspecting an active service bus instance.
            </summary>
    </member>
    <member name="T:MassTransit.BusServiceLayer">
      <summary>
            The layer of the service, which controls the order in which it is started and stopped
            </summary>
    </member>
    <member name="F:MassTransit.BusServiceLayer.Network">
      <summary>
            The lowest level, and includes things that sit just above transports
            </summary>
    </member>
    <member name="F:MassTransit.BusServiceLayer.Session">
      <summary>
            The next level, which includes subscription, timeout, health, and other services that must
            be running before the application can start.
            </summary>
    </member>
    <member name="F:MassTransit.BusServiceLayer.Presentation">
      <summary>
            The next level, which includes services that sit on top of the session services but not yet
            application level services, such as the distributor and workers
            </summary>
    </member>
    <member name="F:MassTransit.BusServiceLayer.Application">
      <summary>
            The highest level, which includes an application level services, such as subscriptions
            </summary>
    </member>
    <member name="T:MassTransit.Configuration.BusSettings">
      <summary>
            Interface with bus settings. Each bus needs to have its own settings,
            and you may have multiple buses with different sets of settings, active,
            at any given point in time of your application.
            </summary>
    </member>
    <member name="T:MassTransit.IInboundMessageInterceptor">
      <summary>
            Implementations can be added to the inbound message pipeline to intercept
            messages before they are delivered to any consumers.
            </summary>
    </member>
    <member name="M:MassTransit.IInboundMessageInterceptor.PreDispatch(MassTransit.IConsumeContext)">
      <summary>
            Called before the message is dispatched to the next handler in the pipeline
            </summary>
      <param name="context">The context of the message being dispatched</param>
    </member>
    <member name="M:MassTransit.IInboundMessageInterceptor.PostDispatch(MassTransit.IConsumeContext)">
      <summary>
            Calls after the message has been dispatched through the pipeline
            </summary>
      <param name="context">The context of the message being dispatched</param>
    </member>
    <member name="T:MassTransit.Configuration.IServiceBusEnvironment">
      <summary>
            Environments are used to execute environment specific configuration based
            on the selection of an active environment by some external configuration.
            </summary>
    </member>
    <member name="M:MassTransit.Configuration.IServiceBusEnvironment.Configure(MassTransit.BusConfigurators.ServiceBusConfigurator)">
      <summary>
            Called by MassTransit when the implementation class name matches the environment
            name that is specified.
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="T:MassTransit.Configurators.ValidationResult">
      <summary>
            Reports information about the configuration before configuring
            so that corrections can be made without allocating resources, etc.
            </summary>
    </member>
    <member name="P:MassTransit.Configurators.ValidationResult.Disposition">
      <summary>
            The disposition of the result, any Failure items will prevent
            the configuration from completing.
            </summary>
    </member>
    <member name="P:MassTransit.Configurators.ValidationResult.Message">
      <summary>
            The message associated with the result
            </summary>
    </member>
    <member name="P:MassTransit.Configurators.ValidationResult.Key">
      <summary>
            The key associated with the result (chained if configurators are nested)
            </summary>
    </member>
    <member name="P:MassTransit.Configurators.ValidationResult.Value">
      <summary>
            The value associated with the result
            </summary>
    </member>
    <member name="M:MassTransit.BusServiceConfigurators.BusServiceConfigurator.Create(MassTransit.IServiceBus)">
      <summary>
            Creates the service
            </summary>
      <param name="bus">
      </param>
      <returns>The instance of the service</returns>
    </member>
    <member name="P:MassTransit.BusServiceConfigurators.BusServiceConfigurator.ServiceType">
      <summary>
            Returns the type of the service created by the configurator
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurationExtensions.ConfigureEndpoint``1(``0,System.String)">
      <summary>
            Returns a configurator for the specified endpoint URI
            </summary>
      <param name="configurator">
      </param>
      <param name="uriString">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurationExtensions.ConfigureEndpoint``1(``0,System.Uri)">
      <summary>
            Returns a configurator for the specified endpoint URI
            </summary>
      <param name="configurator">
      </param>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurationExtensions.ConfigureEndpoint``1(``0,System.String,System.Action{MassTransit.EndpointConfigurators.EndpointConfigurator})">
      <summary>
            Configures the endpoint for the specified endpoint URI
            </summary>
      <param name="configurator">
      </param>
      <param name="uriString">
      </param>
      <param name="configureCallback">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurationExtensions.ConfigureEndpoint``1(``0,System.Uri,System.Action{MassTransit.EndpointConfigurators.EndpointConfigurator})">
      <summary>
            Configures the endpoint for the specified URI
            </summary>
      <param name="configurator">
      </param>
      <param name="uri">
      </param>
      <param name="configureCallback">
      </param>
    </member>
    <member name="M:MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator.Add(System.String,System.Func{MassTransit.Configuration.IServiceBusEnvironment})">
      <summary>
            Add an environment to the configuration
            </summary>
      <param name="environmentName">The name of the environment</param>
      <param name="environmentFactory">The factory to create the environment class instance</param>
    </member>
    <member name="M:MassTransit.EnvironmentConfigurators.EnvironmentsConfigurator.Select(System.String)">
      <summary>
            Selects the current environment, which determines the environment class(es) that will be executed.
            </summary>
      <param name="environmentName">The name of the current environment</param>
    </member>
    <member name="M:MassTransit.HandlerSubscriptionExtensions.Handler``1(MassTransit.SubscriptionConfigurators.SubscriptionBusServiceConfigurator,System.Action{``0})">
      <summary>
            Subscribes a message handler (which can be any delegate of the message type,
            such as a class instance method, a delegate, or a lambda expression)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="configurator">
      </param>
      <param name="handler">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.HandlerSubscriptionExtensions.SubscribeHandler``1(MassTransit.IServiceBus,System.Action{``0})">
      <summary>
            Adds a message handler to the service bus for handling a specific type of message
            </summary>
      <typeparam name="T">The message type to handle, often inferred from the callback specified</typeparam>
      <param name="bus">
      </param>
      <param name="handler">The callback to invoke when messages of the specified type arrive on the service bus</param>
    </member>
    <member name="M:MassTransit.HandlerSubscriptionExtensions.SubscribeContextHandler``1(MassTransit.IServiceBus,System.Action{MassTransit.IConsumeContext{``0}})">
      <summary>
            Adds a message handler to the service bus for handling a specific type of message
            </summary>
      <typeparam name="T">The message type to handle, often inferred from the callback specified</typeparam>
      <param name="bus">
      </param>
      <param name="handler">The callback to invoke when messages of the specified type arrive on the service bus</param>
    </member>
    <member name="M:MassTransit.HandlerSubscriptionExtensions.SubscribeHandler``1(MassTransit.IServiceBus,System.Action{``0},System.Predicate{``0})">
      <summary>
            Adds a message handler to the service bus for handling a specific type of message
            </summary>
      <typeparam name="T">The message type to handle, often inferred from the callback specified</typeparam>
      <param name="bus">
      </param>
      <param name="handler">The callback to invoke when messages of the specified type arrive on the service bus</param>
      <param name="condition">
      </param>
    </member>
    <member name="M:MassTransit.HandlerSubscriptionExtensions.SubscribeHandlerSelector``1(MassTransit.IServiceBus,MassTransit.Pipeline.HandlerSelector{``0})">
      <summary>
            Adds a message handler to the service bus for handling a specific type of message
            </summary>
      <typeparam name="T">The message type to handle, often inferred from the callback specified</typeparam>
      <param name="bus">
      </param>
      <param name="handler">The callback to invoke when messages of the specified type arrive on the service bus</param>
    </member>
    <member name="T:MassTransit.InstanceSubscriptionExtensions">
      <summary>
            Extensions for subscribing object instances.
            </summary>
    </member>
    <member name="M:MassTransit.InstanceSubscriptionExtensions.Instance(MassTransit.SubscriptionConfigurators.SubscriptionBusServiceConfigurator,System.Object)">
      <summary>
            Subscribes an object instance to the bus
            </summary>
      <param name="configurator">Service Bus Service Configurator 
            - the item that is passed as a parameter to
            the action that is calling the configurator.</param>
      <param name="instance">The instance to subscribe.</param>
      <returns>An instance subscription configurator.</returns>
    </member>
    <member name="M:MassTransit.InstanceSubscriptionExtensions.SubscribeInstance(MassTransit.IServiceBus,System.Object)">
      <summary>
            Connects any consumers for the component to the message dispatcher
            </summary>
      <param name="bus">The service bus to configure</param>
      <param name="instance">
      </param>
      <returns>The unsubscribe action that can be called to unsubscribe the instance
            passed as an argument.</returns>
    </member>
    <member name="M:MassTransit.InstanceSubscriptionExtensions.SubscribeInstance``1(MassTransit.IServiceBus,``0)">
      <summary>
            Connects any consumers for the component to the message dispatcher
            </summary>
      <typeparam name="T">The consumer type</typeparam>
      <param name="bus">The service bus instance to call this method on.</param>
      <param name="instance">The instance to subscribe.</param>
      <returns>The unsubscribe action that can be called to unsubscribe the instance
            passed as an argument.</returns>
    </member>
    <member name="M:MassTransit.SubscriptionBuilders.SubscriptionBusServiceBuilder.AddSubscriptionBuilder(MassTransit.SubscriptionBuilders.SubscriptionBuilder)">
      <summary>
            Add a subscription builder to the service so that it is subscribed when
            the bus is started.
            </summary>
      <param name="builder">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryDefaultSettingsConfigurator.SetDefaultSerializer(MassTransit.Serialization.IMessageSerializer)">
      <summary>
            Sets the default serializer used for endpoints
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryDefaultSettingsConfigurator.SetDefaultTransactionTimeout(System.TimeSpan)">
      <summary>
            Sets the default transaction timeout for transactional queue operations
            </summary>
      <param name="transactionTimeout">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryDefaultSettingsConfigurator.SetCreateMissingQueues(System.Boolean)">
      <summary>
            Sets the flag indicating that missing queues should be created
            </summary>
      <param name="createMissingQueues">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryDefaultSettingsConfigurator.SetCreateTransactionalQueues(System.Boolean)">
      <summary>
            When creating queues, attempt to create transactional queues if available
            </summary>
      <param name="createTransactionalQueues">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryDefaultSettingsConfigurator.SetPurgeOnStartup(System.Boolean)">
      <summary>
            Specifies if the input queue should be purged on startup
            </summary>
      <param name="purgeOnStartup">
      </param>
    </member>
    <member name="T:MassTransit.BusConfigurators.BusBuilderConfigurator">
      <summary>
            A thing that configures the thing that builds the bus.
            </summary>
    </member>
    <member name="M:MassTransit.BusConfigurators.BusBuilderConfigurator.Configure(MassTransit.Builders.BusBuilder)">
      <summary>
            Pays the bus builder a visit and return a new builder
            that is correctly configured.
            </summary>
      <param name="builder">The bus builder</param>
      <returns>An updated builder.</returns>
    </member>
    <member name="M:MassTransit.BusConfigurators.ControlBusConfigurator.ReceiveFrom(System.Uri)">
      <summary>
            Specify the endpoint from which messages should be read
            </summary>
      <param name="uri">The uri of the endpoint</param>
    </member>
    <member name="T:MassTransit.EndpointConfigurators.EndpointConfigurator">
      <summary>
            Configure the endpoint
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.UseSerializer(MassTransit.Serialization.IMessageSerializer)">
      <summary>
            Specify a serializer for this endpoint (overrides the default)
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.UseSupportedSerializers(MassTransit.Serialization.ISupportedMessageSerializers)">
      <summary>
            Specify the supported serializers for this endpoint (overrides the defaults)
            </summary>
      <param name="serializers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.SetErrorAddress(System.Uri)">
      <summary>
            Overrides the default error address with a new error address
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.SetTransportFactory(MassTransit.Builders.DuplexTransportFactory)">
      <summary>
            Overrides the transport factory when the error transport is created, to modify the behavior
            </summary>
      <param name="transportFactory">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.SetErrorTransportFactory(MassTransit.Builders.OutboundTransportFactory)">
      <summary>
            Overrides the transport factory when the error transport is created, to modify the behavior
            </summary>
      <param name="errorTransportFactory">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.PurgeExistingMessages">
      <summary>
            Remove any existing messages from the endpoint when it is created
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.CreateTransactional">
      <summary>
            Creates the endpoint as transactional if it needs to be created
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.CreateIfMissing">
      <summary>
            Creates the endpoint if it is missing
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.SetMessageRetryLimit(System.Int32)">
      <summary>
            Set the retry limit for inbound messages in the event of an exception
            </summary>
      <param name="retryLimit">The number of attempts to process the inbound message</param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.SetInboundMessageTrackerFactory(MassTransit.Transports.MessageTrackerFactory)">
      <summary>
            Overrides the default message tracker with a custom factory provider
            </summary>
      <param name="messageTrackerFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.SetTransactionTimeout(System.TimeSpan)">
      <summary>
            Sets the transaction timeout for the endpoint
            </summary>
      <param name="timeout">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointConfigurator.SetIsolationLevel(System.Transactions.IsolationLevel)">
      <summary>
            Sets the isolation level for the endpoint if it is transactional
            </summary>
      <param name="isolationLevel">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.EndpointConfigurators.EndpointFactoryConfigurator">
      <summary>
            Allows for the configuration of the EndpointFactory through the use of an EndpointFactoryConfigurator
            </summary>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryConfigurator.CreateEndpointFactory">
      <summary>
            Creates the endpoint factory with the configuration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryConfigurator.UseEndpointFactoryBuilder(System.Func{MassTransit.EndpointConfigurators.IEndpointFactoryDefaultSettings,MassTransit.Builders.EndpointFactoryBuilder})">
      <summary>
            Overrides the default EndpointResolver builder with another builder
            </summary>
      <param name="endpointFactoryBuilderFactory">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfigurators.EndpointFactoryConfigurator.AddEndpointFactoryConfigurator(MassTransit.EndpointConfigurators.EndpointFactoryBuilderConfigurator)">
      <summary>
            Adds an endpoint configurator to the endpoint resolver builder
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="P:MassTransit.EndpointConfigurators.EndpointFactoryConfigurator.Defaults">
      <summary>
            Gets the endpoint factory defaults.
            </summary>
    </member>
    <member name="T:MassTransit.BusConfigurators.ServiceBusConfigurator">
      <summary>
        <para>The configurator to call methods on, as well as extension methods on,
            in order to configure your service bus. The configuration
            goes a lot by convention, but this interface allows you to configure
            almost any aspect of the bus.</para>
        <para>
            Documentation is at http://readthedocs.org/docs/masstransit/en/latest/configuration/index.html
            </para>
      </summary>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.UseBusBuilder(System.Func{MassTransit.Configuration.BusSettings,MassTransit.Builders.BusBuilder})">
      <summary>
            Specifies the builder factory to use when the service is invoked
            </summary>
      <param name="builderFactory">
      </param>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.AddSubscriptionRouterConfigurator(MassTransit.SubscriptionConfigurators.SubscriptionRouterBuilderConfigurator)">
      <summary>
            Adds a configurator to the subscription coordinator builder
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.AddBusConfigurator(MassTransit.BusConfigurators.BusBuilderConfigurator)">
      <summary>
            Adds a configurator for the service bus builder to the configurator
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.ReceiveFrom(System.Uri)">
      <summary>
            Specify the endpoint from which messages should be read
            </summary>
      <param name="uri">
            The uri of the endpoint that this bus should
            receive message from.
            </param>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.SetNetwork(System.String)">
      <summary>
            Sets the network key for subscriptions
            </summary>
      <param name="network">
      </param>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.DisablePerformanceCounters">
      <summary>
            Disable the performance counters
            </summary>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.BeforeConsumingMessage(System.Action)">
      <summary>
            Specifies an action to call before a message is consumed. Implementors
            should take care to not remove previously set actions so that multiple
            calls to this method generates calls to all those action parameters.
            </summary>
      <param name="beforeConsume">The action to run before consumption.</param>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfigurator.AfterConsumingMessage(System.Action)">
      <summary>
            Specifies an action to call after a message is consumed. Implementors
            should take care to not remove previously set actions so that multiple
            calls to this method generates calls to all those action parameters.
            </summary>
      <param name="afterConsume">The action to run after consumption</param>
    </member>
    <member name="T:MassTransit.BusConfigurators.ServiceBusConfiguratorImpl">
      <summary>
        <see cref="T:MassTransit.BusConfigurators.ServiceBusConfigurator" />. Core implementation of service bus
            configurator.
            </summary>
    </member>
    <member name="M:MassTransit.BusConfigurators.ServiceBusConfiguratorImpl.ChangeSettings(System.Action{MassTransit.BusConfigurators.ServiceBusSettings})">
      <summary>
            This lets you change the bus settings without
            having to implement a <see cref="T:MassTransit.BusConfigurators.BusBuilderConfigurator" />
            first. Use with caution.
            </summary>
      <param name="callback">The callback that changes the settings.</param>
    </member>
    <member name="M:MassTransit.ControlBusConfigurationExtensions.UseControlBus(MassTransit.BusConfigurators.ServiceBusConfigurator)">
      <summary>
            Create a control bus using the default settings and associate it with the ServiceBus being configured.
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="M:MassTransit.ControlBusConfigurationExtensions.UseControlBus(MassTransit.BusConfigurators.ServiceBusConfigurator,System.Action{MassTransit.BusConfigurators.ControlBusConfigurator})">
      <summary>
            Create a control bus, associate it with the ServiceBus being configured, and allow for customization using
            the specified method.
            </summary>
      <param name="configurator">
      </param>
      <param name="configure">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfiguratorExtensions.UseSerializer``1(MassTransit.EndpointConfigurators.EndpointConfigurator)">
      <summary>
            Specify a serializer for this endpoint (overrides the default)
            </summary>
      <typeparam name="TSerializer">
      </typeparam>
    </member>
    <member name="M:MassTransit.EndpointConfiguratorExtensions.UseSerializer(MassTransit.EndpointConfigurators.EndpointConfigurator,System.Type)">
      <summary>
            Specify a serializer for this endpoint (overrides the default)
            </summary>
      <param name="configurator">
      </param>
      <param name="serializerType">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfiguratorExtensions.DiscardFaultingMessages(MassTransit.EndpointConfigurators.EndpointConfigurator)">
      <summary>
            Specifies a null transport for error messages
            </summary>
      <param name="configurator">
      </param>
    </member>
    <member name="M:MassTransit.EndpointConfiguratorExtensions.SetErrorAddress(MassTransit.EndpointConfigurators.EndpointConfigurator,System.String)">
      <summary>
            Overrides the default error address with a new error address
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.SerializerConfigurationExtensions.SupportJsonSerializer``1(``0)">
      <summary>
            Support the receipt of messages serialized by the JsonMessageSerializer
            </summary>
    </member>
    <member name="M:MassTransit.SerializerConfigurationExtensions.SetDefaultSerializer``1(MassTransit.EndpointConfigurators.EndpointFactoryConfigurator)">
      <summary>
            Sets the default message serializer for endpoints
            </summary>
      <typeparam name="TSerializer">
      </typeparam>
      <param name="configurator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.SerializerConfigurationExtensions.SetDefaultSerializer``1(MassTransit.BusConfigurators.ServiceBusConfigurator)">
      <summary>
            Sets the default message serializer for endpoints
            </summary>
      <typeparam name="TSerializer">
      </typeparam>
      <param name="configurator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.SerializerConfigurationExtensions.SetDefaultSerializer``1(``0,System.Type)">
      <summary>
            Sets the default message serializer for endpoints
            </summary>
      <param name="configurator">
      </param>
      <param name="serializerType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.SerializerConfigurationExtensions.SetDefaultSerializer``1(``0,MassTransit.Serialization.IMessageSerializer)">
      <summary>
            Sets the default message serializer for endpoints
            </summary>
      <param name="configurator">
      </param>
      <param name="serializer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.SerializerConfigurationExtensions.SetSupportedMessageSerializers``1(``0,MassTransit.Serialization.ISupportedMessageSerializers)">
      <summary>
            Sets the default message serializer for endpoints
            </summary>
      <param name="configurator">
      </param>
      <param name="supportedSerializer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.ServiceBusConfiguratorExtensions.ReceiveFrom(MassTransit.BusConfigurators.ServiceBusConfigurator,System.String)">
      <summary>
            Specify the endpoint from which messages should be read
            </summary>
      <param name="configurator">
      </param>
      <param name="uriString">The uri of the endpoint</param>
    </member>
    <member name="T:MassTransit.ServiceBusFactory">
      <summary>
            The starting point to configure and create a service bus instance
            </summary>
    </member>
    <member name="T:MassTransit.SubscriptionConnectors.ConsumerConnector">
      <summary>
            Interface implemented by objects that tie an inbound pipeline together with
            consumers (by means of calling a consumer factory).
            </summary>
    </member>
    <member name="T:MassTransit.SubscriptionConnectors.ConsumerSubscriptionConnector">
      <summary>
            A connector for a specific message. Objects implementing this interface should be able to
            both do <see cref="T:MassTransit.SubscriptionConnectors.ConsumerConnector" /> and be typed to a specific message.
            </summary>
    </member>
    <member name="M:MassTransit.SubscriptionConnectors.HandlerSubscriptionConnector`1.Connect(MassTransit.Pipeline.IInboundPipelineConfigurator,MassTransit.Pipeline.HandlerSelector{`0})">
      <summary>
            Connects a handler selector through an 'instance message sink' and makes sure that
            the message router is wired up to route messages to this handler.
            </summary>
      <param name="configurator">The inbound pipeline configurator</param>
      <param name="handler">The handler to subscribe.</param>
      <returns>An action that can be called to unsubscribe the handler.</returns>
    </member>
    <member name="M:MassTransit.SubscriptionRouterConfiguratorExtensions.UseSubscriptionStorage(MassTransit.BusConfigurators.ServiceBusConfigurator,System.Func{MassTransit.Subscriptions.Coordinator.SubscriptionStorage})">
      <summary>
            Specify a custom subscription storage for the bus instance
            </summary>
      <param name="subscriptionStorageFactory">Factory method for the subscription storage</param>
    </member>
    <member name="T:MassTransit.SubscriptionConfigurators.SubscriptionConfigurator`1">
      <summary>
            The base configuration interface for a subscription
            </summary>
    </member>
    <member name="T:MassTransit.SubscriptionConfigurators.SubscriptionBusServiceConfigurator">
      <summary>
            The configuration scope for subscriptions on the bus
            </summary>
    </member>
    <member name="T:MassTransit.SubscriptionConfigurators.SubscriptionBusServiceConfiguratorImpl">
      <summary>
            Handles the configuration of subscriptions as part of the bus
            
            </summary>
    </member>
    <member name="M:MassTransit.TransactionConfigurationExtensions.SetDefaultTransactionTimeout``1(``0,System.TimeSpan)">
      <summary>
            Sets the default transaction timeout for transactional transports
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="configurator">
      </param>
      <param name="timeout">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.IMessageContext">
      <summary>
            The base message context, including all the message headers
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.MessageId">
      <summary>
            The transport id of the message
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.MessageType">
      <summary>
            The type of the message in FullName, Assembly format
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.ContentType">
      <summary>
            The content type of the message from the transport
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.RequestId">
      <summary>
            The request identifier this message is either a request or a response
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.ConversationId">
      <summary>
            The conversation identifier is a higher-level identifier for trace/correlation of conversations
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.CorrelationId">
      <summary>
            If the message is CorrelatedBy, this header contains the string version of the correlation identifier
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.SourceAddress">
      <summary>
            The address from which this message originated
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.InputAddress">
      <summary>
            The address from which this message was most recently read
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.DestinationAddress">
      <summary>
            The address to which the message was originally sent
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.ResponseAddress">
      <summary>
            The address where responses to this message should be sent
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.FaultAddress">
      <summary>
            The address where faults generated by consumers of this message should be sent
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.Network">
      <summary>
            Identifies a specific network to which this message belongs and is used to filter
            out messages that might be from un-trusted networks
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.ExpirationTime">
      <summary>
            The expiration time of the message, if set, otherwise null
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.RetryCount">
      <summary>
            The number of times this message has been delivered to the consumer
            </summary>
    </member>
    <member name="P:MassTransit.IMessageContext.Headers">
      <summary>
            Key/value headers that are application-specific
            </summary>
    </member>
    <member name="T:MassTransit.IConsumeContext">
      <summary>
            The consumer context can be used by message consumers to retrieve out-of-band information
            related to a message
            </summary>
    </member>
    <member name="M:MassTransit.IConsumeContext.IsContextAvailable(System.Type)">
      <summary>
            Determines if the specified message type is available in the consumer context
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.IConsumeContext.TryGetContext``1(MassTransit.IConsumeContext{``0}@)">
      <summary>
            Retrieves a specified message type from the consumer context, if available.
            </summary>
      <typeparam name="T">The message type requested</typeparam>
      <param name="context">The message context for the requested message type</param>
      <returns>True if the message type is available, otherwise false.</returns>
    </member>
    <member name="M:MassTransit.IConsumeContext.Respond``1(``0,System.Action{MassTransit.ISendContext{``0}})">
      <summary>
            Respond to the current message, sending directly to the ResponseAddress if specified
            otherwise publishing the message
            </summary>
      <typeparam name="T">The type of the message to respond with.</typeparam>
      <param name="message">The message to send in response</param>
      <param name="contextCallback">The context action for specifying additional context information</param>
    </member>
    <member name="P:MassTransit.IConsumeContext.BaseContext">
      <summary>
            Gets the base context of this consume context.
            </summary>
    </member>
    <member name="P:MassTransit.IConsumeContext.Bus">
      <summary>
            The bus on which the message was received
            </summary>
    </member>
    <member name="P:MassTransit.IConsumeContext.Endpoint">
      <summary>
            The endpoint from which the message was received
            </summary>
    </member>
    <member name="T:MassTransit.IConsumeContext`1">
      <summary>
            Typed consumer context that can be used by message consumers to retrieve out-of-band information
            related to a message. This consumer context can also be used for explicitly telling the service bus
            to place the message at the end of the input-queue (by calling <see cref="M:MassTransit.IConsumeContext`1.RetryLater" />) or send the message to the poison-letter queue (by
            calling <see cref="M:MassTransit.IConsumeContext`1.GenerateFault(System.Exception)" />.)
            </summary>
      <typeparam name="T">Incoming message type.</typeparam>
    </member>
    <member name="M:MassTransit.IConsumeContext`1.RetryLater">
      <summary>
            Send the message to the end of the input queue so that it can be processed again later
            </summary>
    </member>
    <member name="M:MassTransit.IConsumeContext`1.GenerateFault(System.Exception)">
      <summary>
            Generates a fault for this message, which will be published once the message is moved
            </summary>
    </member>
    <member name="T:MassTransit.IReceiveContext">
      <summary>
            Receive context that allows receiving sinks to 
            </summary>
    </member>
    <member name="M:MassTransit.IReceiveContext.SetContentType(System.String)">
      <summary>
            Set the content type that was indicated by the transport message header
            </summary>
      <param name="value">
      </param>
    </member>
    <member name="M:MassTransit.IReceiveContext.SetBus(MassTransit.IServiceBus)">
      <summary>
            Sets the bus which is receiving this message/data.
            </summary>
      <param name="bus">Bus instance</param>
    </member>
    <member name="M:MassTransit.IReceiveContext.SetBodyStream(System.IO.Stream)">
      <summary>
            Sets the context's body stream;
            useful for wrapped serializers 
            such as encrypting serializers
            and for testing.
            </summary>
      <param name="stream">Stream to replace the previous stream with</param>
    </member>
    <member name="M:MassTransit.IReceiveContext.NotifyFault(System.Action)">
      <summary>
            Notify that a fault needs to be sent, so that the endpoint can send it when
            appropriate.
            </summary>
      <param name="faultAction">
      </param>
    </member>
    <member name="M:MassTransit.IReceiveContext.ExecuteFaultActions(System.Collections.Generic.IEnumerable{System.Action})">
      <summary>
            Publish any pending faults for the context
            </summary>
    </member>
    <member name="M:MassTransit.IReceiveContext.GetFaultActions">
      <summary>
            Returns the fault actions that were added to the context during message processing
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MassTransit.IReceiveContext.IsTransactional">
      <summary>
            True if the transport is transactional and will leave the message on the queue if an exception is thrown
            </summary>
    </member>
    <member name="P:MassTransit.IReceiveContext.OriginalMessageId">
      <summary>
             The original message id that was consumed
            </summary>
    </member>
    <member name="M:MassTransit.Context.ReceiveContext.Respond``1(``0,System.Action{MassTransit.ISendContext{``0}})">
      <summary>
            Respond to the current inbound message with either a send to the ResponseAddress or a
            Publish on the bus that received the message
            </summary>
      <typeparam name="T">Message type</typeparam>
      <param name="message">The message to send/publish</param>
      <param name="contextCallback">The action to setup the context on the outbound message</param>
    </member>
    <member name="M:MassTransit.Context.ReceiveContext.FromBodyStream(System.IO.Stream,System.Boolean)">
      <summary>
            Create a new <see cref="T:MassTransit.Context.ReceiveContext" /> from the incoming 
            stream; the stream should contain the MassTransit <see cref="T:MassTransit.Serialization.Envelope" />
            which in turn contains both payload and meta-data/out-of-band data.
            </summary>
      <param name="bodyStream">Body stream to create receive context from</param>
      <param name="transactional">True if the transport is transactional and will roll back failed messages </param>
      <returns>The receive context</returns>
    </member>
    <member name="M:MassTransit.Context.ReceiveContext.Empty">
      <summary>
            Create a new empty receive context
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MassTransit.Context.ReceiveContext.Endpoint">
      <summary>
            The endpoint from which the message was received
            </summary>
    </member>
    <member name="P:MassTransit.Context.ReceiveContext.Bus">
      <summary>
            The bus on which the message was received
            </summary>
    </member>
    <member name="M:MassTransit.ISendContext.SerializeTo(System.IO.Stream)">
      <summary>
            Serializes the message to the stream
            </summary>
      <param name="stream">The target stream for the serialized message</param>
    </member>
    <member name="M:MassTransit.ISendContext.TryGetContext``1(MassTransit.IBusPublishContext{``0}@)">
      <summary>
            Determines if the send context can be converted to the requested type
            </summary>
      <typeparam name="T">The requested type</typeparam>
      <param name="context">The resulting context that was created for the requested message type</param>
      <returns>True if the message can be assigned to the requested type, otherwise false</returns>
    </member>
    <member name="M:MassTransit.ISendContext.NotifySend(MassTransit.IEndpointAddress)">
      <summary>
            Called when the send context has been used to send a message to an endpoint
            </summary>
      <param name="address">The address to which the message was sent</param>
    </member>
    <member name="P:MassTransit.ISendContext.Id">
      <summary>
            The identifier for this message publish/send
            </summary>
    </member>
    <member name="P:MassTransit.ISendContext.DeclaringMessageType">
      <summary>
            The original message type that was sent/published
            </summary>
    </member>
    <member name="M:MassTransit.ISendContext`1.SetContentType(System.String)">
      <summary>
            Sets the message content type that is used to deserialize the message
            </summary>
      <param name="value">
      </param>
    </member>
    <member name="M:MassTransit.ISendContext`1.SetBodyWriter(System.Action{System.IO.Stream})">
      <summary>
            Sets the writer for the message body
            </summary>
      <param name="bodyWriter">
      </param>
    </member>
    <member name="M:MassTransit.ISendContext`1.SetReceiveContext(MassTransit.IReceiveContext)">
      <summary>
            Sets the receive context that the send was created in for tracing
            </summary>
      <param name="receiveContext">
      </param>
    </member>
    <member name="M:MassTransit.IPublishContext.WasEndpointAlreadySent(MassTransit.IEndpointAddress)">
      <summary>
            Determines if the endpoint was already sent to during this publish
            </summary>
      <param name="address">The address of the endpoint to check</param>
      <returns>True if the message was already sent to the specified endpoint address</returns>
    </member>
    <member name="M:MassTransit.IPublishContext.IfNoSubscribers(System.Action)">
      <summary>
            Defines an action to be called if there are no subscribers for the message
            </summary>
      <param name="callback">The action to call if there are no subscribers registered</param>
    </member>
    <member name="M:MassTransit.IPublishContext.ForEachSubscriber(System.Action{MassTransit.IEndpointAddress})">
      <summary>
            Defines an action to be called for each subscriber of the message
            </summary>
      <param name="callback">The action to call for each subscriber, including the endpoint address of the destination endpoint</param>
    </member>
    <member name="M:MassTransit.IBusPublishContext`1.NotifyNoSubscribers">
      <summary>
            Called if there are no subscribers for the message
            </summary>
    </member>
    <member name="T:MassTransit.MessageContextExtensions">
      <summary>
            Extensions methods for parameterizing message contexts
            </summary>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SetSourceAddress``1(MassTransit.ISendContext{``0},System.String)">
      <summary>
            Sets the source address of the message to be send.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="uriString">The URI string.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SetDestinationAddress``1(MassTransit.ISendContext{``0},System.String)">
      <summary>
            Sets the destination address of the message to be send.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="uriString">The URI string.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SetResponseAddress``1(MassTransit.ISendContext{``0},System.String)">
      <summary>
            Sets the response address of the message to be send.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="uriString">The URI string.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SendResponseTo``1(MassTransit.ISendContext{``0},MassTransit.IServiceBus)">
      <summary>
            Sets the response address of the message to be send to the <see cref="T:MassTransit.IEndpoint" /> of the given <see cref="T:MassTransit.IServiceBus" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="bus">The bus.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SendResponseTo``1(MassTransit.ISendContext{``0},MassTransit.IEndpoint)">
      <summary>
            Sets the response address of the message to be send to the given <see cref="T:MassTransit.IEndpoint" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="endpoint">The endpoint.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SendResponseTo``1(MassTransit.ISendContext{``0},System.Uri)">
      <summary>
            Sets the response address of the message to be send to the given <see cref="T:System.Uri" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="uri">The URI.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SetFaultAddress``1(MassTransit.ISendContext{``0},System.String)">
      <summary>
            Sets the fault address of the message to be send to the given uri.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="uriString">The URI string.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SendFaultTo``1(MassTransit.ISendContext{``0},MassTransit.IServiceBus)">
      <summary>
            Sets the fault address of the message to be send to the given <see cref="T:MassTransit.IServiceBus" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="bus">The bus.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SendFaultTo``1(MassTransit.ISendContext{``0},MassTransit.IEndpoint)">
      <summary>
            Sets the fault address of the message to be send to the given <see cref="T:MassTransit.IEndpoint" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="endpoint">The endpoint.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SendFaultTo``1(MassTransit.ISendContext{``0},System.Uri)">
      <summary>
            Sets the fault address of the message to be send to the given <see cref="T:System.Uri" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="uri">The URI.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.ExpiresAt``1(MassTransit.ISendContext{``0},System.DateTime)">
      <summary>
            Indicates that the messag to be send expireses at the given <see cref="T:System.DateTime" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.ExpiresIn``1(MassTransit.ISendContext{``0},System.TimeSpan)">
      <summary>
            Sets the message to expire after the specified TimeSpan.
            </summary>
      <param name="context">The send context of the message</param>
      <param name="value">The span of time until the message expires</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SetMessageType``1(MassTransit.ISendContext{``0},System.Type)">
      <summary>
            Sets the type of the message to be send.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="messageType">Type of the message.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.SetInputAddress(MassTransit.IReceiveContext,MassTransit.IEndpointAddress)">
      <summary>
            Sets the input address of the message to be send to the given <see cref="T:MassTransit.IEndpointAddress" />.
            </summary>
      <param name="context">The context.</param>
      <param name="address">The address.</param>
    </member>
    <member name="M:MassTransit.MessageContextExtensions.Respond``1(MassTransit.IConsumeContext,``0)">
      <summary>
            Sends the given message to the specified context.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="context">The context.</param>
      <param name="message">The message.</param>
    </member>
    <member name="T:MassTransit.Context.ContextStorage">
      <summary>
            The default context provider using thread local storage
            </summary>
    </member>
    <member name="T:MassTransit.Context.ServiceBusReceiveContext">
      <summary>
            The context keeps track of some statistics about the consumption
            of the message. Both when the receive operation completes
            and when the consume operation completes, does this context
            broadcast that information on the passed <see cref="T:Stact.UntypedChannel" />
            passed in the constructor.
            </summary>
    </member>
    <member name="F:MassTransit.Context.ServiceBusReceiveContext._consumeCount">
      <summary>number of consumers that were selected for the receive context</summary>
    </member>
    <member name="M:MassTransit.Context.ServiceBusReceiveContext.#ctor(MassTransit.IServiceBus,Stact.UntypedChannel,System.TimeSpan)">
      <summary>
            Creates a new service bus receive context, from a bus
            and a channel which will be used to broadcast statistical
            information.
            </summary>
      <param name="bus">The Service Bus instance</param>
      <param name="eventChannel">The Event Channel to broadcast timing information on</param>
      <param name="receiveTimeout">The receive timeout</param>
    </member>
    <member name="M:MassTransit.Context.ServiceBusReceiveContext.ReceiveFromEndpoint">
      <summary>
        <para>Performs a receive from the endpoint that is specified on the bus given in the 
            constructor. First try to do the receive, then let the endpoint/transport
            call <see cref="M:MassTransit.Context.ServiceBusReceiveContext.DeliverMessageToConsumers(MassTransit.IReceiveContext)" /> (if there are consumers interested)</para>
        <para>This method must not throw exceptions, because it might not be run on the main thread.</para>
      </summary>
    </member>
    <member name="M:MassTransit.Context.ServiceBusReceiveContext.DeliverMessageToConsumers(MassTransit.IReceiveContext)">
      <summary>
        <para>Deliver the message to the consumers selected in <see cref="M:MassTransit.Context.ServiceBusReceiveContext.ReceiveFromEndpoint" />. Assumption:
            the inbound transport will send the same context to this method as it did
            to the lambda in <see cref="M:MassTransit.Context.ServiceBusReceiveContext.ReceiveFromEndpoint" />.</para>
        <para>This method will try to give the message to all consumers found.</para>
      </summary>
      <param name="context">The receive context</param>
      <exception cref="T:MassTransit.Exceptions.MessageException">If at least one consumer throws
            an exception, then a MessageException will be thrown. If multiple consumers
            threw exceptions, then the last exception will be the inner exception
            and the others won't be tracked.</exception>
    </member>
    <member name="T:MassTransit.Diagnostics.Introspection.DiagnosticsSource">
      <summary>
            	An item that can add further information about its configuration and current state to the diagnostics probe.
            </summary>
    </member>
    <member name="M:MassTransit.Diagnostics.Introspection.DiagnosticsSource.Inspect(MassTransit.Diagnostics.Introspection.DiagnosticsProbe)">
      <summary>
            	Lets the implementor add diagnostics to the probe instance.
            </summary>
      <param name="probe"> Probe instance </param>
    </member>
    <member name="T:MassTransit.IBusService">
      <summary>
        <para>A bus service is an extension to the service bus, and is used to create services that
            add functionality to the service bus, such as subscription managers, distributors, etc.</para>
        <para>This interface should not be used in most situations and is typically an internal
            use thing.</para>
        <para>Have a look at <see cref="T:MassTransit.BusServiceLayer" /> for the different levels the service can live in.</para>
      </summary>
    </member>
    <member name="M:MassTransit.IBusService.Start(MassTransit.IServiceBus)">
      <summary>
            Called when the service is being started, which is after the service bus has been started.
            </summary>
      <param name="bus">The service bus</param>
    </member>
    <member name="M:MassTransit.IBusService.Stop">
      <summary>
            Called when the ServiceBus is being disposed, to allow any resources or subscriptions
            to be released.
            </summary>
    </member>
    <member name="T:MassTransit.IConsumer">
      <summary>
            Marker interface used to assist identification in IoC containers.
            Not to be used directly.
            </summary>
      <remarks>
            Not to be used directly by application code. Is an internal artifact only.
            </remarks>
    </member>
    <member name="T:MassTransit.Consumes`1">
      <summary>
            API-oriented class.
            </summary>
      <typeparam name="TMessage">The message type to consume.</typeparam>
    </member>
    <member name="T:MassTransit.Consumes`1.All">
      <summary>
            Declares a Consume method for the message type TMessage which is called
            whenever a a message is received of the specified type.
            </summary>
    </member>
    <member name="T:MassTransit.Consumes`1.Selected">
      <summary>
            Declares a selective consumer method for the message type TMessage. In addition
            to the Consume(TMessage) method, an additional Accept method is used to allow
            the consumer object to accept or ignore the message before it is delivered to
            the consumer.
            </summary>
    </member>
    <member name="T:MassTransit.Consumes`1.Context">
      <summary>
            Declares a Consume method for the message type TMessage wrapped in the 
            consume context
            </summary>
    </member>
    <member name="T:MassTransit.Consumes`1.For`1">
      <summary>
            Called by the framework when a message is available to be consumed that
            matches the correlationId of the consumer object instance (exposed by the
            CorrelationId property). This is called by a framework thread, so care
            should be used when accessing any shared objects.
            </summary>
      <typeparam name="TCorrelationId">The type of the CorrelationId to match</typeparam>
    </member>
    <member name="T:MassTransit.CorrelatedBy`1">
      <summary>
              Used to identify a message as correlated so that the CorrelationId can be returned
            </summary>
      <typeparam name="TKey">The type of the CorrelationId used</typeparam>
    </member>
    <member name="P:MassTransit.CorrelatedBy`1.CorrelationId">
      <summary>
              Returns the CorrelationId for the message
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.Id">
      <summary>
            The trace identifier for this message
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.StartTime">
      <summary>
            The date/time the message was received from the transport
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.Duration">
      <summary>
            The amount of time spent processing the message
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.MessageId">
      <summary>
            The transport id of the message
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.MessageType">
      <summary>
            The type of the message in FullName, Assembly format
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.ContentType">
      <summary>
            The content type of the message from the transport
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.SourceAddress">
      <summary>
            The address from which this message originated
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.InputAddress">
      <summary>
            The address from which this message was most recently read
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.DestinationAddress">
      <summary>
            The address to which the message was originally sent
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.ResponseAddress">
      <summary>
            The address where responses to this message should be sent
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.FaultAddress">
      <summary>
            The address where faults generated by consumers of this message should be sent
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.Network">
      <summary>
            Identifies a specific network to which this message belongs and is used to filter
            out messages that might be from un-trusted networks
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.ExpirationTime">
      <summary>
            The expiration time of the message, if set, otherwise null
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetail.RetryCount">
      <summary>
            The number of times this message has been delivered to the consumer
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetailImpl.Duration">
      <summary>
            The amount of time spent processing the message
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetailImpl.Id">
      <summary>
            The trace identifier for this message receive
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.MessageTraceDetailImpl.StartTime">
      <summary>
            The date/time the message was received from the transport
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.ReceivedMessageTraceDetail.Receivers">
      <summary>
            The receivers that processed the message
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.ReceivedMessageTraceDetail.SentMessages">
      <summary>
            The messages that were sent while the message was being received
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.ReceiverTraceDetail.MessageType">
      <summary>
            The message type consumed by the receiver
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.ReceiverTraceDetail.ReceiverType">
      <summary>
            The type of receiver that consumed the message
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.ReceiverTraceDetail.CorrelationId">
      <summary>
            Correlation information related to the receiver (saga Id, etc.)
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.ReceiverTraceDetail.StartTime">
      <summary>
            The time the receiver started processing the message, relative to the receive time
            </summary>
    </member>
    <member name="P:MassTransit.Diagnostics.Tracing.ReceiverTraceDetail.Duration">
      <summary>
            The time at which the receiver was done processing the message
            </summary>
    </member>
    <member name="T:MassTransit.Diagnostics.Tracing.GetMessageTraceListImpl">
      <summary>
            Returns the trace history from the diagnostics service
            </summary>
    </member>
    <member name="T:MassTransit.Diagnostics.Tracing.SentMessageTraceDetail">
      <summary>
            A message that was sent while a message was being received
            </summary>
    </member>
    <member name="T:MassTransit.Distributor.IWorkerLoad`1">
      <summary>
            Used by a worker to determine to manage the load of messages being processed,
            to ensure that message and service limits are not exceeded.
            </summary>
      <typeparam name="TMessage">
      </typeparam>
    </member>
    <member name="T:MassTransit.Pipeline.IPipelineSink">
      <summary>
        <see cref="T:MassTransit.Pipeline.IPipelineSink`1" />.
            </summary>
    </member>
    <member name="T:MassTransit.Pipeline.IPipelineSink`1">
      <summary>
            Implemented by all classes that can be inserted into the pipeline.
            </summary>
      <typeparam name="T">The message type passed by this sink</typeparam>
    </member>
    <member name="M:MassTransit.Pipeline.IPipelineSink`1.Enumerate(`0)">
      <summary>
            Passes a message through the pipeline returning all consumers for the message
            so that it can be dispatched to those consumers. The message does not actually dispatch
            in the pipeline - the consumers' Consume method is called after all consumers have
            been enumerated. A consumer's method of consumption should be equal to the action
            returned.
            </summary>
      <param name="context">
      </param>
      <returns>An enumerable of consumers for the message</returns>
    </member>
    <member name="M:MassTransit.Pipeline.IPipelineSink`1.Inspect(MassTransit.Pipeline.IPipelineInspector)">
      <summary>
            Walks the pipeline from the current sink forward, calling back to the inspector for each
            sink in the pipeline.
            DING: Visitor Pattern merit badge awarded
            </summary>
      <param name="inspector">The inspector to call back to for each sink</param>
      <returns>True if the inspection should continue, false to stop</returns>
    </member>
    <member name="M:MassTransit.EndpointLoggerExtensions.LogMoved(MassTransit.IEndpointAddress,MassTransit.IEndpointAddress,System.String,System.String)">
      <summary>
            Log that a message was moved from one endpoint to the destination endpoint address
            </summary>
      <param name="sourceAddress">
      </param>
      <param name="destinationAddress">
      </param>
      <param name="messageId">
      </param>
      <param name="description">
      </param>
    </member>
    <member name="M:MassTransit.EndpointLoggerExtensions.LogReQueued(MassTransit.IEndpointAddress,MassTransit.IEndpointAddress,System.String,System.String)">
      <summary>
            Log that a message was requeued to the transport after an exception occurred
            </summary>
      <param name="sourceAddress">
      </param>
      <param name="destinationAddress">
      </param>
      <param name="messageId">
      </param>
      <param name="description">
      </param>
    </member>
    <member name="T:MassTransit.IOutboundMessageInterceptor">
      <summary>
            Implementations can be added to the outbound message pipeline to intercept
            messages before they are delivered to any endpoints.
            </summary>
    </member>
    <member name="M:MassTransit.IOutboundMessageInterceptor.PreDispatch(MassTransit.ISendContext)">
      <summary>
            Called before the message is dispatched to the next handler in the pipeline
            </summary>
      <param name="context">The context of the message being dispatched</param>
    </member>
    <member name="M:MassTransit.IOutboundMessageInterceptor.PostDispatch(MassTransit.ISendContext)">
      <summary>
            Calls after the message has been dispatched through the pipeline
            </summary>
      <param name="context">The context of the message being dispatched</param>
    </member>
    <member name="T:MassTransit.Logging.ILog">
      <summary>
            Implementers handle logging and filtering based on logging levels.
            </summary>
    </member>
    <member name="T:MassTransit.Logging.LogOutputProvider">
      <summary>
            Delegate to provide the log output if the log level is enabled
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Debug(System.Object)">
      <summary>
            Logs a debug message.
            
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Debug(System.Object,System.Exception)">
      <summary>
            Logs a debug message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Info(System.Object)">
      <summary>
            Logs an info message.
            
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Info(System.Object,System.Exception)">
      <summary>
            Logs an info message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs an info message.
            
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Warn(System.Object)">
      <summary>
            Logs a warn message.
            
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Warn(System.Object,System.Exception)">
      <summary>
            Logs a warn message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Error(System.Object)">
      <summary>
            Logs an error message.
            
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Error(System.Object,System.Exception)">
      <summary>
            Logs an error message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs an error message.
            
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Fatal(System.Object)">
      <summary>
            Logs a fatal message.
            
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.Fatal(System.Object,System.Exception)">
      <summary>
            Logs a fatal message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an info message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an error message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:MassTransit.Logging.Tracing.TraceLog.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="T:MassTransit.NewId">
      <summary>
            A NewId is a type that fits into the same space as a Guid/Uuid/uniqueidentifier,
            but is guaranteed to be both unique and ordered, assuming it is generated using
            a single instance of the generator for each network address used.
            </summary>
    </member>
    <member name="M:MassTransit.NewId.#ctor(System.Byte[])">
      <summary>
            Creates a NewId using the specified byte array.
            </summary>
      <param name="bytes">
      </param>
    </member>
    <member name="T:MassTransit.Pipeline.Inspectors.PipelineInspectorBase`1">
      <summary>
            Base class for pipeline inspectors
            </summary>
    </member>
    <member name="T:MassTransit.Pipeline.HandlerSelector`1">
      <summary>
            Given a message, returns the handler for that message, or null if the message
            should be ignored.
            </summary>
      <typeparam name="TMessage">The message type</typeparam>
      <param name="context">The consume context of the message</param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.Pipeline.HandlerSelector">
      <summary>
            Helpers for creating HandlerSelectors
            </summary>
    </member>
    <member name="T:MassTransit.Pipeline.MultipleHandlerSelector`1">
      <summary>
            Returns zero to many handlers for the message, aligns with the pipeline sink requirements
            </summary>
      <typeparam name="TMessage">
      </typeparam>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.Pipeline.MultipleHandlerSelector">
      <summary>
            A static class to create delegates easily
            </summary>
    </member>
    <member name="M:MassTransit.Pipeline.MultipleHandlerSelector.ForHandler``1(MassTransit.Pipeline.HandlerSelector{``0})">
      <summary>
            Creates a MultipleHandlerSelector for the selector 
            </summary>
      <typeparam name="TMessage">The message type of the handler</typeparam>
      <param name="selector">The selector to promote to a MultipleHandlerSelector</param>
      <returns>A MultipleHandlerSelector delegate for the specified message type</returns>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.ContextConsumerMessageSink`2">
      <summary>
            Routes messages to instances of subscribed components. A new instance of the component
            is created from the container for each message received.
            </summary>
      <typeparam name="TComponent">The component type to handle the message</typeparam>
      <typeparam name="TMessage">The message to handle</typeparam>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.RequestMessageRouter`2">
      <summary>
            Maintains a dictionary of valid values for the specified string expression
            </summary>
      <typeparam name="TMessage">The type of the message to be routed</typeparam>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MassTransit.RequestResponse.ResponseHandler">
      <summary>
            A response handler is defined by the request/response DSL
            </summary>
    </member>
    <member name="M:MassTransit.RequestResponse.ResponseHandlerBase`1.Success(MassTransit.IConsumeContext{`0})">
      <summary>
            Called when the handler completes successfully
            </summary>
      <param name="context">The message consumer context</param>
    </member>
    <member name="M:MassTransit.RequestResponse.ResponseHandlerBase`1.Failure(System.Exception)">
      <summary>
            Called when the handler throws an exception (exception is wrapped as a RequestException)
            </summary>
      <param name="exception">The wrapped exception</param>
    </member>
    <member name="T:MassTransit.RequestResponse.TaskResponseHandler">
      <summary>
            A task response handler provides access to the task itself
            </summary>
    </member>
    <member name="M:MassTransit.RequestResponse.TaskResponseHandler.GetTask``1">
      <summary>
            Returns the Task&lt;<typeparam name="T">T</typeparam>&gt; for the response handler
            </summary>
    </member>
    <member name="M:MassTransit.RequestResponse.TaskResponseHandler.HandleTimeout">
      <summary>
            Notifies the handler that the request has timed out.
            </summary>
    </member>
    <member name="P:MassTransit.RequestResponse.TaskResponseHandler.Task">
      <summary>
            Returns the Task for the response handler
            </summary>
    </member>
    <member name="P:MassTransit.RequestResponse.TaskResponseHandler`1.Task">
      <summary>
            Returns the Task&lt;<typeparam name="T">T</typeparam>&gt; for the response handler
            </summary>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.RequestConfigurator.SetRequestExpiration(System.TimeSpan)">
      <summary>
            Specifies a time-to-live (TTL) for the request message after which the message
            should be discarded.
            </summary>
      <param name="expiration">The time-to-live for the message</param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.RequestConfigurator.SetTimeout(System.TimeSpan)">
      <summary>
            Specifies a timeout period after which the request should be cancelled and
            a TimeoutException should be thrown
            </summary>
      <param name="timeout">The timeout period</param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.RequestConfigurator.HandleTimeout(System.TimeSpan,System.Action)">
      <summary>
            Specifies a timeout period after which the request should be cancelled and
            the timeoutCallback invoked.
            </summary>
      <param name="timeout">The time period</param>
      <param name="timeoutCallback">The callback to invoke</param>
    </member>
    <member name="P:MassTransit.RequestResponse.Configurators.RequestConfigurator.RequestId">
      <summary>
            Returns the identifier assigned to this request
            </summary>
    </member>
    <member name="T:MassTransit.RequestResponse.Configurators.RequestConfigurator`1">
      <summary>
            Configures a request and the associated response handler behavior
            </summary>
      <typeparam name="TRequest">The message type of the request</typeparam>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.RequestConfigurator`1.HandleTimeout(System.TimeSpan,System.Action{`0})">
      <summary>
            Specifies a timeout period after which the request should be cancelled
            </summary>
      <param name="timeout">The timeout period</param>
      <param name="timeoutCallback">
      </param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.RequestConfigurator`1.Watch``1(System.Action{``0})">
      <summary>
            Configures a watcher to be called when a specified type is received. Messages
            received do not complete the request, but are merely observed while the request
            is pending.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="watcher">
      </param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.RequestConfigurator`1.Watch``1(System.Action{MassTransit.IConsumeContext{``0},``0})">
      <summary>
            Configures a watcher to be called when a specified type is received. Messages
            received do not complete the request, but are merely observed while the request
            is pending.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="watcher">
      </param>
    </member>
    <member name="P:MassTransit.RequestResponse.Configurators.RequestConfigurator`1.Request">
      <summary>
            The request message that was sent
            </summary>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.InlineRequestConfigurator`1.UseCurrentSynchronizationContext">
      <summary>
            Sets the synchronization context for the response and timeout handlers to 
            the current synchronization context
            </summary>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.InlineRequestConfigurator`1.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>
            Sets the synchronization context to the specified synchronization context
            </summary>
      <param name="synchronizationContext">
      </param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.InlineRequestConfigurator`1.Handle``1(System.Action{``0})">
      <summary>
            Configures a handler to be called if a response of the specified type
            is received. Once received, the request completes by default unless
            overridden by calling Continue on the request.
            </summary>
      <typeparam name="TResponse">The message type of the response</typeparam>
      <param name="handler">The handler to call with the response message</param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.InlineRequestConfigurator`1.Handle``1(System.Action{MassTransit.IConsumeContext{``0},``0})">
      <summary>
            Configures a handler to be called if a response of the specified type
            is received. Once received, the request completes by default unless
            overridden by calling Continue on the request.
            </summary>
      <typeparam name="TResponse">The message type of the response</typeparam>
      <param name="handler">The handler to call with the response message</param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.InlineRequestConfigurator`1.HandleFault(System.Action{MassTransit.Fault{`0}})">
      <summary>
            Specifies a handler for a fault published by the request handler
            </summary>
      <param name="faultCallback">
      </param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.InlineRequestConfigurator`1.HandleFault(System.Action{MassTransit.IConsumeContext{MassTransit.Fault{`0}},MassTransit.Fault{`0}})">
      <summary>
            Specifies a handler for a fault published by the request handler
            </summary>
      <param name="faultCallback">
      </param>
    </member>
    <member name="T:MassTransit.RequestResponse.Configurators.TaskRequestConfigurator`1">
      <summary>
            Configures a request and the associated response handler behavior
            </summary>
      <typeparam name="TRequest">The message type of the request</typeparam>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.TaskRequestConfigurator`1.Handle``1(System.Action{``0})">
      <summary>
            Configures a handler to be called if a response of the specified type
            is received. Once received, the request completes by default unless
            overridden by calling Continue on the request.
            </summary>
      <typeparam name="T">The message type of the response</typeparam>
      <param name="handler">The handler to call with the response message</param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.TaskRequestConfigurator`1.Handle``1(System.Action{MassTransit.IConsumeContext{``0},``0})">
      <summary>
            Configures a handler to be called if a response of the specified type
            is received. Once received, the request completes by default unless
            overridden by calling Continue on the request.
            </summary>
      <typeparam name="T">The message type of the response</typeparam>
      <param name="handler">The handler to call with the response message</param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.TaskRequestConfigurator`1.HandleFault(System.Action{MassTransit.Fault{`0}})">
      <summary>
            Specifies a handler for a fault published by the request handler
            </summary>
      <param name="faultCallback">
      </param>
    </member>
    <member name="M:MassTransit.RequestResponse.Configurators.TaskRequestConfigurator`1.HandleFault(System.Action{MassTransit.IConsumeContext{MassTransit.Fault{`0}},MassTransit.Fault{`0}})">
      <summary>
            Specifies a handler for a fault published by the request handler
            </summary>
      <param name="faultCallback">
      </param>
    </member>
    <member name="T:MassTransit.IRequest">
      <summary>
            Handle to a request that was sent/published
            </summary>
    </member>
    <member name="P:MassTransit.IRequest.RequestId">
      <summary>
            Identifies the request for matching up request/response messages
            </summary>
    </member>
    <member name="T:MassTransit.IRequest`1">
      <summary>
            Handle to a request that was sent/published
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:MassTransit.IRequest`1.Message">
      <summary>
            The request message that was sent/published
            </summary>
    </member>
    <member name="T:MassTransit.IAsyncRequest`1">
      <summary>
            A handle to an asynchronous request (started using Begin/End style async pattern)
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:MassTransit.IAsyncRequest`1.Cancel">
      <summary>
            Cancel the request, releasing any pending resources
            </summary>
    </member>
    <member name="M:MassTransit.IAsyncRequest`1.Wait">
      <summary>
            Wait for the request to complete. If the timeout expires, the request
            completes and the timeout callback is called.
            </summary>
      <returns>True if the request completed before the timeout expired</returns>
    </member>
    <member name="M:MassTransit.IAsyncRequest`1.Wait(System.TimeSpan)">
      <summary>
            Wait for the request to complete. If the timeout expires, the request
            completes and the timeout callback is called.
            </summary>
      <param name="timeout">The timeout for the request</param>
      <returns>True if the request completed before the timeout expired</returns>
    </member>
    <member name="M:MassTransit.IAsyncRequest`1.BeginAsync(System.AsyncCallback,System.Object)">
      <summary>
            Begins the request as an asynchronous operation
            </summary>
      <param name="callback">
      </param>
      <param name="state">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.ITaskRequest`1">
      <summary>
            A Task-based request that is designed to be used by the TPL
            </summary>
    </member>
    <member name="M:MassTransit.ITaskRequest`1.Cancel">
      <summary>
            Cancel the request (will signal the Tasks as Cancelled)
            </summary>
    </member>
    <member name="M:MassTransit.ITaskRequest`1.GetResponseTask``1">
      <summary>
            Returns the task for the response handler of the specified message type
            </summary>
      <typeparam name="T">The response message type</typeparam>
      <returns>The Task associated with the response handler</returns>
    </member>
    <member name="M:MassTransit.ITaskRequest`1.GetResponseTask(System.Type)">
      <summary>
            Returns the task for the response handler of the specified message type
            </summary>
      <param name="responseType">The response message type</param>
      <returns>The Task associated with the response handler</returns>
    </member>
    <member name="P:MassTransit.ITaskRequest`1.Task">
      <summary>
            The Task for the entire request, is completed when any of the response
            handlers completes.
            </summary>
    </member>
    <member name="T:MassTransit.Saga.ISagaRepository`1">
      <summary>
            A saga repository is used by the service bus to dispatch messages to sagas
            </summary>
      <typeparam name="TSaga">
      </typeparam>
    </member>
    <member name="M:MassTransit.Saga.ISagaRepository`1.GetSaga``1(MassTransit.IConsumeContext{``0},System.Guid,MassTransit.Pipeline.InstanceHandlerSelector{`0,``0},MassTransit.Saga.ISagaPolicy{`0,``0})">
      <summary>
            Loads/Creates the saga and makes it available for later consumption
            through the Actions
            </summary>
      <typeparam name="TMessage">
      </typeparam>
      <param name="context">
      </param>
      <param name="sagaId">
      </param>
      <param name="selector">
      </param>
      <param name="policy">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaRepository`1.Find(MassTransit.Saga.ISagaFilter{`0})">
      <summary>
            Finds the CorrelationIds for the sagas that match the filter
            </summary>
      <param name="filter">effectively a LINQ expression</param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaRepository`1.Where(MassTransit.Saga.ISagaFilter{`0})">
      <summary>
            Finds the sagas that match the filter
            </summary>
      <param name="filter">effectively a LINQ expression</param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaRepository`1.Where``1(MassTransit.Saga.ISagaFilter{`0},System.Func{`0,``0})">
      <summary>
            Finds all of the sagas that match the filter, and then applies a transform on them.
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="filter">effectively a LINQ expression</param>
      <param name="transformer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaRepository`1.Select``1(System.Func{`0,``0})">
      <summary>
            Queries the underlying store for sagas, then applies a transform to them and
            returns the result
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="transformer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.Saga.DelegatingSagaRepository`1">
      <summary>
            Decorates a saga repository with a callback method that is invoked before every
            instance of the saga is returned, allowing any dependencies to be set.
            </summary>
      <typeparam name="TSaga">
      </typeparam>
    </member>
    <member name="T:MassTransit.Saga.InjectingSagaRepository`1">
      <summary>
            Factory methods for decorating a saga repository so that properties of the saga
            can be set using the value provider specified.
            </summary>
      <typeparam name="TSaga">
      </typeparam>
    </member>
    <member name="M:MassTransit.Saga.InjectingSagaRepository`1.Create``1(MassTransit.Saga.ISagaRepository{`0},System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{`0,``0})">
      <summary>
            Creates a delegate saga repository that sets the designated property using the
            value returned by the value provider specified.
            </summary>
      <typeparam name="T1">The property type</typeparam>
      <param name="repository">The repository to decorate</param>
      <param name="propertyExpression">The property to set</param>
      <param name="valueProvider">The value provider for the property</param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Saga.InjectingSagaRepository`1.Create``2(MassTransit.Saga.ISagaRepository{`0},System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{`0,``0},System.Linq.Expressions.Expression{System.Func{`0,``1}},System.Func{`0,``1})">
      <summary>
            Creates a delegate saga repository that sets the designated property using the
            value returned by the value provider specified.
            </summary>
      <typeparam name="T1">The property type</typeparam>
      <typeparam name="T2">The second property type</typeparam>
      <param name="repository">The repository to decorate</param>
      <param name="propertyExpression1">The first property to set</param>
      <param name="valueProvider1">The first property value provider</param>
      <param name="propertyExpression2">The second property to set</param>
      <param name="valueProvider2">The second value provider</param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.Saga.Pipeline.CorrelationExpressionToSagaIdVisitor`2">
      <summary>
            Determines if a message property is compared to the CorrelationId of the saga and if so
            returns an expression that can be used to return that id
            </summary>
      <typeparam name="TSaga">
      </typeparam>
      <typeparam name="TMessage">
      </typeparam>
    </member>
    <member name="T:MassTransit.Fault`1">
      <summary>
            A fault is a system-generated message that is published when an exception occurs while processing a message.
            </summary>
      <typeparam name="TMessage">The type of message that threw the exception</typeparam>
    </member>
    <member name="M:MassTransit.Fault`1.#ctor(`0,System.Exception)">
      <summary>
            Creates a new fault message for the failed message
            </summary>
      <param name="ex">The exception thrown by the message consumer</param>
      <param name="message">The message that was being processed when the exception was thrown</param>
    </member>
    <member name="P:MassTransit.Fault`1.FailedMessage">
      <summary>
            The message that failed to be consumed
            </summary>
    </member>
    <member name="P:MassTransit.Fault`1.Messages">
      <summary>
            Messages associated with the exception
            </summary>
    </member>
    <member name="P:MassTransit.Fault`1.OccurredAt">
      <summary>
            When the exception occurred
            </summary>
    </member>
    <member name="P:MassTransit.Fault`1.StackTrace">
      <summary>
            A stack trace related to the exception
            </summary>
    </member>
    <member name="T:MassTransit.Fault`2">
      <summary>
            A fault is a system-generated message that is published when an exception occurs while processing a message.
            </summary>
      <typeparam name="TMessage">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="M:MassTransit.Fault`2.#ctor(`0,System.Exception)">
      <summary>
            Creates a new Fault message for the failed correlated message
            </summary>
      <param name="ex">
      </param>
      <param name="message">
      </param>
    </member>
    <member name="T:MassTransit.Pipeline.IEndpointSubscriptionEvent">
      <summary>
            Interface that implementors wishing to be notified on subscription events should
            implement.
            </summary>
    </member>
    <member name="T:MassTransit.Pipeline.IInboundMessagePipeline">
      <summary>
            Implemented by classes that can be placed in the inbound message pipeline. See
            <see cref="T:MassTransit.Pipeline.IPipelineSink`1" /> for sink documentation.
            </summary>
    </member>
    <member name="M:MassTransit.Pipeline.IInboundMessagePipeline.Configure(System.Action{MassTransit.Pipeline.IInboundPipelineConfigurator})">
      <summary>
            Called when the pipeline part is being configured, during the initial setup
            of the message bus, allowing the pipeline part to provide a configurator
            implementation/instance of its own.
            </summary>
      <param name="configureCallback">A callback that may be called (directly) from
            the implementing method. The pipeline sink may choose the configurator instance to
            pass to this action.</param>
    </member>
    <member name="M:MassTransit.Pipeline.IInboundMessagePipeline.Configure``1(System.Func{MassTransit.Pipeline.IInboundPipelineConfigurator,``0})">
      <summary>
        <see cref="M:MassTransit.Pipeline.IInboundMessagePipeline.Configure(System.Action{MassTransit.Pipeline.IInboundPipelineConfigurator})" />
      </summary>
    </member>
    <member name="T:MassTransit.Pipeline.ISubscriptionEvent">
      <summary>
            Notifies when changes to the subscribed message types changes in the pipeline.
            </summary>
    </member>
    <member name="M:MassTransit.Pipeline.ISubscriptionEvent.SubscribedTo``1">
      <summary>
            Notify of a subscription for a message.
            </summary>
      <typeparam name="TMessage">Message type</typeparam>
      <returns>The corresponding action for unsubscription</returns>
    </member>
    <member name="M:MassTransit.Pipeline.ISubscriptionEvent.SubscribedTo``2(``1)">
      <typeparam name="TMessage">Message type</typeparam>
      <typeparam name="TKey">Type of correlation key </typeparam>
      <returns>The corresponding action for unsubscription</returns>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.MessageRouter`1">
      <summary>
            Routes a message to all of the connected message sinks without modification
            </summary>
    </member>
    <member name="P:MassTransit.Pipeline.Sinks.MessageRouter`1.SinkCount">
      <summary>
            Gets the number of pipelink sinks this message router
            has.
            </summary>
    </member>
    <member name="M:MassTransit.SagaSubscriptionConfiguratorExtensions.Saga``1(MassTransit.SubscriptionConfigurators.SubscriptionBusServiceConfigurator,MassTransit.Saga.ISagaRepository{``0})">
      <summary>
            Configure a saga subscription
            </summary>
      <typeparam name="TSaga">
      </typeparam>
      <param name="configurator">
      </param>
      <param name="sagaRepository">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.SagaSubscriptionConfiguratorExtensions.SubscribeSaga``1(MassTransit.IServiceBus,MassTransit.Saga.ISagaRepository{``0})">
      <summary>
            Connects the saga to the service bus
            </summary>
      <typeparam name="TSaga">The consumer type</typeparam>
      <param name="bus">
      </param>
      <param name="sagaRepository">
      </param>
    </member>
    <member name="T:MassTransit.Serialization.IMessageSerializer">
      <summary>
            Message Serialization implementors should handle the nitty-gritty
            details of writing object instances to streams and reading them back
            up from streams.
            </summary>
    </member>
    <member name="M:MassTransit.Serialization.IMessageSerializer.Serialize``1(System.IO.Stream,MassTransit.ISendContext{``0})">
      <summary>
            Serialize the message to the stream
            </summary>
      <typeparam name="T">The implicit type of the message to serialize</typeparam>
      <param name="stream">The stream to write the context to</param>
      <param name="context">The context to send</param>
    </member>
    <member name="M:MassTransit.Serialization.IMessageSerializer.Deserialize(MassTransit.IReceiveContext)">
      <summary>
            Deserialize a message from the stream by reading the 
            bits in the <see cref="P:MassTransit.IReceiveContext.BodyStream" />
            and hydrating the context with that.
            </summary>
      <param name="context">The context to deserialize</param>
      <returns>An object that was deserialized</returns>
    </member>
    <member name="P:MassTransit.Serialization.IMessageSerializer.ContentType">
      <summary>
            The content type that identifies the message serializer
            </summary>
    </member>
    <member name="T:MassTransit.Serialization.Envelope">
      <summary>
            The envelope in use for storing meta-data/out-of-band data and message object data.
            </summary>
    </member>
    <member name="M:MassTransit.Serialization.Envelope.Create``1(MassTransit.ISendContext{``0})">
      <summary>
            Creates a new envelope using the passed send context.
            </summary>
      <typeparam name="T">The type of message</typeparam>
      <param name="context">Context to write to the envelope</param>
      <returns>The constructed envelope</returns>
    </member>
    <member name="T:MassTransit.Serialization.EnvelopeExtensions">
      <summary>
            Extensions to the <see cref="T:MassTransit.Serialization.Envelope" /> class dealing with transferring data
            from the context to the envelope or vice versa.
            </summary>
    </member>
    <member name="M:MassTransit.Serialization.EnvelopeExtensions.SetUsingEnvelope(MassTransit.IReceiveContext,MassTransit.Serialization.Envelope)">
      <summary>
            Sets the contextual data based on what was found in the envelope. Used by the inbound
            transports as the receive context needs to be hydrated from the actual data that was 
            transferred through the transport as payload.
            </summary>
      <param name="context">The context to write data to, from the envelope</param>
      <param name="envelope">The envelope that contains the data to read into the context</param>
    </member>
    <member name="M:MassTransit.Serialization.EnvelopeExtensions.SetUsingContext(MassTransit.Serialization.Envelope,MassTransit.ISendContext)">
      <summary>
            Transfers all contextual data to the envelop. 
            As such it 'sets the envelope data to that of the context'. Used by the outbound
            transports as the envelope needs to be hydrated from the meta-data and message object
            that is being passed down the outbound pipeline to the transport.
            </summary>
      <param name="envelope">Envelope instance to hydrate with context data.</param>
      <param name="context">The context to take the contextual data from.</param>
    </member>
    <member name="M:MassTransit.HealthClientConfiguratorExtensions.UseHealthMonitoring(MassTransit.BusConfigurators.ServiceBusConfigurator,System.Int32)">
      <summary>
            Specifies that the service bus will be using health monitoring. This means that
            the bus will publish heart beats and respond to ping messages. For more information,
            see http://readthedocs.org/docs/masstransit/en/latest/overview/standardservices.html
            </summary>
      <param name="configurator">Configurator that the extension method is invoked upon.</param>
      <param name="heartbeatInterval">The heartbeat interval in seconds (one heartbeat evey n seconds)</param>
    </member>
    <member name="T:MassTransit.Saga.ISaga">
      <summary>
            Defines a component as a saga
            </summary>
    </member>
    <member name="T:MassTransit.Saga.Orchestrates`1">
      <summary>
            Specifies that a class implementing ISaga consumes TMessage as part of the saga
            </summary>
      <typeparam name="TMessage">The type of message to consume</typeparam>
    </member>
    <member name="T:MassTransit.Saga.InitiatedBy`1">
      <summary>
            Specifies that the message type TMessage starts a new saga. 
            </summary>
      <typeparam name="TMessage">
      </typeparam>
    </member>
    <member name="T:MassTransit.Services.Subscriptions.Client.SubscriptionServiceMessageProducer">
      <summary>
            The message producer is used to send subscription updates to the central subscription coordinator.
            </summary>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionServiceMessageProducer.#ctor(MassTransit.Subscriptions.Coordinator.SubscriptionRouter,MassTransit.IEndpoint)">
      <summary>
            Initializes a new instance of the <see cref="T:MassTransit.Services.Subscriptions.Client.SubscriptionServiceMessageProducer" /> class.
            </summary>
      <param name="router">The router.</param>
      <param name="endpoint">The endpoint.</param>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionServiceMessageProducer.OnSubscriptionAdded(MassTransit.Subscriptions.Messages.SubscriptionAdded)">
      <summary>
            Called when a subscription was added.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionServiceMessageProducer.OnSubscriptionRemoved(MassTransit.Subscriptions.Messages.SubscriptionRemoved)">
      <summary>
            Called when a subscription was removed.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionServiceMessageProducer.OnComplete">
      <summary>
            Called when the observation is complete and we should go away
            </summary>
    </member>
    <member name="M:MassTransit.SubscriptionClientConfiguratorExtensions.UseSubscriptionService(MassTransit.BusConfigurators.ServiceBusConfigurator,System.String)">
      <summary>
            Sets the address of the Subscription Service which routes messages to multiple subscribers
            from a single publisher.  The address of the Subscription Service is used by both 
            publishers and subscribers, while routing is carried out by MassTransit.RuntimeServices
            </summary>
      <param name="configurator">
      </param>
      <param name="subscriptionServiceUri">
      </param>
    </member>
    <member name="M:MassTransit.SubscriptionClientConfiguratorExtensions.UseSubscriptionService(MassTransit.BusConfigurators.ServiceBusConfigurator,System.Uri)">
      <summary>
            Sets the address of the Subscription Service which routes messages to multiple subscribers
            from a single publisher.  The address of the Subscription Service is used by both 
            publishers and subscribers, while routing is carried out by MassTransit.RuntimeServices
            </summary>
    </member>
    <member name="M:MassTransit.SubscriptionClientConfiguratorExtensions.UseSubscriptionService(MassTransit.BusConfigurators.ServiceBusConfigurator,System.Action{MassTransit.Services.Subscriptions.Configuration.SubscriptionClientConfigurator})">
      <summary>
            Sets the address of the Subscription Service which routes messages to multiple subscribers
            from a single publisher.  The address of the Subscription Service is used by both 
            publishers and subscribers, while routing is carried out by MassTransit.RuntimeServices
            </summary>
    </member>
    <member name="T:MassTransit.Services.Timeout.Messages.CancelTimeout">
      <summary>
            Used by the Timeout Service, cancels the scheduled timeout with the specified CorrelationId
            </summary>
    </member>
    <member name="P:MassTransit.Services.Timeout.Messages.CancelTimeout.CorrelationId">
      <summary>
            Gets the correlation id.
            </summary>
    </member>
    <member name="P:MassTransit.Services.Timeout.Messages.CancelTimeout.Tag">
      <summary>
            Gets or sets the tag.
            </summary>
      <value>
            The tag.
            </value>
    </member>
    <member name="P:MassTransit.Services.Timeout.Messages.TimeoutMessageBase.Tag">
      <summary>
            The tag associated with the timeout message
            This is mainly because we can't publish type-specific messages yet. 
            We really want to be able to schedule a timeout and specify a message type
            to publish on the timeout, but that is going to be tough to handle (period).
            </summary>
    </member>
    <member name="P:MassTransit.Services.Timeout.Messages.TimeoutMessageBase.TimeoutAt">
      <summary>
            The time (in UTC) when the timeout expires
            </summary>
    </member>
    <member name="P:MassTransit.Services.Timeout.Messages.TimeoutMessageBase.CorrelationId">
      <summary>
            The CorrelationId to use when publishing the timeout message
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.BusUri">
      <summary>
            The control bus address of the instance this subscription belongs to
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.PeerId">
      <summary>
            The PeerId of the remote subscription
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.PeerUri">
      <summary>
            The control bus address of the peer
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.SubscriptionId">
      <summary>
            The subscription id for this instance of the subscription
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.EndpointUri">
      <summary>
            The endpointUri where messages should be delivered matching the subscription
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.MessageName">
      <summary>
            The message name of the subscription
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.CorrelationId">
      <summary>
            The correlationId of the subscription if it is correlated
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.Created">
      <summary>
            The time the subscription was created
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Coordinator.PersistentSubscription.Updated">
      <summary>
            The time the subscription was last updated
            </summary>
    </member>
    <member name="T:MassTransit.Subscriptions.Coordinator.SubscriptionObserver">
      <summary>
            Implemented by observers of subscriptions - subscriptions are locally published inside of the bus,
            so if you're implementing a transport; implementing this interface will allow you to bind whatever
            topics/queues/exchanges/etc to your inbound queue 
            (e.g. if doing equivalent of RMQ:publish w/ fanout, MSMQ: multicast, ZMQ: PGM). 
            This interface is also used internally to route subscriptions and manage their lifestyles.
            </summary>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.SubscriptionObserver.OnSubscriptionAdded(MassTransit.Subscriptions.Messages.SubscriptionAdded)">
      <summary>
            Called when a subscription is registered in the service bus.
            </summary>
      <param name="message">The subscription added message.</param>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.SubscriptionObserver.OnSubscriptionRemoved(MassTransit.Subscriptions.Messages.SubscriptionRemoved)">
      <summary>
            Called when a subscription is unregistered in the service bus.
            </summary>
      <param name="message">The subscription removed message.</param>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.SubscriptionObserver.OnComplete">
      <summary>
            Called when the observation is complete and we should go away
            </summary>
    </member>
    <member name="T:MassTransit.Subscriptions.Coordinator.SubscriptionRouter">
      <summary>
            Implementers take care of 
            </summary>
    </member>
    <member name="T:MassTransit.Subscriptions.Coordinator.BusSubscriptionConnector">
      <summary>
            Connects received subscriptions to a local bus.
            The connector is responsible for picking between the data and the control bus.
            </summary>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.BusSubscriptionConnector.#ctor(MassTransit.IServiceBus)">
      <summary>
            Initializes a new instance of the <see cref="T:MassTransit.Subscriptions.Coordinator.BusSubscriptionConnector" /> class.
            </summary>
      <param name="bus">The bus.</param>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.BusSubscriptionConnector.OnSubscriptionAdded(MassTransit.Subscriptions.Messages.SubscriptionAdded)">
      <summary>
            Adds a remote subscription to the route path or a local data or control bus 
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.BusSubscriptionConnector.OnSubscriptionRemoved(MassTransit.Subscriptions.Messages.SubscriptionRemoved)">
      <summary>
            Removes a remote subscription from the route path or a local data or control bus 
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:MassTransit.Subscriptions.Messages.Subscription">
      <summary>
            Describes a subscription of an <see cref="T:MassTransit.Transports.Endpoint" /> to a particular message.
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.Subscription.SubscriptionId">
      <summary>
            Gets the subscription id.
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.Subscription.EndpointUri">
      <summary>
            Gets the endpoint URI.
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.Subscription.MessageName">
      <summary>
            Gets the name of the subscription message.
            </summary>
      <value>
            The name of the message.
            </value>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.Subscription.CorrelationId">
      <summary>
            Gets the correlation id.
            </summary>
    </member>
    <member name="T:MassTransit.Subscriptions.Coordinator.SubscriptionMessageConsumer">
      <summary>
            The Subscription Message Consumer handles subscription update messages send from the Subscription Service. 
            </summary>
    </member>
    <member name="M:MassTransit.Subscriptions.Coordinator.SubscriptionMessageConsumer.#ctor(MassTransit.Subscriptions.Coordinator.SubscriptionRouter,System.String,System.Uri[])">
      <summary>
            Initializes a new instance of the <see cref="T:MassTransit.Subscriptions.Coordinator.SubscriptionMessageConsumer" /> class.
            </summary>
      <param name="router">The router.</param>
      <param name="network">The network.</param>
      <param name="ignoredSourceAddresses">The ignored source addresses.</param>
    </member>
    <member name="T:MassTransit.Subscriptions.IUnsubscribeAction">
      <summary>
            Used to wrap an UnsubscribeAction in a disposable block
            </summary>
    </member>
    <member name="M:MassTransit.Subscriptions.IUnsubscribeAction.Add(MassTransit.UnsubscribeAction)">
      <summary>
            Add additional actions to the unsubscribe action
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:MassTransit.Subscriptions.ISubscriptionReference.OnStop">
      <summary>
            Called when the bus is being stopped
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.PeerSubscription.PeerId">
      <summary>
            The instance of the client that created the subscription
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.PeerSubscription.MessageNumber">
      <summary>
            The message number sent by this client
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.PeerSubscriptionMessage.PeerId">
      <summary>
            The instance of the client that created the subscription
            </summary>
    </member>
    <member name="P:MassTransit.Subscriptions.Messages.PeerSubscriptionMessage.MessageNumber">
      <summary>
            The message number sent by this client
            </summary>
    </member>
    <member name="T:MassTransit.Subscriptions.SubscriptionBusService">
      <summary>
            Manages the subscription and un subscription of message consumers to the
            service bus as part of the bus lifecycle.
            
            As a bus service, once the bus is started and operational, this service 
            will get started. At this point, any registered consumers and sagas will
            be subscribed to the bus. 
            
            When stop is called, those subscriptions will be removed unless the
            registration information indicated that the subscription is meant to be
            persistent, and not removed on service shutdown.
            </summary>
    </member>
    <member name="T:MassTransit.Testing.Scenarios.TestScenario">
      <summary>
            A test scenario that allows the tester to
            get hold of what messages were published, skipped, sent and received.
            Inherits IDisposable.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.TestScenario.InputBus">
      <summary>
            Gets the input bus. This is the bus that has *incoming* messages, i.e. the bus
            that you receive messages from.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.TestScenario.OutputBus">
      <summary>
            Gets the output bus. This is the bus that has *outgoing* messages, i.e. the bus
            that you publish and send on.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.TestScenario.Published">
      <summary>
            The list of published messages is contained within this instance.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.TestScenario.Received">
      <summary>
            The list of received messages is contained within this instance.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.TestScenario.Sent">
      <summary>
            The list of send messages is contained within this instance.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.TestScenario.Skipped">
      <summary>
            The list of skipped messages is contained within this instance.
            </summary>
    </member>
    <member name="T:MassTransit.Testing.Scenarios.EndpointTestScenario">
      <summary>
            Adds the further feature onto <see cref="T:MassTransit.Testing.Scenarios.TestScenario" /> of having 
            an endpoint cache and an endpoint factory. This is useful if you are 
            testing that you can send messages to what can be considered 'endpoints' rather than
            just 'subscribers'. It's more in line to the usage scenario of request-reply or fire-and-forget
            rather than publish-subscribe.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.EndpointTestScenario.EndpointCache">
      <summary>
            Gets the endpoint cache. Use this instance to find the <see cref="T:MassTransit.IEndpoint" />s.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Scenarios.EndpointTestScenario.EndpointFactory">
      <summary>
            Gets the endpoint factory.
            </summary>
    </member>
    <member name="T:MassTransit.Testing.BusTestScenario">
      <summary>
            A bus test scenario tests a full service bus. see also <see cref="T:MassTransit.Testing.Scenarios.EndpointTestScenario" /> and <see cref="T:MassTransit.Testing.Scenarios.TestScenario" /> for documentation
            and the properties on the interfaces.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.BusTestScenario.Bus">
      <summary>
            Gets the service bus that is active during the test.
            </summary>
    </member>
    <member name="T:MassTransit.Testing.BusTestScenarioExtensions">
      <summary>
            Extension methods for the bus test scenarios.
            </summary>
    </member>
    <member name="M:MassTransit.Testing.BusTestScenarioExtensions.SetConcurrentConsumerLimit(MassTransit.Testing.Configurators.ScenarioConfigurator{MassTransit.Testing.BusTestScenario},System.Int32)">
      <summary>
            Sets the concurrent consumer limit for the <see cref="T:MassTransit.Testing.BusTestScenario" /> that is
            under test.
            </summary>
      <param name="configurator">The configurator passed from the XXXTestFactory interfaces' "New(HandlerTestInstanceConfigurator{TScenario,TMessage})" method.</param>
      <param name="value">The value for this setting.</param>
    </member>
    <member name="P:MassTransit.Testing.Configurators.TestConfiguratorResult.Disposition">
      <summary>
            The disposition of the result, any Failure items will prevent
            the configuration from completing.
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Configurators.TestConfiguratorResult.Key">
      <summary>
            The key associated with the result (chained if configurators are nested)
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Configurators.TestConfiguratorResult.Message">
      <summary>
            The message associated with the result
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Configurators.TestConfiguratorResult.Value">
      <summary>
            The value associated with the result
            </summary>
    </member>
    <member name="M:MassTransit.Testing.TestInstance.Execute">
      <summary>
            Execute the test actions
            </summary>
    </member>
    <member name="P:MassTransit.Testing.TestInstance.Received">
      <summary>
            Messages that were received by any endpoint during the execution of the test
            </summary>
    </member>
    <member name="P:MassTransit.Testing.TestInstance.Sent">
      <summary>
            Messages that were send by any endpoint during the execution of the test
            </summary>
    </member>
    <member name="P:MassTransit.Testing.TestInstance.Skipped">
      <summary>
            Messages that were not received by any handler, consumer, or instance during the execution of the test
            </summary>
    </member>
    <member name="P:MassTransit.Testing.TestInstance.Published">
      <summary>
            Messages that were published by an bus (does not mean they were actually sent, just published)
            </summary>
    </member>
    <member name="T:MassTransit.Testing.ScenarioBuilders.EndpointScenarioBuilder`1">
      <summary>
            And endpoint scenario builder implementation ties together the scenario 
            with the underlying infrastructure.
            </summary>
      <typeparam name="TScenario">See <see cref="T:MassTransit.Testing.BusTestScenario" />, <see cref="T:MassTransit.Testing.Scenarios.EndpointTestScenario" /> and <see cref="T:MassTransit.Testing.Scenarios.TestScenario" />
            for feeding as the generic parameter.</typeparam>
    </member>
    <member name="M:MassTransit.Testing.ScenarioBuilders.EndpointScenarioBuilder`1.ConfigureEndpointFactory(System.Action{MassTransit.EndpointConfigurators.EndpointFactoryConfigurator})">
      <summary>
            Endpoint scenario builders may call this method to configure the endpoint factory. Call this method
            to customize how the endpoint uris are built. Example:
            <code>
            ConfigureEndpointFactory(x =&gt;
               {
               	x.UseRabbitMq();
               });
            </code></summary>
      <param name="configureCallback">
      </param>
    </member>
    <member name="M:MassTransit.Testing.ScenarioBuilders.BusScenarioBuilder.ConfigureBus(System.Action{MassTransit.BusConfigurators.ServiceBusConfigurator})">
      <summary>
            Configure any bus-specific items as part of building the test scenario
            </summary>
      <param name="configureCallback">
      </param>
    </member>
    <member name="M:MassTransit.Testing.ScenarioBuilders.BusScenarioBuilder.ConfigureSubscriptions(System.Action{MassTransit.SubscriptionConfigurators.SubscriptionBusServiceConfigurator})">
      <summary>
            Configure the subscriptions for a test using this scenario.
            </summary>
      <param name="configureCallback">
      </param>
    </member>
    <member name="T:MassTransit.Testing.ScenarioBuilders.BusScenarioBuilderImpl">
      <summary>
            Implementation for the test scenario, but abstract for others to customize it. Sets some defaults in the c'tor, which you
            can override with the <see cref="M:MassTransit.Testing.ScenarioBuilders.BusScenarioBuilderImpl.ConfigureBus(System.Action{MassTransit.BusConfigurators.ServiceBusConfigurator})" /> and <see cref="M:MassTransit.Testing.ScenarioBuilders.BusScenarioBuilderImpl.ConfigureSubscriptions(System.Action{MassTransit.SubscriptionConfigurators.SubscriptionBusServiceConfigurator})" /> methods.
            </summary>
    </member>
    <member name="M:MassTransit.Testing.ScenarioBuilders.BusScenarioBuilderImpl.#ctor(System.Uri)">
      <summary>
            c'tor
            </summary>
      <param name="uri">The uri to receive from during the scenario.</param>
    </member>
    <member name="T:MassTransit.Testing.ScenarioBuilders.LoopbackBusScenarioBuilder">
      <summary>
            Scenario builder for the loopback style of bus. This is basically an
            in-memory bus.
            </summary>
    </member>
    <member name="T:MassTransit.IEndpointCache">
      <summary>
            The endpoint factory methods used to retrieve objects implementing IEndpoint from Uris.
            </summary>
    </member>
    <member name="M:MassTransit.IEndpointCache.GetEndpoint(System.Uri)">
      <summary>
            Returns an IEndpoint for the Uri specified. If the endpoint has not yet been created,
            the factory will attempt to create an endpoint for the Uri.
            </summary>
      <param name="uri">The Uri to resolve to an endpoint</param>
      <returns>An IEndpoint instance - never null; if it cannot be gotten, an exception is thrown instead.</returns>
      <exception cref="T:MassTransit.Exceptions.EndpointException">Could not build up the endpoint with the 
            <see cref="T:MassTransit.Transports.IEndpointFactory" /> configured for the bus</exception>
      <exception cref="T:MassTransit.Exceptions.ConfigurationException">The scheme in the uri didn't have a corresponding
            <see cref="T:MassTransit.Transports.ITransportFactory" /> configured in the bus; the bus doesn't know how to
            send over such a scheme/transport protocol.</exception>
    </member>
    <member name="P:MassTransit.Testing.Subjects.ConsumerTestSubject`1.Received">
      <summary>
            The messages that were received by the handler
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Subjects.SagaTestSubject`1.Received">
      <summary>
            The messages that were received by the handler
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Subjects.SagaTestSubject`1.Created">
      <summary>
            The sagas that were created during the test
            </summary>
    </member>
    <member name="T:MassTransit.Transports.IEndpointFactory">
      <summary>
            Implementors are responsible for creating endpoints based on passed uris.
            </summary>
    </member>
    <member name="M:MassTransit.Transports.IEndpointFactory.CreateEndpoint(System.Uri)">
      <summary>
            Creates a new endpoint for the specified URI
            </summary>
      <param name="uri">To uri to create the endpoint for</param>
      <returns>The endpoint instance that was created from the uri</returns>
    </member>
    <member name="M:MassTransit.Transports.IEndpointFactory.AddTransportFactory(MassTransit.Transports.ITransportFactory)">
      <summary>
            Adds a transport factory to the endpoint factory
            </summary>
      <param name="factory">Factory to add</param>
    </member>
    <member name="T:MassTransit.IEndpoint">
      <summary>
        <para>IEndpoint is implemented by an endpoint. An endpoint is an addressable location on the network.</para>
        <para>In MassTransit, the endpoint ties together the inbound transport, the outbound transport,
            the error transport that ships problematic messages to the error queue, mesage retry trackers
            and serialization.</para>
        <para>It is up to the transports themselves to implement the correct connection handling and to
            to create the <see cref="T:MassTransit.IReceiveContext" /> from the bytes on the wire, which hands the message
            over to MassTransit's internals.
            </para>
      </summary>
    </member>
    <member name="M:MassTransit.IEndpoint.Send``1(MassTransit.ISendContext{``0})">
      <summary>
            Send to the endpoint
            </summary>
      <typeparam name="T">The type of the message to send</typeparam>
      <param name="context">Send context to generate the in-transport message from. Contains
            out-of-band data such as message ids, correlation ids, headers, and in-band data
            such as the actual data of the message to send.</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send``1(``0)">
      <summary>
            Send a message to an endpoint
            </summary>
      <typeparam name="T">The message type</typeparam>
      <param name="message">The message to send</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send``1(``0,System.Action{MassTransit.ISendContext{``0}})">
      <summary>
            Send a message to an endpoint
            </summary>
      <typeparam name="T">The message type</typeparam>
      <param name="message">The message to send</param>
      <param name="contextCallback">A callback method to modify the send context for the message</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send(System.Object)">
      <summary>
            Sends an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send(System.Object,System.Type)">
      <summary>
            Sends an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
      <param name="messageType">The type of the message (use message.GetType() if desired)</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send(System.Object,System.Action{MassTransit.ISendContext})">
      <summary>
            Sends an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
      <param name="contextCallback">Allows the context values to be specified</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send(System.Object,System.Type,System.Action{MassTransit.ISendContext})">
      <summary>
            Sends an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
      <param name="messageType">The type of the message (use message.GetType() if desired)</param>
      <param name="contextCallback">Allows the context values to be specified</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send``1(System.Object)">
      <summary>
            Sends an interface message, initializing the properties of the interface using the anonymous
            object specified
            </summary>
      <typeparam name="T">The interface type to send</typeparam>
      <param name="values">The property values to initialize on the interface</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Send``1(System.Object,System.Action{MassTransit.ISendContext{``0}})">
      <summary>
            Sends an interface message, initializing the properties of the interface using the anonymous
            object specified
            </summary>
      <typeparam name="T">The interface type to send</typeparam>
      <param name="values">The property values to initialize on the interface</param>
      <param name="contextCallback">A callback method to modify the send context for the message</param>
    </member>
    <member name="M:MassTransit.IEndpoint.Receive(System.Func{MassTransit.IReceiveContext,System.Action{MassTransit.IReceiveContext}},System.TimeSpan)">
      <summary>
        <para>Receive from the endpoint by passing a function that can preview the message: if the caller
            chooses to accept it, return a method that will consume the message. The first argument of the 
            Func is created by the transport and this is what callers of receive must inspect
            to find what receivers (the return value Action{IReceiveContext}) are interested in the 
            received data.</para>
        <para>Returns after the specified timeout if no message is available.</para>
      </summary>
      <param name="receiver">The function to preview/consume the message</param>
      <param name="timeout">The time to wait for a message to be available</param>
    </member>
    <member name="P:MassTransit.IEndpoint.Address">
      <summary>
            The address of the endpoint
            </summary>
    </member>
    <member name="P:MassTransit.IEndpoint.InboundTransport">
      <summary>
            The inbound transport for the endpoint
            </summary>
    </member>
    <member name="P:MassTransit.IEndpoint.OutboundTransport">
      <summary>
            The outbound transport for the endpoint
            </summary>
    </member>
    <member name="P:MassTransit.IEndpoint.ErrorTransport">
      <summary>
            The transport where faulting messages (poison messages) are sent
            </summary>
    </member>
    <member name="P:MassTransit.IEndpoint.Serializer">
      <summary>
            The message serializer being used by the endpoint
            </summary>
    </member>
    <member name="P:MassTransit.Testing.Subjects.HandlerTestSubject`1.Received">
      <summary>
            The messages that were received by the handler
            </summary>
    </member>
    <member name="T:MassTransit.Saga.ISagaPolicy`2">
      <summary>
            A saga policy defines how the pipeline should handle messages when being routed 
            to the saga. Checks are made for the existence of a saga, whether the message should
            create a new saga, or otherwise
            </summary>
      <typeparam name="TSaga">The saga that will handle the message</typeparam>
      <typeparam name="TMessage">The message that will be handled by the saga</typeparam>
    </member>
    <member name="M:MassTransit.Saga.ISagaPolicy`2.CanCreateInstance(MassTransit.IConsumeContext{`1})">
      <summary>
            Determines if the message is able to create a new instance of the saga
            </summary>
      <param name="context">The consumer context of the message</param>
      <returns>True if a new instance of the saga can be created, otherwise false</returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaPolicy`2.CreateInstance(MassTransit.IConsumeContext{`1},System.Guid)">
      <summary>
            Creates a new instance of the saga using the data in the message context
            </summary>
      <param name="context">The consumer context of the message</param>
      <param name="sagaId">
      </param>
      <returns>A newly created saga instance</returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaPolicy`2.GetNewSagaId(MassTransit.IConsumeContext{`1})">
      <summary>
            Returns the saga id that should be used for a newly created saga instance, based on the policy
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaPolicy`2.CanUseExistingInstance(MassTransit.IConsumeContext{`1})">
      <summary>
            Determines if the message can be delivered to an existing saga instance
            </summary>
      <param name="context">The consumer context of the message</param>
      <returns>True if the message can be delivered to the saga instance, otherwise false</returns>
    </member>
    <member name="M:MassTransit.Saga.ISagaPolicy`2.CanRemoveInstance(`0)">
      <summary>
            Determines if the saga instance can be removed, using the saga configuration information
            </summary>
      <param name="instance">The saga instance to check</param>
      <returns>True if the saga instance can be removed, otherwise false</returns>
    </member>
    <member name="T:MassTransit.IServiceBus">
      <summary>
              The base service bus interface
            </summary>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish``1(``0)">
      <summary>
        <para>Publishes a message to all subscribed consumers for the message type as specified
            by the generic parameter. The second parameter allows the caller to customize the
            outgoing publish context and set things like headers on the message.</para>
        <para>
            Read up on publishing: http://readthedocs.org/docs/masstransit/en/latest/overview/publishing.html
            </para>
      </summary>
      <typeparam name="T">The type of the message</typeparam>
      <param name="message">The messages to be published</param>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish``1(``0,System.Action{MassTransit.IPublishContext{``0}})">
      <summary>
        <para>Publishes a message to all subscribed consumers for the message type as specified
            by the generic parameter. The second parameter allows the caller to customize the
            outgoing publish context and set things like headers on the message.</para>
        <para>
            Read up on publishing: http://readthedocs.org/docs/masstransit/en/latest/overview/publishing.html
            </para>
      </summary>
      <typeparam name="T">The type of the message</typeparam>
      <param name="message">The messages to be published</param>
      <param name="contextCallback">A callback that gives the caller
            access to the publish context.</param>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish(System.Object)">
      <summary>
            Publishes an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish(System.Object,System.Type)">
      <summary>
            Publishes an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
      <param name="messageType">The type of the message (use message.GetType() if desired)</param>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish(System.Object,System.Action{MassTransit.IPublishContext})">
      <summary>
            Publishes an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
      <param name="contextCallback">A callback that gives the caller
            access to the publish context.</param>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish(System.Object,System.Type,System.Action{MassTransit.IPublishContext})">
      <summary>
            Publishes an object as a message, using the message type specified. If the object cannot be cast
            to the specified message type, an exception will be thrown.
            </summary>
      <param name="message">The message object</param>
      <param name="messageType">The type of the message (use message.GetType() if desired)</param>
      <param name="contextCallback">A callback that gives the caller
            access to the publish context.</param>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish``1(System.Object)">
      <summary>
        <see cref="M:MassTransit.IServiceBus.Publish``1(``0)" />: this is a "dynamically"
            typed overload - give it an interface as its type parameter,
            and a loosely typed dictionary of values and the MassTransit
            underlying infrastructure will populate an object instance
            with the passed values. It actually does this with DynamicProxy
            in the background.
            </summary>
      <typeparam name="T">The type of the interface or
            non-sealed class with all-virtual members.</typeparam>
      <param name="bus">The bus to publish on.</param>
      <param name="values">The dictionary of values to place in the
            object instance to implement the interface.</param>
    </member>
    <member name="M:MassTransit.IServiceBus.Publish``1(System.Object,System.Action{MassTransit.IPublishContext{``0}})">
      <summary>
        <see cref="!:Publish&lt;T&gt;(MassTransit.IServiceBus,object)" />: this
            overload further takes an action; it allows you to set <see cref="T:MassTransit.IPublishContext" />
            meta-data. Also <see cref="M:MassTransit.IServiceBus.Publish``1(``0)" />.
            </summary>
      <typeparam name="T">The type of the message to publish</typeparam>
      <param name="bus">The bus to publish the message on.</param>
      <param name="values">The dictionary of values to become hydrated and
            published under the type of the interface.</param>
      <param name="contextCallback">The context callback.</param>
    </member>
    <member name="M:MassTransit.IServiceBus.GetEndpoint(System.Uri)">
      <summary>
            Looks an endpoint up by its uri.
            </summary>
      <param name="address">
      </param>
      <returns>The endpoint that corresponds to the uri passed</returns>
    </member>
    <member name="M:MassTransit.IServiceBus.Configure(System.Func{MassTransit.Pipeline.IInboundPipelineConfigurator,MassTransit.UnsubscribeAction})">
      <summary>
              Not sure this is going to make it, but trying a new approach.
            </summary>
      <param name="configure">
      </param>
      <returns>An unsubscribe action that can be called to unsubscribe
            what was configured to be subscribed with the func passed. <see cref="T:MassTransit.UnsubscribeAction" />.</returns>
    </member>
    <member name="M:MassTransit.IServiceBus.GetService(System.Type)">
      <summary>
            Get the first service with the matching type, throwing an InvalidOperationException if none is found.
            </summary>
      <param name="type">The type of service to get.</param>
      <returns>The first service of type T.</returns>
    </member>
    <member name="M:MassTransit.IServiceBus.TryGetService(System.Type,MassTransit.IBusService@)">
      <summary>
            Try to get the first service with the matching type.
            </summary>
      <param name="type">The type of service to get.</param>
      <param name="result">The service.</param>
      <returns>Whether the service was found.</returns>
    </member>
    <member name="P:MassTransit.IServiceBus.Endpoint">
      <summary>
              The endpoint from which messages are received
            </summary>
    </member>
    <member name="P:MassTransit.IServiceBus.InboundPipeline">
      <summary>
            Gets the inbound message pipeline.
            </summary>
    </member>
    <member name="P:MassTransit.IServiceBus.OutboundPipeline">
      <summary>
            Gets the outbound message pipeline.
            </summary>
    </member>
    <member name="P:MassTransit.IServiceBus.ControlBus">
      <summary>
            Gets the control bus that can be used 
            to add/remove subscripts, move message 
            handlers around and tap runtime metrics
            from the service bus.
            </summary>
    </member>
    <member name="P:MassTransit.IServiceBus.EndpointCache">
      <summary>
            Gets the endpoint cache. This property is used
            by <see cref="M:MassTransit.IServiceBus.GetEndpoint(System.Uri)" /> method in turn.
            </summary>
    </member>
    <member name="P:MassTransit.IServiceBus.ShutdownTimeout">
      <summary>
            Gets or Sets the timeout used to wait for consumers to finish when shutting the bus down.
            </summary>
    </member>
    <member name="T:MassTransit.Testing.TestFactory">
      <summary>
            Factory for testing message handlers, buses and messages - received, skipped, sent and published. The builders used
            with the <see cref="T:MassTransit.Testing.TestInstanceConfigurators.TestInstanceConfigurator`1" />, defaults to the loopback bus scenario. Use the extension methods in
            <see cref="T:MassTransit.Testing.BusTestScenarioExtensions" /> to use alternative scenario builders. A builder is something that ties some component
            together.
            </summary>
    </member>
    <member name="M:MassTransit.Testing.TestFactory.ForHandler``1">
      <summary>
            Creates a new <see cref="T:MassTransit.Testing.Factories.HandlerTestFactory`2" /> for the passed message (generic parameter).
            </summary>
      <typeparam name="TMessage">The type of the message to create a test for.</typeparam>
      <returns>A 'configurator' - a handler test factory.</returns>
    </member>
    <member name="T:MassTransit.Threading.ThreadPoolConsumerPool">
      <summary>
            The default consumer pool that enqueues consumes on the thread pool.
            </summary>
    </member>
    <member name="M:MassTransit.Threading.ThreadPoolConsumerPool.Start">
      <summary>
        <para>Start the receiving thread pool.</para>
        <para>This method implements a message-based receive loop;
            so instead of having a while-loop that receives non-stop, the event channel
            ensures that receives are enqueued whenever <see cref="T:MassTransit.Events.ReceiveCompleted" /> is published
            in the event channel passed to this pool instance at construction time.</para>
      </summary>
    </member>
    <member name="T:MassTransit.Transports.ConnectionHandler`1">
      <summary>
            Wraps the management of a connection to apply reconnect and retry strategies
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MassTransit.Transports.IMessageNameFormatter">
      <summary>
            Used to format a message type into a MessageName, which can be used as a valid
            queue name on the transport
            </summary>
    </member>
    <member name="T:MassTransit.Transports.IInboundTransport">
      <summary>
            The inbound transport takes messages from the underlying transport technology and hands it to the
            Action{IReceiveContext} that can be gotten from the lookup function 
            passed to the <see cref="M:MassTransit.Transports.IInboundTransport.Receive(System.Func{MassTransit.IReceiveContext,System.Action{MassTransit.IReceiveContext}},System.TimeSpan)" /> method.
            </summary>
    </member>
    <member name="M:MassTransit.Transports.IInboundTransport.Receive(System.Func{MassTransit.IReceiveContext,System.Action{MassTransit.IReceiveContext}},System.TimeSpan)">
      <summary>
            Implementors should take messages from the inbound transport technology,
            call the lookup function to get a callback that passes messages to all
            routed sinks for the context's message type and properties and then
            ACK the receive.
            </summary>
      <param name="lookupSinkChain">A lookup function that takes a receive context
            and gives back either a non-null action handler for </param>
      <param name="timeout">The timeout to wait for the inbound transport technology to
            yield a message before giving up.</param>
    </member>
    <member name="T:MassTransit.Transports.IOutboundTransport">
      <summary>
            Transport 
            </summary>
    </member>
    <member name="T:MassTransit.Transports.IDuplexTransport">
      <summary>
            A duplex transport binds an inbound and outbound transport into a single transport capable of
            bi-directional communication.
            </summary>
    </member>
    <member name="T:MassTransit.Transports.IInboundMessageTracker">
      <summary>
            Tracks the inbound processing of messages by the endpoint. Once a message is 
            received successfully, it should be removed from the tracker. In the event a 
            message throws an exception, a retry count is tracked. Once the retry limit is exceeded,
            the message is moved to the error queue by the endpoint.
            </summary>
    </member>
    <member name="M:MassTransit.Transports.IInboundMessageTracker.IsRetryLimitExceeded(System.String,System.Exception@,System.Collections.Generic.IEnumerable{System.Action}@)">
      <summary>
            Check if the message retry limit has been exceeded for the id specified.
            </summary>
      <param name="id">The message identifier</param>
      <param name="retryException">The exception to throw in association with the error queue</param>
      <param name="faultActions">The actions to invoke that were due to the fault</param>
      <returns>True if the message should no longer be processed and moved to the error queue</returns>
    </member>
    <member name="M:MassTransit.Transports.IInboundMessageTracker.IncrementRetryCount(System.String)">
      <summary>
            Increment the retry count of the message without an exception or fault action
            </summary>
      <param name="id">The message identifier</param>
    </member>
    <member name="M:MassTransit.Transports.IInboundMessageTracker.IncrementRetryCount(System.String,System.Exception)">
      <summary>
            Increment the retry count of the message as an exception has occurred.
            </summary>
      <param name="id">The message identifier</param>
      <param name="exception">The exception that was thrown by the consumer(s)</param>
    </member>
    <member name="M:MassTransit.Transports.IInboundMessageTracker.IncrementRetryCount(System.String,System.Exception,System.Collections.Generic.IEnumerable{System.Action})">
      <summary>
            Increment the retry count of the message as an exception has occurred.
            </summary>
      <param name="id">The message identifier</param>
      <param name="exception">The exception that was thrown by the consumer(s)</param>
      <param name="faultActions">The list of actions to invoke due to the fault</param>
    </member>
    <member name="M:MassTransit.Transports.IInboundMessageTracker.MessageWasReceivedSuccessfully(System.String)">
      <summary>
            Marks the message as received successfully. This should remove the message tracking information
            from the tracker. It is suggested that for memory utilization reasons, an asynchronous timer based
            expiration also be used for messages that may be consumed by other processes.
            </summary>
      <param name="id">The message identifier</param>
    </member>
    <member name="M:MassTransit.Transports.IInboundMessageTracker.MessageWasMovedToErrorQueue(System.String)">
      <summary>
            Marks the message as moved to the error queue.
            </summary>
      <param name="id">The message identifier</param>
    </member>
    <member name="T:MassTransit.Transports.MessageName">
      <summary>
            Class encapsulating naming strategies for exchanges corresponding
            to message types.
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportSettings.Address">
      <summary>
            The address of the endpoint/transport
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportSettings.CreateIfMissing">
      <summary>
            The transport should be created if it was not found
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportSettings.IsolationLevel">
      <summary>
            The isolation level to use with the transaction if a transactional transport is used
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportSettings.PurgeExistingMessages">
      <summary>
            If the transport should purge any existing messages before reading from the queue
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportSettings.RequireTransactional">
      <summary>
            if the transactional queue is requested and required it will throw an exception if the queue 
            exists and is not transactional
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportSettings.TransactionTimeout">
      <summary>
            The timeout for the transaction if System.Transactions is supported
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportSettings.Transactional">
      <summary>
            True if the endpoint should be transactional. If Transactional is true and the endpoint already
            exists and is not transactional, an exception will be thrown.
            </summary>
    </member>
    <member name="P:MassTransit.Transports.TransportSettings.Address">
      <summary>
            The address of the endpoint
            </summary>
    </member>
    <member name="P:MassTransit.Transports.TransportSettings.Transactional">
      <summary>
            True if the endpoint should be transactional. If Transactional is true and the endpoint already
            exists and is not transactional, an exception will be thrown.
            </summary>
    </member>
    <member name="P:MassTransit.Transports.TransportSettings.RequireTransactional">
      <summary>
            if the transactional queue is requested and required it will throw an exception if the queue 
            exists and is not transactional
            </summary>
    </member>
    <member name="P:MassTransit.Transports.TransportSettings.TransactionTimeout">
      <summary>
            The timeout for the transaction if System.Transactions is supported
            </summary>
    </member>
    <member name="P:MassTransit.Transports.TransportSettings.IsolationLevel">
      <summary>
            The isolation level to use with the transaction if a transactional transport is used
            </summary>
    </member>
    <member name="P:MassTransit.Transports.TransportSettings.CreateIfMissing">
      <summary>
            The transport should be created if it was not found
            </summary>
    </member>
    <member name="P:MassTransit.Transports.TransportSettings.PurgeExistingMessages">
      <summary>
            If the transport should purge any existing messages before reading from the queue
            </summary>
    </member>
    <member name="M:MassTransit.EndpointCacheExtensions.GetEndpoint(MassTransit.IEndpointCache,System.String)">
      <summary>
            Returns an IEndpoint for the Uri string specified. If the endpoint has not yet been created,
            the factory will attempt to create an endpoint for the Uri string.
            </summary>
      <param name="cache">
      </param>
      <param name="uriString">The Uri string to resolve to an endpoint (will be checked for valid Uri syntax)</param>
      <returns>An IEndpoint instance</returns>
    </member>
    <member name="M:MassTransit.Transports.EndpointFactory.#ctor(System.Collections.Generic.IDictionary{System.String,MassTransit.Transports.ITransportFactory},System.Collections.Generic.IDictionary{System.Uri,MassTransit.Builders.EndpointBuilder},MassTransit.EndpointConfigurators.IEndpointFactoryDefaultSettings)">
      <summary>
            Creates a new endpoint factory instance
            </summary>
      <param name="transportFactories">Dictionary + contents owned by the EndpointFactory instance.</param>
      <param name="endpointBuilders">
      </param>
      <param name="defaults">
      </param>
    </member>
    <member name="P:MassTransit.Transports.IEndpointSettings.ErrorAddress">
      <summary>
            The address of the endpoint where invalid messages should be moved
            </summary>
    </member>
    <member name="P:MassTransit.Transports.IEndpointSettings.Serializer">
      <summary>
            The serializer to use for messages on the endpoint
            </summary>
    </member>
    <member name="P:MassTransit.Transports.IEndpointSettings.SupportedSerializers">
      <summary>
            The message serializers supported
            </summary>
    </member>
    <member name="P:MassTransit.Transports.IEndpointSettings.RetryLimit">
      <summary>
            The retry limit for inbound messages
            </summary>
    </member>
    <member name="P:MassTransit.Transports.IEndpointSettings.TrackerFactory">
      <summary>
            The message tracker factory
            </summary>
    </member>
    <member name="P:MassTransit.Transports.ITransportFactory.MessageNameFormatter">
      <summary>
            The message name formatter associated with this transport
            </summary>
    </member>
    <member name="T:MassTransit.Services.HealthMonitoring.HealthService">
      <summary>
            The health service attempts to track all known endpoints and monitor their status for up/down. 
            </summary>
    </member>
    <member name="M:MassTransit.Services.HealthMonitoring.HealthService.#ctor(MassTransit.IServiceBus,MassTransit.Saga.ISagaRepository{MassTransit.Services.HealthMonitoring.Server.HealthSaga})">
      <summary>
            Initializes a new instance of the <see cref="T:MassTransit.Services.HealthMonitoring.HealthService" /> class.
            </summary>
      <param name="bus">The bus.</param>
      <param name="healthSagas">The health sagas.</param>
    </member>
    <member name="M:MassTransit.Services.HealthMonitoring.HealthService.Start">
      <summary>
            Starts this instance.
            </summary>
    </member>
    <member name="M:MassTransit.Services.HealthMonitoring.HealthService.Stop">
      <summary>
            Stops this instance.
            </summary>
    </member>
    <member name="M:MassTransit.Services.HealthMonitoring.HealthClient.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:MassTransit.Services.HealthMonitoring.HealthClient" /> class with an interval time out of 3 seconds.
            </summary>
    </member>
    <member name="M:MassTransit.Services.HealthMonitoring.HealthClient.#ctor(System.Int32)">
      <summary>
              Constructs a new HealthClient object
            </summary>
      <param name="intervalInSeconds">The heartbeat interval in seconds</param>
    </member>
    <member name="T:MassTransit.UnsubscribeAction">
      <summary>
              The action to call to unsubscribe a previously subscribed consumer.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.UnregisterAction">
      <summary>
              The action to call to unregister a previously registered component
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.IControlBus">
      <summary>
              Extends the IServiceBus interface to include additional methods for
              services that extend the service bus
            </summary>
    </member>
    <member name="T:MassTransit.ServiceBus">
      <summary>
            A service bus is used to attach message handlers (services) to endpoints, as well as
            communicate with other service bus instances in a distributed application
            </summary>
    </member>
    <member name="M:MassTransit.ServiceBus.#ctor(MassTransit.IEndpoint,MassTransit.IEndpointCache,System.Boolean)">
      <summary>
            Creates an instance of the ServiceBus, which implements IServiceBus. This is normally
            not called and should be created using the ServiceBusConfigurator to ensure proper defaults
            and operation.
            </summary>
    </member>
    <member name="M:MassTransit.ServiceBus.Publish``1(``0,System.Action{MassTransit.IPublishContext{``0}})">
      <summary>
            Publishes a message to all subscribed consumers for the message type
            </summary>
      <typeparam name="T">The type of the message</typeparam>
      <param name="message">The messages to be published</param>
      <param name="contextCallback">The callback to perform operations on the context</param>
    </member>
    <member name="M:MassTransit.ServiceBus.Publish``1(System.Object)">
      <summary>
        <see cref="M:MassTransit.IServiceBus.Publish``1(``0)" />: this is a "dynamically"
            typed overload - give it an interface as its type parameter,
            and a loosely typed dictionary of values and the MassTransit
            underlying infrastructure will populate an object instance
            with the passed values. It actually does this with DynamicProxy
            in the background.
            </summary>
      <typeparam name="T">The type of the interface or
            non-sealed class with all-virtual members.</typeparam>
      <param name="bus">The bus to publish on.</param>
      <param name="values">The dictionary of values to place in the
            object instance to implement the interface.</param>
    </member>
    <member name="M:MassTransit.ServiceBus.Publish``1(System.Object,System.Action{MassTransit.IPublishContext{``0}})">
      <summary>
        <see cref="!:Publish&lt;T&gt;(MassTransit.IServiceBus,object)" />: this
            overload further takes an action; it allows you to set <see cref="T:MassTransit.IPublishContext" />
            meta-data. Also <see cref="M:MassTransit.IServiceBus.Publish``1(``0)" />.
            </summary>
      <typeparam name="T">The type of the message to publish</typeparam>
      <param name="bus">The bus to publish the message on.</param>
      <param name="values">The dictionary of values to become hydrated and
            published under the type of the interface.</param>
      <param name="contextCallback">The context callback.</param>
    </member>
    <member name="P:MassTransit.ServiceBus.Endpoint">
      <summary>
            The endpoint associated with this instance
            </summary>
    </member>
    <member name="T:MassTransit.Services.Subscriptions.Client.SubscriptionClient">
      <summary>
            The subscription client is responsible for exchanging subscription information between a local bus and the central subscription coordinator.
            </summary>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionClient.#ctor(MassTransit.IServiceBus,MassTransit.Subscriptions.Coordinator.SubscriptionRouter,System.Uri,System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:MassTransit.Services.Subscriptions.Client.SubscriptionClient" /> class.
            </summary>
      <param name="bus">The bus.</param>
      <param name="router">The router.</param>
      <param name="subscriptionServiceUri">The subscription service URI.</param>
      <param name="startTimeout">The start timeout.</param>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionClient.OnSubscriptionAdded(MassTransit.Subscriptions.Messages.SubscriptionAdded)">
      <summary>
            Called when a subscription was added.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionClient.OnSubscriptionRemoved(MassTransit.Subscriptions.Messages.SubscriptionRemoved)">
      <summary>
            Called when a subscription was removed.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:MassTransit.Services.Subscriptions.Client.SubscriptionClient.OnComplete">
      <summary>
            Called when the observation is complete and we should go away
            </summary>
    </member>
    <member name="T:MassTransit.Util.CheckConvention">
      <summary>
              Check class for verifying the condition of items included in interface contracts
            </summary>
    </member>
    <member name="T:MassTransit.Util.IndexedSagaProperty`1">
      <summary>
            For the in-memory saga repository, this maintains an index of saga properties
            for fast searching
            </summary>
      <typeparam name="TSaga">The saga type</typeparam>
    </member>
    <member name="M:MassTransit.Util.IndexedSagaProperty`1.Add(`0)">
      <summary>
            Adds a new saga to the index
            </summary>
      <param name="newItem">
      </param>
    </member>
    <member name="M:MassTransit.Util.IndexedSagaProperty`1.Remove(`0)">
      <summary>
            Removes a saga from the index
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:MassTransit.Util.IndexedSagaProperty`1.Where(System.Func{`0,System.Boolean})">
      <summary>
            Returns sagas matching the filter function
            </summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Util.IndexedSagaProperty`1.Where(System.Object,System.Func{`0,System.Boolean})">
      <summary>
            Returns sagas matching the filter function where the key also matches
            </summary>
      <param name="key">
      </param>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Util.IndexedSagaProperty`1.Select``1(System.Func{`0,``0})">
      <summary>
            Selects sagas from the index, running the transformation function and returning the output type
            </summary>
      <param name="transformer">
      </param>
      <typeparam name="TResult">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="P:MassTransit.Util.IndexedSagaProperty`1.Item(System.Object)">
      <summary>
            Returns the saga with the specified key
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="T:MassTransit.Util.IndexedSagaProperty`2">
      <summary>
            A dictionary index of the sagas
            </summary>
      <typeparam name="TSaga">
      </typeparam>
      <typeparam name="TProperty">
      </typeparam>
    </member>
    <member name="M:MassTransit.Util.IndexedSagaProperty`2.#ctor(System.Reflection.PropertyInfo)">
      <summary>
            Creates an index for the specified property of a saga
            </summary>
      <param name="propertyInfo">
      </param>
    </member>
    <member name="T:MassTransit.Util.LocalizationRequiredAttribute">
      <summary>
            Indicates that marked element should be localized or not.
            </summary>
    </member>
    <member name="M:MassTransit.Util.LocalizationRequiredAttribute.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:MassTransit.Util.LocalizationRequiredAttribute" /> class.
            </summary>
      <param name="required">
        <c>true</c> if a element should be localized; otherwise, <c>false</c>.</param>
    </member>
    <member name="M:MassTransit.Util.LocalizationRequiredAttribute.Equals(System.Object)">
      <summary>
            Returns whether the value of the given object is equal to the current <see cref="T:MassTransit.Util.LocalizationRequiredAttribute" />.
            </summary>
      <param name="obj">The object to test the value equality of. </param>
      <returns>
        <c>true</c> if the value of the given object is equal to that of the current; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:MassTransit.Util.LocalizationRequiredAttribute.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current <see cref="T:MassTransit.Util.LocalizationRequiredAttribute" />.</returns>
    </member>
    <member name="P:MassTransit.Util.LocalizationRequiredAttribute.Required">
      <summary>
            Gets a value indicating whether a element should be localized.
            <value><c>true</c> if a element should be localized; otherwise, <c>false</c>.</value></summary>
    </member>
    <member name="T:MassTransit.Util.StringFormatMethodAttribute">
      <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> -like form
            </summary>
    </member>
    <member name="M:MassTransit.Util.StringFormatMethodAttribute.#ctor(System.String)">
      <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
      <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
    </member>
    <member name="P:MassTransit.Util.StringFormatMethodAttribute.FormatParameterName">
      <summary>
            Gets format parameter name
            </summary>
    </member>
    <member name="T:MassTransit.Util.InvokerParameterNameAttribute">
      <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException" /> has such parameter.
            </summary>
    </member>
    <member name="T:MassTransit.Util.AssertionMethodAttribute">
      <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:MassTransit.Util.AssertionConditionAttribute" /> attribute
            </summary>
      <seealso cref="T:MassTransit.Util.AssertionConditionAttribute" />
    </member>
    <member name="T:MassTransit.Util.AssertionConditionAttribute">
      <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:MassTransit.Util.AssertionMethodAttribute" /> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
      <seealso cref="T:MassTransit.Util.AssertionConditionType" />
    </member>
    <member name="M:MassTransit.Util.AssertionConditionAttribute.#ctor(MassTransit.Util.AssertionConditionType)">
      <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
      <param name="conditionType">Specifies condition type</param>
    </member>
    <member name="P:MassTransit.Util.AssertionConditionAttribute.ConditionType">
      <summary>
            Gets condition type
            </summary>
    </member>
    <member name="T:MassTransit.Util.AssertionConditionType">
      <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
    </member>
    <member name="F:MassTransit.Util.AssertionConditionType.IS_TRUE">
      <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
    </member>
    <member name="F:MassTransit.Util.AssertionConditionType.IS_FALSE">
      <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
    </member>
    <member name="F:MassTransit.Util.AssertionConditionType.IS_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
    </member>
    <member name="F:MassTransit.Util.AssertionConditionType.IS_NOT_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
    </member>
    <member name="T:MassTransit.Util.TerminatesProgramAttribute">
      <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
    </member>
    <member name="T:MassTransit.Util.CanBeNullAttribute">
      <summary>
            Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
            </summary>
    </member>
    <member name="T:MassTransit.Util.NotNullAttribute">
      <summary>
            Indicates that the value of marked element could never be <c>null</c></summary>
    </member>
    <member name="T:MassTransit.Util.CannotApplyEqualityOperatorAttribute">
      <summary>
            Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
            There is only exception to compare with <c>null</c>, it is permitted
            </summary>
    </member>
    <member name="T:MassTransit.Util.BaseTypeRequiredAttribute">
      <summary>
            When applied to target attribute, specifies a requirement for any type which is marked with 
            target attribute to implement or inherit specific type or types
            </summary>
      <example>
        <code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute 
            {}
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent
            {}
            </code>
      </example>
    </member>
    <member name="M:MassTransit.Util.BaseTypeRequiredAttribute.#ctor(System.Type[])">
      <summary>
            Initializes new instance of BaseTypeRequiredAttribute
            </summary>
      <param name="baseTypes">Specifies which types are required</param>
    </member>
    <member name="P:MassTransit.Util.BaseTypeRequiredAttribute.BaseTypes">
      <summary>
            Gets enumerations of specified base types
            </summary>
    </member>
    <member name="T:MassTransit.Util.UsedImplicitlyAttribute">
      <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
    </member>
    <member name="P:MassTransit.Util.UsedImplicitlyAttribute.TargetFlags">
      <summary>
            Gets value indicating what is meant to be used
            </summary>
    </member>
    <member name="T:MassTransit.Util.MeansImplicitUseAttribute">
      <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
    </member>
    <member name="P:MassTransit.Util.MeansImplicitUseAttribute.TargetFlags">
      <summary>
            Gets value indicating what is meant to be used
            </summary>
    </member>
    <member name="F:MassTransit.Util.ImplicitUseKindFlags.Access">
      <summary>
            Only entity marked with attribute considered used
            </summary>
    </member>
    <member name="F:MassTransit.Util.ImplicitUseKindFlags.Assign">
      <summary>
            Indicates implicit assignment to a member
            </summary>
    </member>
    <member name="F:MassTransit.Util.ImplicitUseKindFlags.Instantiated">
      <summary>
            Indicates implicit instantiation of a type
            </summary>
    </member>
    <member name="T:MassTransit.Util.ImplicitUseTargetFlags">
      <summary>
            Specify what is considered used implicitly when marked with <see cref="T:MassTransit.Util.MeansImplicitUseAttribute" /> or <see cref="T:MassTransit.Util.UsedImplicitlyAttribute" /></summary>
    </member>
    <member name="F:MassTransit.Util.ImplicitUseTargetFlags.Members">
      <summary>
            Members of entity marked with attribute are considered used
            </summary>
    </member>
    <member name="F:MassTransit.Util.ImplicitUseTargetFlags.WithMembers">
      <summary>
            Entity marked with attribute and all its members considered used
            </summary>
    </member>
    <member name="T:MassTransit.Distributor.WorkerPendingMessageTracker`1">
      <summary>
            Keeps track of messages that were not accepted due to worker load in order to provide a pending message count
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MassTransit.Distributor.WorkerSettings">
      <summary>
            These settings are used to configure a distributed consumer if the default
            settings are not sufficient.
            </summary>
    </member>
    <member name="P:MassTransit.Distributor.WorkerSettings.PendingLimit">
      <summary>
            A recommended limit of pending messages for this worker. This is not a hard limit,
            the queue depth may at times exceed this value.
            </summary>
    </member>
    <member name="P:MassTransit.Distributor.WorkerSettings.InProgressLimit">
      <summary>
            A recommended limit of concurrent messages being consumed by the worker. This too is not a hard
            limit, just a recommendation that will most likely be enforced but not guaranteed.
            </summary>
    </member>
    <member name="T:MassTransit.Distributor.Messages.Distributed`1">
      <summary>
              Wraps a message type as a distributed message so that it can be sent separately from the actual
              message being processed. We intentionally make sure it is not assignable to TMessage, because we don't
              want it getting downgraded to a consumer of TMessage.
            </summary>
      <typeparam name="TMessage">The message type being distributed</typeparam>
    </member>
    <member name="T:MassTransit.Distributor.Messages.Workload`1">
      <summary>
            Presents the workload of a worker to interested consumers
            </summary>
      <typeparam name="T">The type of message being handled</typeparam>
    </member>
    <member name="P:MassTransit.Distributor.Messages.Workload`1.Pending">
      <summary>
            The number of messages pending for consumption by this worker
            </summary>
    </member>
    <member name="P:MassTransit.Distributor.Messages.Workload`1.PendingLimit">
      <summary>
            The maximum number of messages that should be pending for this worker in the queue
            </summary>
    </member>
    <member name="P:MassTransit.Distributor.Messages.Workload`1.InProgress">
      <summary>
            The number of messages currently being processed by this worker
            </summary>
    </member>
    <member name="P:MassTransit.Distributor.Messages.Workload`1.InProgressLimit">
      <summary>
            The maximum number of messages that can be processed at a time by this worker
            </summary>
    </member>
    <member name="T:MassTransit.Distributor.Messages.WorkerAvailable`1">
      <summary>
            Published by workers that can process a message of type T
            </summary>
      <typeparam name="T">The type of message that can be processed.</typeparam>
    </member>
    <member name="T:MassTransit.IEndpointAddress">
      <summary>
            Identifies an endpoint
            </summary>
    </member>
    <member name="P:MassTransit.IEndpointAddress.Uri">
      <summary>
            The URI used to access the endpoint
            </summary>
    </member>
    <member name="P:MassTransit.IEndpointAddress.IsLocal">
      <summary>
            True if the endpoint is local to this machine
            </summary>
    </member>
    <member name="P:MassTransit.IEndpointAddress.IsTransactional">
      <summary>
            Was transactional requested by the Uri
            </summary>
    </member>
    <member name="T:MassTransit.Transports.Endpoint">
      <summary>
            See <see cref="T:MassTransit.IEndpoint" /> for docs.
            </summary>
    </member>
    <member name="M:MassTransit.Transports.Endpoint.Send``1(System.Object)">
      <summary>
            Sends an interface message, initializing the properties of the interface using the anonymous
            object specified
            </summary>
      <typeparam name="T">The interface type to send</typeparam>
      <param name="endpoint">The destination endpoint</param>
      <param name="values">The property values to initialize on the interface</param>
    </member>
    <member name="M:MassTransit.Transports.Endpoint.Send``1(System.Object,System.Action{MassTransit.ISendContext{``0}})">
      <summary>
            Sends an interface message, initializing the properties of the interface using the anonymous
            object specified
            </summary>
      <typeparam name="T">The interface type to send</typeparam>
      <param name="endpoint">The destination endpoint</param>
      <param name="values">The property values to initialize on the interface</param>
      <param name="contextCallback">A callback method to modify the send context for the message</param>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.InstanceMessageSinkBase`1">
      <summary>
            Handles 
            </summary>
      <typeparam name="TMessage">
      </typeparam>
    </member>
    <member name="T:MassTransit.Serialization.Custom.ISerializerContext">
      <summary>
            The serializer context is passed through all of the serializers to provide a central context for
            dispatching to the appropriate serializer for each type encountered without using a static class
            </summary>
    </member>
    <member name="M:MassTransit.Serialization.Custom.ISerializerContext.GetPrefix(System.String,System.String)">
      <summary>
            Returns the namespace prefix to use for the specified element
            </summary>
      <param name="localName">The name of the element being added to the XML document</param>
      <param name="ns">The namespace that defines the type for the element</param>
      <returns>A prefix to use when writing the element to the XML stream</returns>
    </member>
    <member name="M:MassTransit.Serialization.Custom.ISerializerContext.MapType(System.Type,System.Type,System.Object)">
      <summary>
            Returns the type for a property if the property type is to be overridden by the serializer
            </summary>
      <param name="declaringType">The type containing the property</param>
      <param name="propertyType">The type of the property</param>
      <param name="value">The value to use to obtain the type, if necessary</param>
      <returns>The property type, or the overriding type</returns>
    </member>
    <member name="M:MassTransit.Serialization.Custom.ISerializerContext.WriteNamespaceInformationToXml(System.Xml.XmlWriter)">
      <summary>
            Writes any namespace information that was collected to the document element attribute
            </summary>
      <param name="writer">The XmlWriter to use for writing the attributes</param>
    </member>
    <member name="M:MassTransit.Serialization.Custom.ISerializerContext.SerializeObject(System.String,System.Type,System.Object)">
      <summary>
            Delegates the serialization of an obj
            </summary>
      <param name="localName">The name of the element in the XML document</param>
      <param name="type">The type of object to serialize</param>
      <param name="value">The actual object to serialize</param>
      <returns>An enumeration of continuations to actually write the XML</returns>
    </member>
    <member name="T:MassTransit.Serialization.Custom.NonClosingStream">
      <summary>
            A stream that doesn't close the inner stream when <see cref="M:MassTransit.Serialization.Custom.NonClosingStream.Close" /> is called.
            </summary>
    </member>
    <member name="T:MassTransit.Transports.LoopbackTransport">
      <summary>
            The loopback transport is a built-in transport for MassTransit that 
            works on messages in-memory. It is dependent on the <see cref="T:MassTransit.Subscriptions.Coordinator.SubscriptionLoopback" />
            that takes care of subscribing the buses in the process
            depending on what subscriptions are made.
            </summary>
    </member>
    <member name="T:MassTransit.Services.Subscriptions.Server.SubscriptionSaga">
      <summary>
              Manages the lifecycle of a subscription through the system
            </summary>
    </member>
    <member name="T:MassTransit.Services.Subscriptions.SubscriptionConsumer">
      <summary>
            Used by testing framework
            </summary>
    </member>
    <member name="T:MassTransit.Services.Subscriptions.SubscriptionPublisher">
      <summary>
            The subscription publisher is responsible for notifying the subscription
            service about what 'actors' ('callers' so to speak) around the service bus
            wants to happen: it allows the 
            </summary>
    </member>
    <member name="T:MassTransit.ServiceBusExtensions">
      <summary>
            Extension methods pertinent to service bus logic, but on
            type <see cref="T:System.Type" /> - handles different sorts of reflection
            logic.
            </summary>
    </member>
    <member name="M:MassTransit.ServiceBusExtensions.ToMessageName(System.Type)">
      <summary>
            Transforms the type of message to a normalized string which can be used
            for naming a queue on a transport.
            </summary>
      <param name="messageType">The message class/interface type</param>
      <returns>The normalized name for this type</returns>
    </member>
    <member name="M:MassTransit.ServiceBusExtensions.IsAllowedMessageType(System.Type)">
      <summary>
            Returns true if the specified type is an allowed message type, i.e.
            that it doesn't come from the .Net core assemblies or is without a namespace,
            amongst others.
            </summary>
      <param name="type">The type to inspect</param>
      <returns>True if the message can be sent, otherwise false</returns>
    </member>
    <member name="M:MassTransit.ServiceBusExtensions.GetMessageTypes(System.Type)">
      <summary>
            Returns all the message types that are available for the specified type. This will
            return any base classes or interfaces implemented by the type that are allowed
            message types.
            </summary>
      <param name="type">The type to inspect</param>
      <returns>An enumeration of valid message types implemented by the specified type</returns>
    </member>
    <member name="M:MassTransit.ServiceBusExtensions.IsControlAddress(System.Uri)">
      <summary>
            Determines whether the given <see cref="T:MassTransit.IEndpointAddress" /> is a control bus by examining the uri.
            </summary>
      <param name="address">The address.</param>
      <returns>
        <c>true</c> if the URI of of the given <see cref="T:MassTransit.IEndpointAddress" /> end with '_control'; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.CorrelatedMessageSinkRouter`3">
      <summary>
            Routes a message to all of the connected message sinks without modification
            </summary>
      <typeparam name="TMessage">The type of the message to be routed</typeparam>
      <typeparam name="TKey">The correlation key type</typeparam>
      <typeparam name="T">The input type of the router</typeparam>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.ConsumerMessageSink`2">
      <summary>
            Routes messages to instances of subscribed components. A new instance of the component
            is created from the container for each message received.
            </summary>
      <typeparam name="TConsumer">The component type to handle the message</typeparam>
      <typeparam name="TMessage">The message to handle</typeparam>
    </member>
    <member name="T:MassTransit.Pipeline.IInboundPipelineConfigurator">
      <summary>
        <para>Implementors should configure the pipeline managing subscriptions 
            to messages; both correlated by and by-type subscriptions.</para>
            
            See also <see cref="T:MassTransit.Pipeline.ISubscriptionEvent" /> - which is passed to implementers of this
            interface.
            </summary>
    </member>
    <member name="M:MassTransit.Pipeline.IInboundPipelineConfigurator.Register(MassTransit.Pipeline.ISubscriptionEvent)">
      <summary>
            Register some instance that cares about message-subscriptions.
            </summary>
      <param name="subscriptionEventHandler">Instance</param>
      <returns>An unsubscribing multi-cast delegate.</returns>
    </member>
    <member name="P:MassTransit.Pipeline.IInboundPipelineConfigurator.Pipeline">
      <summary>
            Gets the inbound message pipeline.
            </summary>
    </member>
    <member name="P:MassTransit.Pipeline.IInboundPipelineConfigurator.Bus">
      <summary>
            Gets the service bus under configuration.
            </summary>
    </member>
    <member name="T:MassTransit.Util.RegistrationList`1">
      <summary>
              A multiple-readers, single-writer, disposable, list implementation.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MassTransit.Pipeline.InboundMessagePipeline">
      <summary>
            An inbound message pipeline takes a consume context and maps it
            to a number if actual consumers, in its <see cref="M:MassTransit.Pipeline.InboundMessagePipeline.Enumerate(MassTransit.IConsumeContext)" /> method. It
            is also a place-holder for configuration regarding the consume context/its mapped
            outputs.
            </summary>
    </member>
    <member name="M:MassTransit.Pipeline.InboundMessagePipeline.ReplaceOutputSink(MassTransit.Pipeline.IPipelineSink{MassTransit.IConsumeContext})">
      <summary>
            Atomically replaces the current output sink with the argument.
            </summary>
      <param name="sink">The argument sink.</param>
      <returns>The passed argument when the replace operation is done.</returns>
    </member>
    <member name="T:MassTransit.Pipeline.MessagePipelineExtensions">
      <summary>
            Extensions for the message pipeline.
            </summary>
    </member>
    <member name="M:MassTransit.Pipeline.MessagePipelineExtensions.Dispatch``1(MassTransit.Pipeline.IInboundMessagePipeline,``0)">
      <summary>
            Dispatch a message through the pipeline
            </summary>
      <param name="pipeline">The pipeline instance</param>
      <param name="message">The message to dispatch</param>
    </member>
    <member name="M:MassTransit.Pipeline.MessagePipelineExtensions.Dispatch``1(MassTransit.Pipeline.IInboundMessagePipeline,``0,System.Func{``0,System.Boolean})">
      <summary>
            Dispatch a message through the pipeline. If the message will be consumed, the accept function
            is called to allow the endpoint to acknowledge the message reception if applicable
            </summary>
      <param name="pipeline">The pipeline instance</param>
      <param name="message">The message to dispatch</param>
      <param name="acknowledge">The function to call if the message will be consumed by the pipeline</param>
      <returns>whether the message was consumed</returns>
    </member>
    <member name="M:MassTransit.Pipeline.MessagePipelineExtensions.Dispatch``1(MassTransit.Pipeline.IOutboundMessagePipeline,``0,System.Func{``0,System.Boolean})">
      <summary>
        <see cref="M:MassTransit.Pipeline.MessagePipelineExtensions.Dispatch``1(MassTransit.Pipeline.IInboundMessagePipeline,``0)" />: this one is for the outbound pipeline.
            </summary>
    </member>
    <member name="M:MassTransit.Pipeline.MessagePipelineExtensions.ConnectConsumer``1(MassTransit.Pipeline.IInboundMessagePipeline)">
      <summary>
            Subscribe a component type to the pipeline that is resolved from the container for each message
            </summary>
      <typeparam name="TComponent">
      </typeparam>
      <param name="pipeline">The pipeline to configure</param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Pipeline.MessagePipelineExtensions.ConnectConsumer``1(MassTransit.Pipeline.IInboundMessagePipeline,System.Func{``0})">
      <summary>
            Subscribe a component type to the pipeline that is resolved from the container for each message
            </summary>
      <typeparam name="TConsumer">
      </typeparam>
      <param name="pipeline">The pipeline to configure</param>
      <param name="consumerFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Pipeline.MessagePipelineExtensions.ConnectInstance``1(MassTransit.Pipeline.IInboundMessagePipeline,``0)">
      <summary>
            Subscribe a component to the pipeline that handles every message
            </summary>
      <typeparam name="TComponent">
      </typeparam>
      <param name="pipeline">The pipeline to configure</param>
      <param name="instance">The instance that will handle the messages</param>
      <returns>
      </returns>
    </member>
    <member name="M:MassTransit.Pipeline.MessagePipelineExtensions.ConnectEndpoint``1(MassTransit.Pipeline.IOutboundMessagePipeline,MassTransit.IEndpoint)">
      <summary>
            Connects an endpoint to the outbound pipeline by message type.
            </summary>
      <typeparam name="TMessage">The type of the message to route</typeparam>
      <param name="pipeline">The outbound pipeline</param>
      <param name="endpoint">The endpoint to route to</param>
      <returns>
      </returns>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.CorrelatedMessageRouter`3">
      <summary>
            Splits a message path based on the correlation information in the message
            </summary>
      <typeparam name="TMessage">The type of the message to be routed</typeparam>
      <typeparam name="TKey">They key type for the message</typeparam>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.EndpointMessageSink`1">
      <summary>
            A message sink that sends to an endpoint
            </summary>
      <typeparam name="TMessage">
      </typeparam>
    </member>
    <member name="T:MassTransit.Pipeline.Configuration.InboundPipelineConfigurator">
      <summary>
        <see cref="T:MassTransit.Pipeline.IInboundPipelineConfigurator" />.</summary>
    </member>
    <member name="T:MassTransit.Pipeline.Sinks.SelectedConsumerMessageSink`2">
      <summary>
            Routes messages to instances of subscribed components. A new instance of the component
            is created from the container for each message received.
            </summary>
      <typeparam name="TConsumer">The component type to handle the message</typeparam>
      <typeparam name="TMessage">The message to handle</typeparam>
    </member>
    <member name="T:MassTransit.Serialization.MessageEnvelopeBase">
      <summary>
              A base message envelope for transports that support enveloped messages
              This does not include the binary formatter, since it is retained for
              legacy support as a pure object formatter with no envelope
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.SourceAddress">
      <summary>
              The source where the message originated
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.DestinationAddress">
      <summary>
              The destination where the message was originally sent
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.MessageId">
      <summary>
              A transport specific message identifier if appropriate
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.RequestId">
      <summary>
            The request identifier
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.ConversationId">
      <summary>
              A higher-level conversation identifier that goes above any type of saga or request/response
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.CorrelationId">
      <summary>
              A correlation identifier for the message, if a saga or correlated message
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.ResponseAddress">
      <summary>
              The destination to use for replies to this message
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.FaultAddress">
      <summary>
              The destination to send any faults caused by this message
              If not specified, faults are either sent to the ResponseAddress address
              If this nor ResponseAddress is specified, faults are published
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.Network">
      <summary>
              Identifies a specific network to which this message belongs and is used to filter
              out messages that might be from untrusted networks
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.RetryCount">
      <summary>
              The number of times the message has been retried by a consumer
              Starts at zero and is incremented every time the message is scheduled for retry
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.ExpirationTime">
      <summary>
              The message envelope base for the binary serializer?
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.MessageEnvelopeBase.MessageType">
      <summary>
              The type of the message, including the full name and assembly
            </summary>
    </member>
    <member name="T:MassTransit.Serialization.BinaryMessageSerializer">
      <summary>
            The binary message serializer used the .NET BinaryFormatter to serialize
            message content. 
            </summary>
    </member>
    <member name="T:MassTransit.Serialization.XmlMessageEnvelope">
      <summary>
              The envelope that is used to wrap messages serialized using Xml
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.SourceAddress">
      <summary>
              The source where the message originated
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.DestinationAddress">
      <summary>
              The destination where the message was originally sent
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.MessageId">
      <summary>
              A transport specific message identifier if appropriate
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.RequestId">
      <summary>
            The request identifier
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.ConversationId">
      <summary>
              A higher-level conversation identifier that goes above any type of saga or request/response
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.CorrelationId">
      <summary>
              A correlation identifier for the message, if a saga or correlated message
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.ResponseAddress">
      <summary>
              The destination to use for replies to this message
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.FaultAddress">
      <summary>
              The destination to send any faults caused by this message
              If not specified, faults are either sent to the ResponseAddress address
              If this nor ResponseAddress is specified, faults are published
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.Network">
      <summary>
              Identifies a specific network to which this message belongs and is used to filter
              out messages that might be from untrusted networks
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.RetryCount">
      <summary>
              The number of times the message has been retried by a consumer
              Starts at zero and is incremented every time the message is scheduled for retry
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.ExpirationTime">
      <summary>
              The message envelope base for the binary serializer?
            </summary>
    </member>
    <member name="P:MassTransit.Serialization.XmlMessageEnvelope.MessageType">
      <summary>
              The type of the message, including the full name and assembly
            </summary>
    </member>
    <member name="T:Stact.Actor">
      <summary>
            Declares the class is an actor. This is a marker interface.
            </summary>
    </member>
    <member name="M:Stact.ActorConvention`1.Matches(Stact.ActorConvention{`0})">
      <summary>
            Determines if a convention the same as the target convention, to avoid 
            duplicate conventions from being added
            </summary>
      <param name="convention">The convention to compare</param>
      <returns>True if it matches, otherwise false</returns>
    </member>
    <member name="T:Stact.Channel">
      <summary>
            The base Channel interface, used as a marker to identify channels
            </summary>
    </member>
    <member name="T:Stact.UntypedChannel">
      <summary>
            A channel to which any message type can be sent
            </summary>
    </member>
    <member name="M:Stact.UntypedChannel.Send``1(``0)">
      <summary>
              Send a message to an untyped channel
            </summary>
      <typeparam name="T">The message type</typeparam>
      <param name="message">The message</param>
    </member>
    <member name="T:Stact.ActorRef">
      <summary>
            An ActorInstance is used to send messages to an actor instance. This abstraction
            helps avoid tight coupling with the actor class definition.
            </summary>
    </member>
    <member name="T:Stact.ActorFactory`1">
      <summary>
            A builder abstraction for creating actor instances when needed
            </summary>
      <typeparam name="TActor">The actor type</typeparam>
    </member>
    <member name="M:Stact.ActorFactory`1.GetActor">
      <summary>
            Returns an instance of an actor
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.ExtensionsForLinking.Link(Stact.ActorRef,Stact.Inbox)">
      <summary>
            Initiates a link to another actor instance. Once linked, if either actor
            exits, all actors linked to this actor will be sent an Exit with a reason
            of actor death
            </summary>
      <param name="actor">The actor to link</param>
      <param name="inbox">The inbox of the actor requesting the link</param>
    </member>
    <member name="T:Stact.UntypedFilterChannel`1">
      <summary>
            This is a type of siphon filter that would remove a message from an untyped
            channel rather than passing it to the output channel. It is mainly designed for handling
            intercept messages such as a Kill command to an actor.
            </summary>
      <typeparam name="TOutput">The message type to siphon from the channel</typeparam>
    </member>
    <member name="T:Stact.Messages.InboxMessage">
      <summary>
            An InboxMessage is one that is handled by the inbox by default
            </summary>
    </member>
    <member name="T:Stact.Internal.LocalizationRequiredAttribute">
      <summary>
            Indicates that marked element should be localized or not.
            </summary>
    </member>
    <member name="M:Stact.Internal.LocalizationRequiredAttribute.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Stact.Internal.LocalizationRequiredAttribute" /> class.
            </summary>
      <param name="required">
        <c>true</c> if a element should be localized; otherwise, <c>false</c>.</param>
    </member>
    <member name="M:Stact.Internal.LocalizationRequiredAttribute.Equals(System.Object)">
      <summary>
            Returns whether the value of the given object is equal to the current <see cref="T:Stact.Internal.LocalizationRequiredAttribute" />.
            </summary>
      <param name="obj">The object to test the value equality of. </param>
      <returns>
        <c>true</c> if the value of the given object is equal to that of the current; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Stact.Internal.LocalizationRequiredAttribute.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current <see cref="T:Stact.Internal.LocalizationRequiredAttribute" />.</returns>
    </member>
    <member name="P:Stact.Internal.LocalizationRequiredAttribute.Required">
      <summary>
            Gets a value indicating whether a element should be localized.
            <value><c>true</c> if a element should be localized; otherwise, <c>false</c>.</value></summary>
    </member>
    <member name="T:Stact.Internal.StringFormatMethodAttribute">
      <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> -like form
            </summary>
    </member>
    <member name="M:Stact.Internal.StringFormatMethodAttribute.#ctor(System.String)">
      <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
      <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
    </member>
    <member name="P:Stact.Internal.StringFormatMethodAttribute.FormatParameterName">
      <summary>
            Gets format parameter name
            </summary>
    </member>
    <member name="T:Stact.Internal.InvokerParameterNameAttribute">
      <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException" /> has such parameter.
            </summary>
    </member>
    <member name="T:Stact.Internal.AssertionMethodAttribute">
      <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:Stact.Internal.AssertionConditionAttribute" /> attribute
            </summary>
      <seealso cref="T:Stact.Internal.AssertionConditionAttribute" />
    </member>
    <member name="T:Stact.Internal.AssertionConditionAttribute">
      <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:Stact.Internal.AssertionMethodAttribute" /> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
      <seealso cref="T:Stact.Internal.AssertionConditionType" />
    </member>
    <member name="M:Stact.Internal.AssertionConditionAttribute.#ctor(Stact.Internal.AssertionConditionType)">
      <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
      <param name="conditionType">Specifies condition type</param>
    </member>
    <member name="P:Stact.Internal.AssertionConditionAttribute.ConditionType">
      <summary>
            Gets condition type
            </summary>
    </member>
    <member name="T:Stact.Internal.AssertionConditionType">
      <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
    </member>
    <member name="F:Stact.Internal.AssertionConditionType.IS_TRUE">
      <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
    </member>
    <member name="F:Stact.Internal.AssertionConditionType.IS_FALSE">
      <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
    </member>
    <member name="F:Stact.Internal.AssertionConditionType.IS_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
    </member>
    <member name="F:Stact.Internal.AssertionConditionType.IS_NOT_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
    </member>
    <member name="T:Stact.Internal.TerminatesProgramAttribute">
      <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
    </member>
    <member name="T:Stact.Internal.CanBeNullAttribute">
      <summary>
            Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
            </summary>
    </member>
    <member name="T:Stact.Internal.NotNullAttribute">
      <summary>
            Indicates that the value of marked element could never be <c>null</c></summary>
    </member>
    <member name="T:Stact.Internal.CannotApplyEqualityOperatorAttribute">
      <summary>
            Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
            There is only exception to compare with <c>null</c>, it is permitted
            </summary>
    </member>
    <member name="T:Stact.Internal.BaseTypeRequiredAttribute">
      <summary>
            When applied to target attribute, specifies a requirement for any type which is marked with 
            target attribute to implement or inherit specific type or types
            </summary>
      <example>
        <code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute 
            {}
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent
            {}
            </code>
      </example>
    </member>
    <member name="M:Stact.Internal.BaseTypeRequiredAttribute.#ctor(System.Type[])">
      <summary>
            Initializes new instance of BaseTypeRequiredAttribute
            </summary>
      <param name="baseTypes">Specifies which types are required</param>
    </member>
    <member name="P:Stact.Internal.BaseTypeRequiredAttribute.BaseTypes">
      <summary>
            Gets enumerations of specified base types
            </summary>
    </member>
    <member name="T:Stact.Internal.UsedImplicitlyAttribute">
      <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
    </member>
    <member name="P:Stact.Internal.UsedImplicitlyAttribute.TargetFlags">
      <summary>
            Gets value indicating what is meant to be used
            </summary>
    </member>
    <member name="T:Stact.Internal.MeansImplicitUseAttribute">
      <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
    </member>
    <member name="P:Stact.Internal.MeansImplicitUseAttribute.TargetFlags">
      <summary>
            Gets value indicating what is meant to be used
            </summary>
    </member>
    <member name="F:Stact.Internal.ImplicitUseKindFlags.Access">
      <summary>
            Only entity marked with attribute considered used
            </summary>
    </member>
    <member name="F:Stact.Internal.ImplicitUseKindFlags.Assign">
      <summary>
            Indicates implicit assignment to a member
            </summary>
    </member>
    <member name="F:Stact.Internal.ImplicitUseKindFlags.Instantiated">
      <summary>
            Indicates implicit instantiation of a type
            </summary>
    </member>
    <member name="T:Stact.Internal.ImplicitUseTargetFlags">
      <summary>
            Specify what is considered used implicitly when marked with <see cref="T:Stact.Internal.MeansImplicitUseAttribute" /> or <see cref="T:Stact.Internal.UsedImplicitlyAttribute" /></summary>
    </member>
    <member name="F:Stact.Internal.ImplicitUseTargetFlags.Members">
      <summary>
            Members of entity marked with attribute are considered used
            </summary>
    </member>
    <member name="F:Stact.Internal.ImplicitUseTargetFlags.WithMembers">
      <summary>
            Entity marked with attribute and all its members considered used
            </summary>
    </member>
    <member name="P:Stact.SetMessageHeader.MessageId">
      <summary>
            The identifier for this message
            </summary>
    </member>
    <member name="P:Stact.SetMessageHeader.CorrelationId">
      <summary>
            The identifier correlating this message to a message exchange/conversation
            </summary>
    </member>
    <member name="P:Stact.SetMessageHeader.SenderAddress">
      <summary>
            The sender address of the message
            </summary>
    </member>
    <member name="P:Stact.SetMessageHeader.DestinationAddress">
      <summary>
            The final destination of the message
            </summary>
    </member>
    <member name="P:Stact.SetMessageHeader.FaultAddress">
      <summary>
            The address where faults should be sent
            </summary>
    </member>
    <member name="T:Stact.ActorRegistry">
      <summary>
            An actor registry provide running storage for actors that are active in the system
            </summary>
    </member>
    <member name="M:Stact.ActorRegistry.Register(System.Guid,Stact.ActorRef)">
      <summary>
            Adds an actor instance to the registry
            </summary>
      <param name="key">The unique identifier for the actor instance</param>
      <param name="actor">The actor instance</param>
    </member>
    <member name="M:Stact.ActorRegistry.Register(Stact.ActorRef,System.Action{System.Guid,Stact.ActorRef})">
      <summary>
            Adds an actor to the registry
            </summary>
      <param name="actor">The actor to add</param>
      <param name="callback">
      </param>
    </member>
    <member name="M:Stact.ActorRegistry.Unregister(Stact.ActorRef)">
      <summary>
            Removes an actor from the registry
            </summary>
      <typeparam name="T">The type of the actor</typeparam>
      <param name="actor">The actor to remove</param>
    </member>
    <member name="M:Stact.ActorRegistry.Unregister(System.Guid)">
      <summary>
            Removes an actor from the registry
            </summary>
      <param name="key">The id of the actor to remove</param>
    </member>
    <member name="M:Stact.ActorRegistry.Shutdown">
      <summary>
            Stops all actors and removes them from the registry
            </summary>
    </member>
    <member name="M:Stact.ActorRegistry.Get(System.Guid,System.Action{Stact.ActorRef},System.Action)">
      <summary>
            Gets an actor from the registry
            </summary>
      <param name="key">The id of the actor</param>
      <param name="callback">
      </param>
      <param name="notFoundCallback">
      </param>
    </member>
    <member name="M:Stact.ActorRegistry.Select(System.Uri,System.Action{Stact.ActorRef},System.Action)">
      <summary>
            Returns an actor instance for the actor referenced by the URI specified.
            </summary>
      <param name="actorAddress">The URI for the actor, maybe be a local or remote actor address</param>
      <param name="callback">Called when the actor intance is available</param>
      <param name="notFoundCallback">Called if the actor instance was not found and could not be created</param>
    </member>
    <member name="M:Stact.ActorRegistry.Each(System.Action{System.Guid,Stact.ActorRef})">
      <summary>
            Calls the callback for each actor in the registry
            </summary>
      <param name="callback">A method to call with each actor</param>
    </member>
    <member name="M:Stact.ActorRegistry.Subscribe(System.Action{Stact.Configuration.ConnectionConfigurator})">
      <summary>
            Allow subscription to events that are produced by the actor registry as actors
            are registered and unregistered.
            </summary>
      <param name="subscriberActions">The subscription actions</param>
      <returns>A channel subscription</returns>
    </member>
    <member name="M:Stact.Configuration.ActorFactoryConfigurator`1.AddConvention(Stact.ActorConvention{`0})">
      <summary>
            Add conventions to apply to actor instances as they are created
            </summary>
      <param name="convention">The convention to apply to the actor instance</param>
      <returns>The configurator</returns>
    </member>
    <member name="T:Stact.Configuration.FiberFactoryConfigurator`1">
      <summary>
              Configures the type of fiber to be used for handling messages
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnCallingThread">
      <summary>
              Handle on the calling thread (synchronously)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnPoolFiber">
      <summary>
              Handle on a dedicated fiber (uses the thread pool, lightweight)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnFiber(Stact.Fiber)">
      <summary>
              Handle on the specified fiber
            </summary>
      <param name="fiber">The fiber to use</param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnThreadFiber">
      <summary>
              Handle on a dedicated thread (operating system thread)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.UseFiberFactory(Stact.FiberFactory)">
      <summary>
              Use the specified fiber factory
            </summary>
      <param name="fiberFactory">The fiber factory to use</param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.UseFiberFactory(Stact.FiberFactoryEx)">
      <summary>
              Use the specified fiber factory
            </summary>
      <param name="fiberFactory">The fiber factory to use</param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.UseShutdownTimeout(System.TimeSpan)">
      <summary>
              Configure the shutdown timeout for the fiber
            </summary>
      <param name="timeout">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.Configurator.ValidateConfiguration">
      <summary>
            Validate the configuration, throwing an exception if the configuration settings
            are insufficient or invalid based on the type of configuration being performed.
            </summary>
    </member>
    <member name="T:Stact.Configuration.Internal.PropertyChannelConvention`2">
      <summary>
            Connects an actor property that implements Channel&lt;T&gt; to the inbox
            </summary>
      <typeparam name="TActor">The actor type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="M:Stact.ExtensionsForActorConventions.ConnectPublicMethods``1(Stact.Configuration.ActorFactoryConfigurator{``0})">
      <summary>
            Connect methods that are public and have a single parameter that is a Message type, such as
            Message, Request, or Response as a consumer on the inbox
            </summary>
      <typeparam name="TActor">
      </typeparam>
      <param name="configurator">
      </param>
    </member>
    <member name="M:Stact.ExtensionsForActorConventions.ConnectPropertyChannels``1(Stact.Configuration.ActorFactoryConfigurator{``0})">
      <summary>
            Connect properties that are public and of type Channel&lt;T&gt; to the inbox
            </summary>
      <typeparam name="TActor">
      </typeparam>
      <param name="configurator">
      </param>
    </member>
    <member name="T:Stact.AnonymousActor">
      <summary>
            An anonymous actor is used to declare behavior inline, rather than using a 
            class. 
            </summary>
    </member>
    <member name="T:Stact.Internal.CreateChannelConnection">
      <summary>
            Allows channels and disposable items to be added to the connection
            </summary>
    </member>
    <member name="M:Stact.Internal.CreateChannelConnection.AddChannel(Stact.Channel)">
      <summary>
            Adds a channel to the connection
            </summary>
      <param name="channel">
      </param>
    </member>
    <member name="M:Stact.Internal.CreateChannelConnection.AddDisposable(System.IDisposable)">
      <summary>
            Adds a disposable reference to the connection
            </summary>
      <param name="disposable">
      </param>
    </member>
    <member name="T:Stact.ChannelConnection">
      <summary>
            Contains the changes made by a connection to a channel so that they can be 
            removed when the connections are no longer required.
            </summary>
    </member>
    <member name="M:Stact.ChannelConnection.Disconnect">
      <summary>
            Disconnects any channels and/or consumers that were added by a Connect
            to a channel.
            </summary>
    </member>
    <member name="T:Stact.Configuration.ConnectionConfigurator`1">
      <summary>
            Used to configure the connections to be added to a typed Channel
            </summary>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="M:Stact.Extensions.Exit(Stact.UntypedChannel)">
      <summary>
              Sends an Exit message to an actor instance without waiting for a response
            </summary>
      <param name="instance">The actor instance</param>
    </member>
    <member name="M:Stact.Extensions.Exit(Stact.ActorRef,Stact.Inbox)">
      <summary>
              Sends an Exit message to an actor instance
            </summary>
      <param name="instance">The actor instance</param>
      <param name="sender">The exit request sender</param>
    </member>
    <member name="M:Stact.Extensions.Kill(Stact.UntypedChannel)">
      <summary>
              Sends a Kill message to an actor instance
            </summary>
      <param name="instance">The actor instance</param>
    </member>
    <member name="T:Stact.ChannelProvider`1">
      <summary>
            Used by dispatching channels to retrieve the appropriate channel for
            a message.
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="M:Stact.ChannelProvider`1.GetChannel(`0)">
      <summary>
            Get a channel for the message
            </summary>
      <param name="message">The message to use to select the channel</param>
      <returns>The channel that should process the message, or null</returns>
    </member>
    <member name="T:Stact.Internal.ActorChannelProvider`2">
      <summary>
              Provides a channel from an actor, based on the property information which is used
              to create a dynamic method that returns the actual channel
            </summary>
      <typeparam name="TActor">The actor type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="T:Stact.MessageHeaders.MatchHeaderCallback`1">
      <summary>
            Matches the header type and carries along a context value with the match
            </summary>
      <typeparam name="TContext">
      </typeparam>
    </member>
    <member name="P:Stact.MessageHeader.BodyType">
      <summary>
            The message body type in URN-format
            </summary>
    </member>
    <member name="P:Stact.MessageHeader.MessageId">
      <summary>
            The identifier for this message
            </summary>
    </member>
    <member name="P:Stact.MessageHeader.CorrelationId">
      <summary>
            The identifier correlating this message to a message exchange/conversation
            </summary>
    </member>
    <member name="P:Stact.MessageHeader.SenderAddress">
      <summary>
            The sender address of the message
            </summary>
    </member>
    <member name="P:Stact.MessageHeader.DestinationAddress">
      <summary>
            The final destination of the message
            </summary>
    </member>
    <member name="P:Stact.MessageHeader.FaultAddress">
      <summary>
            The address where faults should be sent
            </summary>
    </member>
    <member name="P:Stact.MessageHeader.Headers">
      <summary>
            A general headers collection
            </summary>
    </member>
    <member name="P:Stact.RequestHeader.RequestId">
      <summary>
              The request identifier which should be returned with a response
            </summary>
    </member>
    <member name="P:Stact.RequestHeader.ResponseAddress">
      <summary>
              The address where a response should be sent (use the response channel, however)
            </summary>
    </member>
    <member name="P:Stact.ResponseHeader.RequestId">
      <summary>
              The request identifier which should be returned with a response
            </summary>
    </member>
    <member name="T:Stact.Channel`1">
      <summary>
            A one-way communication containing messages of the specified type
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Stact.Channel`1.Send(`0)">
      <summary>
            Send a message to the channel
            </summary>
      <param name="message">The message to send</param>
    </member>
    <member name="T:Stact.Remote.ReliableMulticast.ReliableMulticastWriter">
      <summary>
            Sends messages via Pragmatic General Multicast
            </summary>
    </member>
    <member name="T:Stact.Remote.RemoteActor">
      <summary>
            A reference to a remote actor
            
            Forwards messages to the remote actor using the header channel specified in the constructor.
            </summary>
    </member>
    <member name="M:Stact.RequestExtensions.Request``1(Stact.UntypedChannel,``0,Stact.UntypedChannel)">
      <summary>
              Wraps the message in a request and sends it to the channel
            </summary>
      <typeparam name="TRequest">The type of the request message</typeparam>
      <param name="channel">The channel where the message should be sent</param>
      <param name="request">The request message</param>
      <param name="responseChannel">The channel where responses should be sent</param>
    </member>
    <member name="M:Stact.RequestExtensions.Request``1(Stact.Channel{Stact.Request{``0}},``0,Stact.UntypedChannel)">
      <summary>
              Wraps the message in a request and sends it to the channel
            </summary>
      <typeparam name="TRequest">The type of the request message</typeparam>
      <param name="channel">The channel where the message should be sent</param>
      <param name="request">The request message</param>
      <param name="responseChannel">The channel where responses should be sent</param>
    </member>
    <member name="M:Stact.RequestExtensions.Request``1(Stact.UntypedChannel,Stact.UntypedChannel)">
      <summary>
              Sends an uninitialized interface implementation as a request
            </summary>
      <typeparam name="TRequest">The request message type, which must be an interface</typeparam>
      <param name="channel">The target channel</param>
      <param name="responseChannel">The channel where responses should be sent</param>
    </member>
    <member name="M:Stact.RequestExtensions.Request``1(Stact.Channel{Stact.Request{``0}},Stact.UntypedChannel)">
      <summary>
              Sends an uninitialized interface implementation as a request
            </summary>
      <typeparam name="TRequest">The request message type, which must be an interface</typeparam>
      <param name="channel">The target channel</param>
      <param name="responseChannel">The channel where responses should be sent</param>
    </member>
    <member name="M:Stact.RequestExtensions.Request``1(Stact.UntypedChannel,``0,Stact.Inbox)">
      <summary>
              Wraps the message in a request and sends it to the channel
            </summary>
      <typeparam name="TRequest">The type of the request message</typeparam>
      <param name="channel">The channel where the message should be sent</param>
      <param name="request">The request message</param>
      <param name="inbox">The response inbox</param>
    </member>
    <member name="M:Stact.RespondExtensions.Respond``2(Stact.Request{``0},``1)">
      <summary>
              Wraps a message in a response and sends it to the response channel of the request
            </summary>
      <typeparam name="TRequest">The type of the request message</typeparam>
      <typeparam name="TResponse">The type of the response message</typeparam>
      <param name="request">The request context</param>
      <param name="response">The response message</param>
    </member>
    <member name="T:Stact.Routing.Activation`1">
      <summary>
            An Activation moves a message from left to right in the graph, forward-chained
            to the next node.
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="T:Stact.Message">
      <summary>
            The base message header, non-generic to allow use in any method
            </summary>
    </member>
    <member name="T:Stact.Message`1">
      <summary>
            The message header, generic matching the type of the message body
            </summary>
      <typeparam name="T">The message body type</typeparam>
    </member>
    <member name="M:Stact.Routing.RoutingContext`1.Match(System.Action{Stact.Routing.RoutingContext{Stact.Message{`0}}},System.Action{Stact.Routing.RoutingContext{Stact.Request{`0}}},System.Action{Stact.Routing.RoutingContext{Stact.Response{`0}}})">
      <summary>
            Matches the message header type an invokes the proper callback
            </summary>
      <param name="messageCallback">
      </param>
      <param name="requestCallback">
      </param>
      <param name="responseCallback">
      </param>
    </member>
    <member name="P:Stact.Routing.RoutingContext`1.Priority">
      <summary>
            as types are abstracted, proxied, etc. the priority value decreases
            </summary>
    </member>
    <member name="T:Stact.Request`1">
      <summary>
            Request is a message stereotype that is applied to a message in which
            a response is expected
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="P:Stact.Request`1.ResponseChannel">
      <summary>
              Where responses to the request should be sent
            </summary>
    </member>
    <member name="T:Stact.Response`1">
      <summary>
            Response is a message stereotype applied to a message that is in response
            to a Request message.
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="T:Stact.Routing.Nodes.ActiveContextList`1">
      <summary>
            An AlphaMemory retains a list of messages and automatically removes
            messages from the list when they are evicted from memory based on the
            context property IsAvailable
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Routing.Nodes.RightActivation`1">
      <summary>
            A RightActivation moves a message along the right side of the graph, which is
            referred to as the beta network or join network.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Stact.Routing.Nodes.RightActivation`1.RightActivate(System.Func{Stact.Routing.RoutingContext{`0},System.Boolean})">
      <summary>
            Performs a join operation between the two messages, performing the callback for
            every activation on the right node until the callback returns false
            </summary>
      <param name="callback">
      </param>
    </member>
    <member name="M:Stact.Routing.Nodes.RightActivation`1.RightActivate(Stact.Routing.RoutingContext{`0},System.Action{Stact.Routing.RoutingContext{`0}})">
      <summary>
            Performs a match operation between two activations, 
            </summary>
      <param name="context">
      </param>
      <param name="callback">
      </param>
    </member>
    <member name="T:Stact.Routing.Nodes.BetaMemory`1">
      <summary>
            A beta channel supports activation via a typed input and activates
            any successors upon receipt
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Routing.Nodes.ConstantNode`1">
      <summary>
            Always invokes on right activation for joining single alpha nodes
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Routing.Nodes.ProductionNode`1">
      <summary>
            The basic functionality of a production node that deals with
            evicting the message from the routing engine and dispatching it
            to the specified delegate
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="T:Stact.Routing.Nodes.ConsumerNode`1">
      <summary>
            Delivers a message to a consumer on the specified fiber.
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="T:Stact.Routing.Nodes.JoinNode`1">
      <summary>
            A JoinNode with a single type argument joins the output of the left side network
            to the right-side network. A single type will only join to the same message that 
            was passed through the left side network to the alpha nodes
            
            BetaMemory is used since it keeps track of all valid activations (joins)
            
            The unjoined messages are discarded (do they need to be kept, will right activations
            ever change, requiring a reevaluation of the join?)
            
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Routing.Nodes.SelectiveConsumerNode`1">
      <summary>
            Selectively delivers a message to a consumer on the specified fiber.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Stact.SendExtensions.Send``1(Stact.UntypedChannel)">
      <summary>
              Sends an uninitialized interface implementation
            </summary>
      <typeparam name="T">The request message type, which must be an interface</typeparam>
      <param name="channel">The target channel</param>
    </member>
    <member name="T:Stact.Internal.ThreadSingleton`2">
      <summary>
            Encapsulates a value such that only one instance is retained per thread,
            allowing concurrency without blocking on a shared lock for access to a 
            static variable.
            
            NOTE that this is NOT a global variable
            </summary>
      <typeparam name="TContainer">The container type, to ensure proper segregation from other contained types</typeparam>
      <typeparam name="T">The type to contain</typeparam>
    </member>
    <member name="T:Stact.Inbox">
      <summary>
              Mailbox is a higher level construct than a channel, providing channel aggregation,
              directed receives, and dispatching to channels within a context, such as an actor
            </summary>
    </member>
    <member name="M:Stact.Inbox.Receive``1(Stact.SelectiveConsumer{``0})">
      <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
      <typeparam name="T">The requested message type</typeparam>
      <param name="consumer">The consumer</param>
    </member>
    <member name="M:Stact.Inbox.Receive``1(Stact.SelectiveConsumer{``0},System.TimeSpan,System.Action)">
      <summary>
              Specifies a method to call when a message is recieved. If a message is not received within
              the specified timeout, a timeout callback is called instead and the receiver is removed from 
              the waiting list of receivers.
            </summary>
      <param name="consumer">The consumer to call with the message</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="M:Stact.Inbox.SetExceptionHandler(Stact.Actors.Actors.ActorExceptionHandler)">
      <summary>
            Sets the exception handler for the inbox
            </summary>
      <param name="handler">The exception handler</param>
    </member>
    <member name="T:Stact.Internal.ThreadStaticActorFactory`1">
      <summary>
              Maintains only one instance of an actor per thread
            </summary>
      <typeparam name="TActor">The actor type</typeparam>
    </member>
    <member name="T:Stact.Configuration.Builders.ConnectionBuilder">
      <summary>
            The root connection builder that is passed through the configurators to build connections
            </summary>
    </member>
    <member name="T:Stact.Configuration.FiberProviderConfigurator`2">
      <summary>
              Configures the type of fiber to be used for handling messages
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="M:Stact.Configuration.FiberProviderConfigurator`2.ShareFiberAcrossInstances">
      <summary>
              Share one fiber for every key value
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberProviderConfigurator`2.CreateFiberPerInstance">
      <summary>
              Create a new fiber for each key value
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Configuration.FiberProviderConfigurator`2.UseFiberProvider(Stact.FiberProvider{`1})">
      <summary>
              Specifies a specific fiber provider, which provides the fiber for each instance
            </summary>
      <param name="fiberProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Stact.Configuration.Internal.DistributedInstanceChannelConfigurator`3">
      <summary>
            An instance configuration that is distributed by a specified key
            </summary>
      <typeparam name="TInstance">
      </typeparam>
      <typeparam name="TChannel">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:Stact.Configuration.Internal.DistributedInstanceChannelConfiguratorImpl`3">
      <summary>
            Implements the factory that creates the instance channel backed by a 
            KeyedChannelProvider, which maintains an instance of the channel for each
            unique key value
            </summary>
      <typeparam name="TChannel">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
    </member>
    <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.Consumer{``0})">
      <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
      <typeparam name="T">The requested message type</typeparam>
      <param name="inbox">The inbox to receive the message from</param>
      <param name="consumer">The consumer</param>
    </member>
    <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.Consumer{``0},System.TimeSpan,System.Action)">
      <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
      <typeparam name="T">The requested message type</typeparam>
      <param name="inbox">The inbox to receive the message from</param>
      <param name="consumer">The consumer</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.Consumer{``0},System.Int32,System.Action)">
      <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
      <typeparam name="T">The requested message type</typeparam>
      <param name="inbox">The inbox to receive the message from</param>
      <param name="consumer">The consumer</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.SelectiveConsumer{``0},System.Int32,System.Action)">
      <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
      <typeparam name="T">The requested message type</typeparam>
      <param name="inbox">The inbox to receive the message from</param>
      <param name="consumer">The consumer</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="P:Stact.Response`2.Request">
      <summary>
            The request to which this response is correlated
            </summary>
    </member>
    <member name="T:Stact.Internal.SentRequestImpl`1">
      <summary>
              A decorator for sent requests that enables method chaining
            </summary>
      <typeparam name="TRequest">
      </typeparam>
    </member>
    <member name="T:Stact.TypedChannelAdapter`1">
      <summary>
            Converts an untyped channel to a typed channel, passing only messages
            which can be assigned to the channel type and discarding all others
            </summary>
      <typeparam name="TOutput">The output channel type</typeparam>
    </member>
    <member name="T:Stact.Internal.ActorInbox`1">
      <summary>
              An inbox for an actor. Channel properties on the actor are automatically bound.
              Messages are automatically delivered to the inbox for each message type unless
              a property channel has the same message type. Calling Receive on the inbox will
            </summary>
      <typeparam name="TActor">The actor type for this inbox</typeparam>
    </member>
    <member name="T:Stact.Configuration.Internal.WcfConnectionConfiguratorImpl">
      <summary>
            Exposes the configuration options for a WcfProxy
            </summary>
    </member>
    <member name="T:Stact.InstanceProvider`2">
      <summary>
            Used to obtain and instance of a class based on the information contained
            in the specified message
            </summary>
      <typeparam name="TInstance">The type of the class</typeparam>
      <typeparam name="TChannel">The type of the message</typeparam>
    </member>
    <member name="T:Stact.Internal.AsyncResult">
      <summary>
            A callback-only version of the AsyncResult callback
            </summary>
    </member>
    <member name="T:Stact.ChannelFactory`1">
      <summary>
            Implemented by classes that can create channels. The factory method is used
            to create channels outside of any message delivery context. If the content
            of the message is important in the creation of the channel, the ChannelProvider is a 
            better choice to use since it passes the message as part of the channel acquisition
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Stact.ChannelFactory`1.GetChannel">
      <summary>
            Returns the channel
            </summary>
      <returns>A channel instance</returns>
    </member>
    <member name="T:Stact.Configuration.ChannelConfigurationException">
      <summary>
            Thrown when an invalid configuration is supplied when configuring a channel
            </summary>
    </member>
    <member name="T:Stact.Configuration.Internal.DistinctConfigurator`2">
      <summary>
            Used to configure the options on a channel that delivers messages at regular
            intervals
            </summary>
      <typeparam name="TChannel">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="M:Stact.ExtensionsForConsumerChannel.AddConsumer``1(Stact.Configuration.ConnectionConfigurator{``0},Stact.Consumer{``0})">
      <summary>
            Add a consumer to the channel using the message type defined for the channel
            </summary>
      <typeparam name="TChannel">The channel type, specifies the type of message sent by the channel</typeparam>
      <param name="connectionConfigurator">The connection configurator</param>
      <param name="consumer">The consumer to add to the channel</param>
      <returns>A consumer configurator to customize the consumer settings</returns>
    </member>
    <member name="M:Stact.ExtensionsForConsumerChannel.UsingConsumer``1(Stact.Configuration.ChannelConfigurator{``0},Stact.Consumer{``0})">
      <summary>
            Consumes the message on a ConsumerChannel, given the specified delegate
            </summary>
      <param name="configurator">
      </param>
      <param name="consumer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.ExtensionsForIntervalChannels.BufferFor``1(Stact.Configuration.ChannelConfigurator{``0},System.TimeSpan)">
      <summary>
            Specifies an interval at which the consumer should be called with a collection
            of messages received during that period.
            </summary>
      <param name="configurator">
      </param>
      <param name="interval">The time period of each interval</param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.ExtensionsForSelectiveConsumerChannel.AddSelectiveConsumer``1(Stact.Configuration.ConnectionConfigurator{``0},Stact.SelectiveConsumer{``0})">
      <summary>
            Add a consumer to the channel using the message type defined for the channel
            </summary>
      <typeparam name="TChannel">The channel type, specifies the type of message sent by the channel</typeparam>
      <param name="connectionConfigurator">The connection configurator</param>
      <param name="consumer">The consumer to add to the channel</param>
      <returns>A consumer configurator to customize the consumer settings</returns>
    </member>
    <member name="M:Stact.ExtensionsForSelectiveConsumerChannel.UsingSelectiveConsumer``1(Stact.Configuration.ChannelConfigurator{``0},Stact.SelectiveConsumer{``0})">
      <summary>
            Consumes the message on a SelectiveConsumerChannel given the specified delegate
            </summary>
      <param name="configurator">
      </param>
      <param name="selectiveConsumer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.ExtensionsForAddConsumer.AddConsumerOf``1(Stact.Configuration.ConnectionConfigurator)">
      <summary>
            Add a consumer of the specified message type
            </summary>
      <typeparam name="TChannel">The channel type</typeparam>
      <returns>A chainable method to configure additional options</returns>
    </member>
    <member name="T:Stact.Configuration.Internal.InstanceConfigurator`2">
      <summary>
            A fluent syntax for configuration options of a channel consumer
            </summary>
      <typeparam name="TInstance">The consumer type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="T:Stact.Configuration.Internal.IntervalConfigurator`1">
      <summary>
            Used to configure the options on a channel that delivers messages at regular
            intervals
            </summary>
      <typeparam name="TChannel">
      </typeparam>
    </member>
    <member name="T:Stact.Configuration.Internal.LastConfigurator`1">
      <summary>
            Used to configure the last channel 
            </summary>
      <typeparam name="TChannel">
      </typeparam>
    </member>
    <member name="T:Stact.Future`1">
      <summary>
            A future object that supports both callbacks and asynchronous waits once a future value becomes available.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.InstanceChannelProvider`2">
      <summary>
            Gets an instance of a class from the InstanceProvider and returns the channel
            from that class
            </summary>
      <typeparam name="TInstance">The instance type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="T:Stact.SelectiveConsumerChannel`1">
      <summary>
            A channel that accepts a message and enqueues the consumer method via the
            specified Fiber
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Stact.SelectiveConsumerChannel`1.#ctor(Stact.Fiber,Stact.SelectiveConsumer{`0})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="selectiveConsumer">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Stact.WcfChannelHost">
      <summary>
            Receives messages from a named pipe via WCF and forwards them to the specific channel. Messages
            are first serialized to a wire type that is already WCF compliant, making it unnecessary to decorate
            your message objects with WCF data contract serializer attributes.
            </summary>
    </member>
    <member name="T:Stact.WcfChannelHost`1">
      <summary>
            Receives messages from a named pipe via WCF and forwards it to the output
            channel. Message serialization is handled entirely by WCF and therefore
            requires that classes are appropriately decorated.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Configuration.ConnectionConfigurator">
      <summary>
            Used to configure the connections to be added to an UntypedChannel
            </summary>
    </member>
    <member name="T:Stact.ChannelAdapter">
      <summary>
            A channel adapter is a mutable segment in a channel network. The output channel can
            be replaced, allowing a new channel network (built via a ChannelVisitor) to be installed
            in response to changes (attachments, detachments, etc.) to the network.
            
            This particular version handles untyped channels
            </summary>
    </member>
    <member name="T:Stact.ChannelAdapter`1">
      <summary>
            A channel adapter is a mutable segment in a channel network. The output channel can
            be replaced, allowing a new channel network (built via a ChannelVisitor) to be installed
            in response to changes (attachments, detachments, etc.) to the network.
            
            This particular version handles typed channels
            </summary>
    </member>
    <member name="T:Stact.Internal.UntypedChannelConnection">
      <summary>
            The channel connection implementation
            </summary>
    </member>
    <member name="T:Stact.DeserializeMessageEnvelopeChannel`1">
      <summary>
            Accepts a MessageEnvelope as input and deserializes the message body on the supplied fiber,
            after which the message object is sent to the untyped output channel.
            </summary>
      <typeparam name="T">The input message type, which must implement MessageEnvelope</typeparam>
    </member>
    <member name="M:Stact.DeserializeMessageEnvelopeChannel`1.#ctor(Stact.Fiber,Magnum.Serialization.Serializer,Stact.UntypedChannel)">
      <summary>
            Constructs an instance
            </summary>
      <param name="fiber">The fiber used to perform message deserialization</param>
      <param name="serializer">The serializer to use on the message body</param>
      <param name="output">The output channel for the deserialized message</param>
    </member>
    <member name="T:Stact.Internal.WcfChannel`1">
      <summary>
              A single generic channel type used for local channels via WCF/named pipes
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Internal.WcfChannelService`1">
      <summary>
              Handles the server end of a WCF channel connection
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Stact.SelectiveConsumer`1">
      <summary>
              A conditional consumer is given a message to evaluate, after which it
              can determine if it is interested in the message and return an action
              to process the message or null
            </summary>
      <typeparam name="T">The message type</typeparam>
      <param name="message">The message</param>
      <returns>An action to consume the message, or null</returns>
    </member>
    <member name="T:Stact.ShuntChannel">
      <summary>
            Implements a channel shunt, discarding any message that is send without action
            </summary>
    </member>
    <member name="T:Stact.ShuntChannel`1">
      <summary>
            Implements a channel shunt, discarding any message that is send without action
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Routing.RoutingEngine">
      <summary>
            A routing engine managed the distribution of messages to consumers using
            a rules engine style to allow for highly complex routing rules without
            custom application coding
            </summary>
    </member>
    <member name="M:Stact.ExtensionsToScheduler.Schedule(Stact.Scheduler,System.Int32,Stact.Fiber,System.Action)">
      <summary>
            Schedules an operation to be executed after the special interval has elapsed
            </summary>
      <param name="scheduler">The scheduler to reference</param>
      <param name="interval">The duration of the interval</param>
      <param name="fiber">The fiber where the operation should be added</param>
      <param name="operation">The operation to execute</param>
      <returns>A ScheduledOperation reference</returns>
    </member>
    <member name="M:Stact.ExtensionsToScheduler.Schedule(Stact.Scheduler,System.Int32,System.Int32,Stact.Fiber,System.Action)">
      <summary>
            Schedules an operation to be executed after the special interval has elapsed and
            every periodic interval after the initial execution
            </summary>
      <param name="scheduler">The scheduler to reference</param>
      <param name="interval">The duration of the interval</param>
      <param name="periodicInterval">The periodic interval between subsequent executions</param>
      <param name="fiber">The fiber where the operation should be added</param>
      <param name="operation">The operation to execute</param>
      <returns>A ScheduledOperation reference</returns>
    </member>
    <member name="T:Stact.Configuration.FiberConfigurationException">
      <summary>
            Thrown when an invalid configuration is supplied when configuring a channel
            </summary>
    </member>
    <member name="T:Stact.Internal.DisposeCallback">
      <summary>
            Wraps a callback as an IDisposable to allow it to be called when the object is disposed.
            </summary>
    </member>
    <member name="M:Stact.ExtensionsToFiber.ShutdownOnDispose(Stact.Fiber,System.TimeSpan)">
      <summary>
              Creates a disposable object that calls Shutdown on the fiber when it is
              disposed
            </summary>
      <param name="fiber">The fiber to shutdown</param>
      <param name="timeout">The timeout to wait for the shutdown to complete</param>
      <returns>An IDisposable object</returns>
    </member>
    <member name="M:Stact.ExtensionsToFiber.StopOnDispose(Stact.Fiber)">
      <summary>
              Creates a disposable object that calls Stop on the fiber when it is
              disposed
            </summary>
      <param name="fiber">The fiber to stop</param>
      <returns>An IDisposable object</returns>
    </member>
    <member name="M:Stact.ExtensionsToFiber.Shutdown(Stact.Fiber)">
      <summary>
            Signals the fiber to shut down, but does not wait for the remaining operations
            to be executed
            </summary>
      <param name="fiber">
      </param>
    </member>
    <member name="T:Stact.FiberProvider`1">
      <summary>
            Returns a fiber appropriate for the specified key
            
            Designed for use with cases where there are multiple channels needed
            for a particular object and the fiber needs to be acquired
            </summary>
      <typeparam name="TKey">The key type</typeparam>
    </member>
    <member name="T:Stact.Internal.KeyedFiberProvider`1">
      <summary>
            Keeps track of a keyed fiber collection
            </summary>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="M:Stact.Fiber.Add(System.Action)">
      <summary>
            Enqueue a single action to the queue
            </summary>
      <param name="operation">
      </param>
    </member>
    <member name="M:Stact.Fiber.Shutdown(System.TimeSpan)">
      <summary>
            Runs all remaining actions, waiting until all actions have been executed or until the
            timeout expires. If the timeout expires, an exception is thrown.
            </summary>
      <param name="timeout">The time to wait for all pending actions to be executed before throwing an exception</param>
    </member>
    <member name="M:Stact.Fiber.Stop">
      <summary>
            Stops the fiber, discards any remaining actions, and prevents new actions from being added
            </summary>
    </member>
    <member name="M:Stact.Scheduler.Schedule(System.TimeSpan,Stact.Fiber,System.Action)">
      <summary>
            Schedules an operation to be executed after the special interval has elapsed
            </summary>
      <param name="interval">The duration of the interval</param>
      <param name="fiber">The fiber where the operation should be added</param>
      <param name="operation">The operation to execute</param>
      <returns>A ScheduledOperation reference</returns>
    </member>
    <member name="M:Stact.Scheduler.Schedule(System.TimeSpan,System.TimeSpan,Stact.Fiber,System.Action)">
      <summary>
            Schedules an operation to be executed after the special interval has elapsed and
            every periodic interval after the initial execution
            </summary>
      <param name="interval">The duration of the interval</param>
      <param name="periodicInterval">The periodic interval between subsequent executions</param>
      <param name="fiber">The fiber where the operation should be added</param>
      <param name="operation">The operation to execute</param>
      <returns>A ScheduledOperation reference</returns>
    </member>
    <member name="M:Stact.Scheduler.Stop(System.TimeSpan)">
      <summary>
            Disables the scheduler, preventing any further scheduled operations from being executed
            </summary>
      <param name="timeout">The time period to wait for the scheduler to shutdown</param>
    </member>
    <member name="M:Stact.ScheduledOperation.Cancel">
      <summary>
              Cancels the scheduled operation, ensuring that it does not execute
            </summary>
    </member>
    <member name="P:Stact.ScheduledOperation.ScheduledAt">
      <summary>
              The time coordinates when the operation is scheduled to execute
            </summary>
    </member>
    <member name="T:Stact.SynchronousFiber">
      <summary>
              A synchronous fiber will execute an action immediately on the calling thread
              without any protection from an exception
            </summary>
    </member>
    <member name="T:Stact.PoolFiber">
      <summary>
            An Fiber that uses the .NET ThreadPool and QueueUserWorkItem to execute
            actions.
            </summary>
    </member>
    <member name="T:Stact.AsyncResultChannel">
      <summary>
            Wraps a channel in an IAsyncResult compatible wrapper to support asynchronous usage with
            frameworks that support asynchronous callbacks
            </summary>
    </member>
    <member name="T:Stact.AsyncResultChannel`1">
      <summary>
            Wraps a channel in an IAsyncResult compatible wrapper to support asynchronous usage with
            frameworks that support asynchronous callbacks
            </summary>
      <typeparam name="T">The channel type supported</typeparam>
    </member>
    <member name="T:Stact.ChannelAccessor`2">
      <summary>
            Provides a channel from an instance
            </summary>
      <typeparam name="TInstance">The type of instance being accessed</typeparam>
      <typeparam name="T">The type of channel to return</typeparam>
      <param name="instance">The instance to retrieve the channel from</param>
      <returns>The channel of the requested type from the instance</returns>
    </member>
    <member name="T:Stact.ConsumerChannel`1">
      <summary>
            A channel that accepts a message and enqueues the consumer method via the
            specified Fiber
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Stact.ConsumerChannel`1.#ctor(Stact.Fiber,Stact.Consumer{`0})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="consumer">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Stact.Consumer`1">
      <summary>
            A consumer delegate, which can be assigned to any method that takes a message as an argument,
            including Actions, void methods, etc.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="message">
      </param>
    </member>
    <member name="T:Stact.DelegateChannelProvider`1">
      <summary>
            Wraps an anonymous method in a ChannelProvider
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="M:Stact.Interceptor`1.OnSend(`0)">
      <summary>
            Called before a message is delivered to the output channel
            </summary>
      <param name="message">The message being delivered</param>
      <returns>The message passed, a modified message, or null to discard the message</returns>
    </member>
    <member name="M:Stact.Interceptor`1.OnException(System.Exception)">
      <summary>
            Called when an exception is returned during delivery to the output channel
            </summary>
      <param name="exception">The exception that occurred</param>
    </member>
    <member name="M:Stact.Interceptor`1.OnComplete">
      <summary>
            Called when a message has been successfully delivered to the output channel
            </summary>
    </member>
    <member name="T:Stact.InterceptorChannel`1">
      <summary>
            An interceptor channel can be placed in front of any other channel and provides
            the ability to intercept sends to the wrapper channel and modify the message that
            is sent. An additional method is also called once the message has been processed by
            the wrapped channel
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Stact.InterceptorFactory`1">
      <summary>
            Provides an instance of an interceptor for an InterceptorChannel to
            handle the interception of messages on channels
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="M:Stact.InterceptorFactory`1.GetInterceptor(`0)">
      <summary>
            Returns an instance of an interceptor
            </summary>
      <param name="message">The message being delivered</param>
      <returns>An interceptor</returns>
    </member>
    <member name="T:Stact.DistinctChannel`2">
      <summary>
            A channel that converts a collection of messages into a dictionary of distinct
            messages by the specified key
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
      <typeparam name="TKey">The type of the key for the message</typeparam>
    </member>
    <member name="M:Stact.DistinctChannel`2.#ctor(Stact.Fiber,Stact.KeyAccessor{`0,`1},Stact.Channel{System.Collections.Generic.IDictionary{`1,`0}})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="keyAccessor">Returns the key for the message</param>
      <param name="output">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Stact.InstanceChannel`1">
      <summary>
            An instance channel requests an instance of a channel which can be created/loaded
            based on the information in the message being sent on the channel
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Stact.Internal.MessageList`1">
      <summary>
            Encapsulates a collection of messages
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="M:Stact.Internal.MessageList`1.Add(`0)">
      <summary>
            Adds a message to the list
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="M:Stact.Internal.MessageList`1.RemoveAll">
      <summary>
            Removes all messages from the list
            </summary>
      <returns>A list of messages that were removed from the list</returns>
    </member>
    <member name="T:Stact.IntervalChannel`1">
      <summary>
            A channel that accepts messages and sends them to the channel at regular intervals
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Stact.IntervalChannel`1.#ctor(Stact.Fiber,Stact.Scheduler,System.TimeSpan,Stact.Channel{System.Collections.Generic.ICollection{`0}})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="scheduler">The scheduler to use for scheduling calls to the consumer</param>
      <param name="interval">The interval between calls to the consumer</param>
      <param name="output">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Stact.KeyAccessor`2">
      <summary>
            Returns the key for the given source
            </summary>
      <typeparam name="T">The type of the source from which the key is to be retrieved</typeparam>
      <typeparam name="TKey">The type of the key to return</typeparam>
      <param name="source">The source from which to retrieve the key</param>
      <returns>The value of the key for the source</returns>
    </member>
    <member name="T:Stact.LastChannel`1">
      <summary>
            Forwards the last message in the set of messages to the next channel
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="T:Stact.FilterChannel`1">
      <summary>
              A channel that selectively accepts a message and enqueues the consumer method via the
              specified Fiber.
              Note that the filter function is called as part of the queued action, so threading
              is not an issue.
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Stact.FilterChannel`1.#ctor(Stact.Fiber,Stact.Channel{`0},Stact.Filter{`0})">
      <summary>
              Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="output">The method to call when a message is sent to the channel</param>
      <param name="filter">The filter to determine if the message can be consumed</param>
    </member>
    <member name="T:Stact.BroadcastChannel">
      <summary>
            A BroadcastChannel sends a message to zero or more listeners
            </summary>
    </member>
    <member name="T:Stact.BroadcastChannel`1">
      <summary>
            A BroadcastChannel sends a message to zero or more listeners
            </summary>
      <typeparam name="T">Channel type</typeparam>
    </member>
    <member name="T:Stact.SynchronizedChannel">
      <summary>
            Using the specified SynchronizationContext, messages sent through this channel
            will be delivered on the specified user interface thread, to avoid issues when
            writing to the UI
            </summary>
    </member>
    <member name="T:Stact.SynchronizedChannel`1">
      <summary>
            Using the specified SynchronizationContext, messages sent through this channel
            will be delivered on the specified user interface thread, to avoid issues when
            writing to the UI
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Stact.ThreadPoolChannel`1">
      <summary>
            Keeps a fixed number of channels available, which presumably are doing some form of synchronous processing
            of messages, to avoid too many consumers running at the same time
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Stact.ThreadStaticChannelProvider`1">
      <summary>
            Provides an instance of a channel per thread for situations where the
            processing of a channel should be done per-thread to avoid bottlenecks
            
            This should not be used in cases where the channel maintains state
            between calls since threads may change and ordering cannot be guaranteed
            </summary>
      <typeparam name="T">The message type of the channel</typeparam>
    </member>
    <member name="T:Stact.ConvertChannel`2">
      <summary>
              Tranforms a message from one type to another
            </summary>
      <typeparam name="TInput">Input message type</typeparam>
      <typeparam name="TOutput">Output message type</typeparam>
    </member>
    <member name="T:Stact.StateMachine.ChannelConfiguration.CacheChannelProvider`2">
      <summary>
            Gets an instance of a class from the InstanceProvider and returns the channel
            from that class
            </summary>
      <typeparam name="TChannel">The channel type</typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:Stact.InstanceChannelPolicy`2">
      <summary>
            Defines the instance policy for a regarding a particular event
            </summary>
      <typeparam name="T">The state machine type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="M:Stact.InstanceChannelPolicy`2.CanCreateInstance(`1,`0@)">
      <summary>
            Returns true if the message can create a new instance
            </summary>
      <param name="message">The message received</param>
      <param name="instance">The instance created</param>
      <returns>True if the new instance could be created</returns>
    </member>
    <member name="M:Stact.InstanceChannelPolicy`2.IsHandledByExistingInstance(`1)">
      <summary>
            Checks if the message can be handled by an existing instance
            </summary>
      <param name="message">The message received</param>
      <returns>True if the message should be delivered to the instance, otherwise false</returns>
    </member>
    <member name="M:Stact.InstanceChannelPolicy`2.WasNotHandled(`1)">
      <summary>
            Called when a message was not handled by an instance
            </summary>
      <param name="message">The message that was not handled</param>
    </member>
    <member name="M:Stact.InstanceChannelPolicy`2.CanUnloadInstance(`0)">
      <summary>
            Checks if an instance can be unloaded
            </summary>
      <param name="instance">The instance to check</param>
      <returns>True if the instance can be unloaded from memory</returns>
    </member>
    <member name="M:Stact.InstanceChannelPolicy`2.CanRemoveInstance(`0)">
      <summary>
            Checks if an instance can be removed/destroyed
            </summary>
      <param name="instance">The instance to check</param>
      <returns>True if the instance can be removed from storage</returns>
    </member>
    <member name="T:Stact.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2">
      <summary>
            Describes an event, received by a state machine, and the in which that event is valid
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:Stact.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2.Event">
      <summary>
            The event received by the state machine
            </summary>
    </member>
    <member name="P:Stact.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2.AcceptingStates">
      <summary>
            The states in which the event can be delivered to the state machine
            </summary>
    </member>
    <member name="T:Stact.Workflow.Internal.AcceptStateMachineVisitor">
      <summary>
            Implemented by objects that accept a StateMachineVisitor for discovery
            </summary>
    </member>
    <member name="T:Stact.Workflow.WorkflowDefinition">
      <summary>
            Exposes the metadata of a state machine workflow
            </summary>
    </member>
    <member name="M:Stact.Workflow.WorkflowDefinition.GetState(System.String)">
      <summary>
            Retrieves the named state for the state machine workflow
            </summary>
      <param name="name">The name of the state</param>
      <returns>The configured State</returns>
    </member>
    <member name="M:Stact.Workflow.WorkflowDefinition.GetEvent(System.String)">
      <summary>
            Retrieves the named event for the state machine workflow
            </summary>
      <param name="name">The name of the event</param>
      <returns>The Event</returns>
    </member>
    <member name="T:Stact.Workflow.StateMachineWorkflow`2">
      <summary>
            A state machine workflow encapsulates the definition of a state machine behind a 
            workflow interface. The interface can be used to apply the state machine behavior
            to a class instance. It can also be visited to graph the state machineb behavior 
            for user review.
            </summary>
      <typeparam name="TWorkflow">The interface that defines the states and events for the workflow</typeparam>
      <typeparam name="TInstance">The instance that is used to track the state</typeparam>
    </member>
    <member name="P:Stact.Workflow.State.Entry">
      <summary>
            Triggered when the state becomes the current state
            </summary>
    </member>
    <member name="P:Stact.Workflow.State.Exit">
      <summary>
            Triggered when the instance is transitioned to another state
            </summary>
    </member>
    <member name="M:Stact.Workflow.ThenExtensions.Then``2(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1},System.Action{``1})">
      <summary>
            Invoke an action with the state machine instance
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="activityConfigurator">
      </param>
      <param name="action">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.ThenExtensions.Then``3(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1,``2},System.Action{``1,``2})">
      <summary>
            Invoke an action with the state machine instance and the body of the message event
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <typeparam name="TBody">
      </typeparam>
      <param name="activityConfigurator">
      </param>
      <param name="eventAction">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.During``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.State}})">
      <summary>
            Selects a state to which events can be added
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="stateMachineConfigurator">
      </param>
      <param name="stateExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Initially``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1})">
      <summary>
            The initial state for a workflow (named Initial) to which events can be attached
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="stateMachineConfigurator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Finally``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1})">
      <summary>
            Finally is triggered upon entry to the Final state
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="stateMachineConfigurator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Finally``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1},System.Action{Stact.Workflow.Configuration.ActivityConfigurator{``0,``1}})">
      <summary>
            Finally is triggered upon entry to the Final state
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="stateMachineConfigurator">
      </param>
      <param name="configurationAction">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.When``2(Stact.Workflow.Configuration.StateConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.Event}})">
      <summary>
            Selects an event that is accepted during the specified state
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="stateConfigurator">
      </param>
      <param name="eventExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.When``3(Stact.Workflow.Configuration.StateConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.Event{``2}}})">
      <summary>
            Selects an event that is accepted during the specified state
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <typeparam name="TBody">
      </typeparam>
      <param name="stateConfigurator">
      </param>
      <param name="eventExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Finalize``2(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1})">
      <summary>
            Transition the state machine workflow to the Final state
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="activityConfigurator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Stact.Workflow.WorkflowInstance`1.CurrentState">
      <summary>
            Returns the current state for the instance
            </summary>
    </member>
    <member name="M:Stact.Workflow.TransitionToExtensions.TransitionTo``2(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.State}})">
      <summary>
            Transition the state machine to the specified state
            </summary>
      <typeparam name="TWorkflow">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
      <param name="activityConfigurator">
      </param>
      <param name="targetStateExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Stact.Workflow.WorkflowInstanceExtensions.GetInstance``2(Stact.Workflow.StateMachineWorkflow{``0,``1},``1)">
      <summary>
            Wraps an instance so that it can be passed without the TInstance dependency
            </summary>
      <param name="workflow">The workflow</param>
      <param name="instance">The instance to wrap</param>
      <returns>
      </returns>
    </member>
  </members>
</doc>